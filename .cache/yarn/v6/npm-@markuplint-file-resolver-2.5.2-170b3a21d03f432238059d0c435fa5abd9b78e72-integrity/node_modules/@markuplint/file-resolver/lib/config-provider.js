"use strict";
var _ConfigProvider_store, _ConfigProvider_cache, _ConfigProvider_held, _ConfigProvider_recursiveLoadKeyAndDepth, _ConfigProvider_watch;
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConfigProvider = void 0;
const tslib_1 = require("tslib");
const path_1 = tslib_1.__importDefault(require("path"));
const ml_config_1 = require("@markuplint/ml-config");
const ml_core_1 = require("@markuplint/ml-core");
const cosmiconfig_1 = require("./cosmiconfig");
const resolve_plugins_1 = require("./resolve-plugins");
const utils_1 = require("./utils");
const KEY_SEPARATOR = '__ML_CONFIG_MERGE__';
class ConfigProvider {
    constructor(watch) {
        _ConfigProvider_store.set(this, new Map());
        _ConfigProvider_cache.set(this, new Map());
        _ConfigProvider_held.set(this, new Set());
        _ConfigProvider_recursiveLoadKeyAndDepth.set(this, new Map());
        _ConfigProvider_watch.set(this, void 0);
        tslib_1.__classPrivateFieldSet(this, _ConfigProvider_watch, true, "f");
    }
    set(config, key) {
        key = key || (0, utils_1.uuid)();
        tslib_1.__classPrivateFieldGet(this, _ConfigProvider_store, "f").set(key, config);
        return key;
    }
    async search(targetFile) {
        if (!(await targetFile.dirExists())) {
            return null;
        }
        const res = await (0, cosmiconfig_1.search)(targetFile.path, tslib_1.__classPrivateFieldGet(this, _ConfigProvider_watch, "f"));
        if (!res) {
            return null;
        }
        const { filePath, config } = res;
        const pathResolvedConfig = this._pathResolve(config, filePath);
        tslib_1.__classPrivateFieldGet(this, _ConfigProvider_store, "f").set(filePath, pathResolvedConfig);
        return filePath;
    }
    async resolve(targetFile, names, remerge = false) {
        const keys = names.filter(utils_1.nonNullableFilter);
        const key = keys.join(KEY_SEPARATOR);
        const currentConfig = tslib_1.__classPrivateFieldGet(this, _ConfigProvider_cache, "f").get(key);
        if (!remerge && currentConfig) {
            return currentConfig;
        }
        let configSet = await this._mergeConfigs(keys);
        const plugins = await (0, resolve_plugins_1.resolvePlugins)(configSet.config.plugins);
        if (tslib_1.__classPrivateFieldGet(this, _ConfigProvider_held, "f").size) {
            const extendHelds = Array.from(tslib_1.__classPrivateFieldGet(this, _ConfigProvider_held, "f").values());
            extendHelds.forEach(held => {
                var _a;
                const [, prefix, namespace, name] = held.match(/^([a-z]+:)([^/]+)(?:\/(.+))?$/) || [];
                switch (prefix) {
                    case 'plugin:': {
                        const plugin = plugins.find(plugin => plugin.name === namespace);
                        const config = (_a = plugin === null || plugin === void 0 ? void 0 : plugin.configs) === null || _a === void 0 ? void 0 : _a[name];
                        if (config) {
                            this.set(config, held);
                        }
                        break;
                    }
                    case 'markuplint:': {
                        const config = ml_core_1.configs[namespace];
                        if (config) {
                            this.set(config, held);
                        }
                        break;
                    }
                }
            });
            configSet = await this._mergeConfigs([...keys, ...extendHelds]);
            tslib_1.__classPrivateFieldGet(this, _ConfigProvider_held, "f").clear();
        }
        // Resolves `overrides`
        if (configSet.config.overrides) {
            const overrides = configSet.config.overrides;
            const globs = Object.keys(overrides);
            for (const glob of globs) {
                const isMatched = targetFile.matches(glob);
                if (isMatched) {
                    // Note: Original config disappears
                    configSet.config = overrides[glob];
                }
            }
        }
        const result = {
            ...configSet,
            plugins,
        };
        tslib_1.__classPrivateFieldGet(this, _ConfigProvider_cache, "f").set(key, result);
        return result;
    }
    async _mergeConfigs(keys) {
        const resolvedKeys = new Set();
        const errs = [];
        for (const key of keys) {
            tslib_1.__classPrivateFieldGet(this, _ConfigProvider_recursiveLoadKeyAndDepth, "f").clear();
            const keySet = await this._recursiveLoad(key);
            for (const k of keySet.stack) {
                resolvedKeys.add(k);
            }
            if (keySet.errs) {
                errs.push(...keySet.errs);
            }
        }
        const configs = Array.from(resolvedKeys)
            .map(name => tslib_1.__classPrivateFieldGet(this, _ConfigProvider_store, "f").get(name))
            .filter(utils_1.nonNullableFilter);
        let resultConfig = {};
        for (const config of configs) {
            resultConfig = (0, ml_config_1.mergeConfig)(resultConfig, config);
        }
        return {
            config: resultConfig,
            files: resolvedKeys,
            errs,
        };
    }
    async _recursiveLoad(key, depth = 1) {
        const stack = new Set();
        const errs = [];
        const ancestorDepth = tslib_1.__classPrivateFieldGet(this, _ConfigProvider_recursiveLoadKeyAndDepth, "f").get(key);
        if (ancestorDepth != null && ancestorDepth < depth) {
            return {
                stack,
                errs: [new CircularReferenceError(`Circular reference detected: ${key}`)],
            };
        }
        tslib_1.__classPrivateFieldGet(this, _ConfigProvider_recursiveLoadKeyAndDepth, "f").set(key, depth);
        let config = tslib_1.__classPrivateFieldGet(this, _ConfigProvider_store, "f").get(key) || null;
        if (!config) {
            config = await this._load(key);
        }
        if (!config) {
            return { stack, errs: null };
        }
        const depKeys = config.extends ? (Array.isArray(config.extends) ? config.extends : [config.extends]) : null;
        if (depKeys) {
            for (const depKey of depKeys) {
                const keys = await this._recursiveLoad(depKey, depth + 1);
                for (const key of keys.stack) {
                    stack.add(key);
                }
                if (keys.errs) {
                    errs.push(...keys.errs);
                }
            }
        }
        stack.add(key);
        return { stack, errs };
    }
    async _load(filePath) {
        const entity = tslib_1.__classPrivateFieldGet(this, _ConfigProvider_store, "f").get(filePath);
        if (entity) {
            return entity;
        }
        if (isPrefixedName(filePath)) {
            tslib_1.__classPrivateFieldGet(this, _ConfigProvider_held, "f").add(filePath);
            return null;
        }
        if (!moduleExists(filePath) && !path_1.default.isAbsolute(filePath)) {
            throw new TypeError(`${filePath} is not an absolute path`);
        }
        const config = await load(filePath, tslib_1.__classPrivateFieldGet(this, _ConfigProvider_watch, "f"));
        if (!config) {
            return null;
        }
        const pathResolvedConfig = this._pathResolve(config, filePath);
        tslib_1.__classPrivateFieldGet(this, _ConfigProvider_store, "f").set(filePath, pathResolvedConfig);
        return pathResolvedConfig;
    }
    _pathResolve(config, filePath) {
        const dir = path_1.default.dirname(filePath);
        return {
            ...config,
            extends: pathResolve(dir, config.extends),
            plugins: pathResolve(dir, config.plugins, ['name']),
            parser: pathResolve(dir, config.parser),
            specs: pathResolve(dir, config.specs),
            excludeFiles: pathResolve(dir, config.excludeFiles),
            overrides: pathResolve(dir, config.overrides, undefined, true),
        };
    }
}
exports.ConfigProvider = ConfigProvider;
_ConfigProvider_store = new WeakMap(), _ConfigProvider_cache = new WeakMap(), _ConfigProvider_held = new WeakMap(), _ConfigProvider_recursiveLoadKeyAndDepth = new WeakMap(), _ConfigProvider_watch = new WeakMap();
async function load(filePath, watch) {
    if (!(0, utils_1.fileExists)(filePath) && moduleExists(filePath)) {
        const mod = await Promise.resolve().then(() => tslib_1.__importStar(require(filePath)));
        const config = (mod === null || mod === void 0 ? void 0 : mod.default) || null;
        return config;
    }
    const res = await (0, cosmiconfig_1.load)(filePath, watch);
    if (!res) {
        return null;
    }
    return res.config;
}
function pathResolve(dir, filePath, resolveProps, resolveKey = false) {
    if (filePath == null) {
        // @ts-ignore
        return undefined;
    }
    if (typeof filePath === 'string') {
        // @ts-ignore
        return resolve(dir, filePath);
    }
    if (Array.isArray(filePath)) {
        // @ts-ignore
        return filePath.map(fp => pathResolve(dir, fp, resolveProps));
    }
    const res = {};
    for (const [key, fp] of Object.entries(filePath)) {
        let _key = key;
        if (resolveKey) {
            _key = resolve(dir, key);
        }
        if (typeof fp === 'string') {
            if (!resolveProps) {
                res[_key] = resolve(dir, fp);
            }
            else if (resolveProps.includes(key)) {
                res[_key] = resolve(dir, fp);
            }
            else {
                res[_key] = fp;
            }
        }
        else {
            res[_key] = fp;
        }
    }
    // @ts-ignore
    return res;
}
function resolve(dir, pathOrModName) {
    if (isPrefixedName(pathOrModName)) {
        return pathOrModName;
    }
    if (moduleExists(pathOrModName)) {
        return pathOrModName;
    }
    return path_1.default.resolve(dir, pathOrModName);
}
function moduleExists(name) {
    try {
        require.resolve(name);
    }
    catch (err) {
        if (
        // @ts-ignore
        'code' in err &&
            // @ts-ignore
            err.code === 'MODULE_NOT_FOUND') {
            return false;
        }
        throw err;
    }
    return true;
}
function isPrefixedName(name) {
    return /^(?:markuplint|plugin):/.test(name);
}
class CircularReferenceError extends ReferenceError {
    constructor() {
        super(...arguments);
        this.name = 'CircularReferenceError';
    }
}
