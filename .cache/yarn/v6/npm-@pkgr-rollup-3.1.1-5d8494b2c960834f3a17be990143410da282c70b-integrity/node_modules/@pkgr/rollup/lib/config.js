import fs from 'node:fs';
import path from 'node:path';
import { DEFAULT_EXTENSIONS } from '@babel/core';
import { entries } from '@pkgr/es-modules';
import { getGlobals, normalizePkg, upperCamelCase, } from '@pkgr/umd-globals';
import { CWD, EXTENSIONS, PROD, __DEV__, __PROD__, arrayify, identify, monorepoPkgs, tryExtensions, tryFile, tryGlob, tryPkg, tryRequirePkg, } from '@pkgr/utils';
import alias from '@rollup/plugin-alias';
import babel from '@rollup/plugin-babel';
import commonjs from '@rollup/plugin-commonjs';
import json from '@rollup/plugin-json';
import nodeResolve from '@rollup/plugin-node-resolve';
import replace from '@rollup/plugin-replace';
import url from '@rollup/plugin-url';
import builtinModules from 'builtin-modules';
import debug from 'debug';
import isGlob from 'is-glob';
import { flatMap } from 'lodash-es';
import copy from 'rollup-plugin-copy';
import esbuild from 'rollup-plugin-esbuild';
import postcss from 'rollup-plugin-postcss';
import { terser } from 'rollup-plugin-terser';
import unassert from 'rollup-plugin-unassert';
import vueJsx from 'rollup-plugin-vue-jsx-compat';
import unassertjs from 'unassert';
const vue = tryRequirePkg('rollup-plugin-vue');
const info = debug('r:info');
const STYLE_EXTENSIONS = [
    '.css',
    '.less',
    '.pcss',
    '.sass',
    '.scss',
    '.styl',
    '.stylus',
];
const IMAGE_EXTENSIONS = [
    '.bmp',
    '.gif',
    '.jpeg',
    '.jpg',
    '.png',
    '.svg',
    '.webp',
];
const ASSETS_EXTENSIONS = [...STYLE_EXTENSIONS, ...IMAGE_EXTENSIONS];
const resolve = ({ deps, node, ts, }) => nodeResolve(Object.assign({ dedupe: node ? [] : deps, mainFields: [
        !node && 'browser',
        'esnext',
        'es2020',
        'esm2020',
        'fesm2020',
        'es2015',
        'esm2015',
        'fesm2015',
        'esm5',
        'fesm5',
        'module',
        'jsnext:main',
        'main',
    ].filter(Boolean), preferBuiltins: node }, (ts && {
    extensions: EXTENSIONS,
})));
const cjs = (sourceMap) => commonjs({ sourceMap });
const DEFAULT_FORMATS = ['cjs', 'es2015', 'esm'];
const regExpCacheMap = new Map();
const tryRegExp = (exp) => {
    if (typeof exp === 'string' && (exp = exp.trim())) {
        const cached = regExpCacheMap.get(exp);
        if (cached != null) {
            return cached;
        }
        const matched = /^\/(.*)\/([gimsuy]*)$/.exec(exp);
        if (matched) {
            try {
                const regExp = new RegExp(matched[1], matched[2]);
                regExpCacheMap.set(exp, regExp);
                return regExp;
            }
            catch (_a) { }
        }
        regExpCacheMap.set(exp, exp);
    }
    return exp;
};
const onwarn = (warning, warn) => {
    if (warning.code === 'THIS_IS_UNDEFINED') {
        return;
    }
    warn(warning);
};
export const COPY_OPTIONS_KEYS = [
    'targets',
    'verbose',
    'hook',
    'copyOnce',
];
const isCopyOptions = (copies) => !!copies &&
    !Array.isArray(copies) &&
    Object.keys(copies).every(key => COPY_OPTIONS_KEYS.includes(key));
export const config = ({ formats, monorepo, input, exclude = [], outputDir = 'lib', exports, external, externals = external !== null && external !== void 0 ? external : [], globals: umdGlobals, aliasEntries = [], copies = [], sourceMap = false, babel: babelOptions, esbuild: esbuildOptions = {}, transformer = 'esbuild', postcss: postcssOptions = {}, vue: vueOptions, define, terser: terserOptions, prod = __PROD__, } = // eslint-disable-next-line sonarjs/cognitive-complexity
 {}) => {
    let pkgs = monorepo === false
        ? [CWD]
        : Array.isArray(monorepo)
            ? tryGlob(monorepo)
            : monorepoPkgs;
    if (monorepo == null && pkgs.length === 0) {
        pkgs = [CWD];
    }
    const globals = getGlobals({
        globals: umdGlobals,
    });
    const aliasOptions = {
        resolve: [...EXTENSIONS, ...ASSETS_EXTENSIONS],
        entries: [
            ...(Array.isArray(aliasEntries)
                ? aliasEntries.map(({ find, replacement }) => ({
                    find: tryRegExp(find),
                    replacement,
                }))
                : Object.entries(aliasEntries).map(([find, replacement]) => ({
                    find: tryRegExp(find),
                    replacement,
                }))),
            ...entries,
        ],
    };
    const copyOptions = isCopyOptions(copies)
        ? copies
        : {
            targets: Array.isArray(copies)
                ? copies
                : Object.entries(copies).map(([src, dest]) => ({
                    src,
                    dest,
                })),
        };
    const configs = flatMap(pkgs, pkg => {
        const srcPath = path.resolve(pkg, 'src');
        let pkgInput = input;
        let pkgOutputDir = outputDir;
        if (!fs.existsSync(srcPath) && pkgInput == null) {
            pkgInput = 'index';
        }
        pkgInput = tryExtensions(path.resolve(pkg, pkgInput !== null && pkgInput !== void 0 ? pkgInput : 'src/index'));
        if (pkgOutputDir && !pkgOutputDir.endsWith('/')) {
            pkgOutputDir = pkgOutputDir + '/';
        }
        if (!pkgInput || !pkgInput.startsWith(pkg)) {
            return [];
        }
        const pkgJson = tryRequirePkg(path.resolve(pkg, 'package.json'));
        if (!pkgJson ||
            exclude.includes(pkgJson.name) ||
            tryGlob(exclude, path.resolve(pkg, '..')).includes(pkg)) {
            return [];
        }
        const { name, engines: { node = null } = {}, dependencies = {}, peerDependencies = {}, } = pkgJson;
        const deps = Object.keys(dependencies);
        const collectedExternals = typeof externals === 'function'
            ? []
            : [
                ...arrayify(externals),
                ...Object.keys(peerDependencies),
                ...(node ? [...deps, ...builtinModules] : []),
            ];
        const pkgFormats = formats && formats.length > 0
            ? formats
            : [...DEFAULT_FORMATS, ...(node ? [] : ['umd'])];
        const pkgGlobals = collectedExternals.reduce((pkgGlobals, pkg) => {
            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
            if (pkgGlobals[pkg] == null) {
                pkgGlobals[pkg] = upperCamelCase(normalizePkg(pkg));
            }
            return pkgGlobals;
        }, globals);
        let defineValues;
        if (define) {
            defineValues = Object.entries(define === true ? {} : define).reduce((acc, [key, value]) => Object.assign(acc, {
                [key]: JSON.stringify(value),
            }), 
            // __DEV__ and __PROD__ will always be replaced while `process.env.NODE_ENV` will be preserved except on production
            prod
                ? {
                    __DEV__: JSON.stringify(false),
                    __PROD__: JSON.stringify(true),
                    'process.env.NODE_ENV': JSON.stringify(PROD),
                }
                : {
                    __DEV__: JSON.stringify(__DEV__),
                    __PROD__: JSON.stringify(__PROD__),
                });
        }
        const isTsInput = /\.tsx?/.test(pkgInput);
        const useEsBuild = transformer === 'esbuild';
        const { jsxFactory, target } = esbuildOptions;
        const esbuildVueJsx = useEsBuild && vue && (!jsxFactory || jsxFactory === 'vueJsxCompat');
        return pkgFormats.map(format => {
            const isEsVersion = /^es(\d+|m|next)$/.test(format) && format !== 'es5';
            return {
                input: pkgInput,
                output: {
                    file: path.resolve(pkg, `${pkgOutputDir}${path.basename(pkgInput, path.extname(pkgInput))}${format === 'cjs' ? '' : '.' + format}${prod ? '.min' : ''}.${isEsVersion ? 'mjs' : format === 'cjs' ? 'cjs' : 'js'}`),
                    format: isEsVersion ? 'esm' : format,
                    name: pkgGlobals[name] || upperCamelCase(normalizePkg(name)),
                    globals,
                    exports,
                    sourcemap: sourceMap,
                },
                external(id) {
                    if (typeof externals === 'function') {
                        return externals(id, collectedExternals);
                    }
                    return collectedExternals.some(pkg => {
                        const pkgRegExp = tryRegExp(pkg);
                        return pkgRegExp instanceof RegExp
                            ? pkgRegExp.test(id)
                            : isGlob(pkg)
                                ? tryRequirePkg('micromatch').isMatch(id, pkg)
                                : id === pkg || id.startsWith(`${pkg}/`);
                    });
                },
                onwarn,
                plugins: [
                    alias(aliasOptions),
                    esbuildVueJsx && vueJsx(),
                    useEsBuild
                        ? esbuild(Object.assign(Object.assign({ jsxFactory: esbuildVueJsx ? 'vueJsxCompat' : undefined, tsconfig: tryFile(path.resolve(pkg, 'tsconfig.json')) ||
                                tryFile('tsconfig.base.json') ||
                                tryPkg('@1stg/tsconfig'), define: defineValues, minify: prod, loaders: {
                                '.json': 'json',
                                '.js': 'jsx',
                            } }, esbuildOptions), { 
                            /**
                             * es5 is not supported temporarily
                             * @see https://github.com/evanw/esbuild/issues/297
                             */
                            target: isEsVersion
                                ? format === 'esm'
                                    ? 'es6'
                                    : format
                                : target !== null && target !== void 0 ? target : 'es6', sourceMap }))
                        : babel(Object.assign({ babelHelpers: 'runtime', exclude: (babelOptions === null || babelOptions === void 0 ? void 0 : babelOptions.filter)
                                ? undefined
                                : ['*.min.js', '*.prod.js', '*.production.js'], extensions: isTsInput
                                ? ['.ts', '.tsx', ...DEFAULT_EXTENSIONS]
                                : undefined, presets: [
                                [
                                    '@babel/env',
                                    {
                                        bugfixes: true,
                                        corejs: { version: '3.13', proposals: true },
                                        shippedProposals: true,
                                        useBuiltIns: 'usage',
                                        targets: isEsVersion ? { esmodules: true } : undefined,
                                    },
                                ],
                                isTsInput && [
                                    '@babel/typescript',
                                    { allowDeclareFields: true, allowNamespaces: true },
                                ],
                            ].filter(identify), plugins: [['@babel/proposal-decorators', { legacy: true }]] }, babelOptions)),
                    resolve({
                        deps,
                        node: !!node,
                        ts: isTsInput,
                    }),
                    cjs(sourceMap),
                    copy(copyOptions),
                    json(),
                    url({ include: IMAGE_EXTENSIONS.map(ext => `**/*${ext}`) }),
                    unassert({
                        importPatterns: [
                            ...unassertjs.defaultOptions().importPatterns,
                            "import * as assert from 'uvu/assert'",
                            "import { ok as assert } from 'uvu/assert'",
                        ],
                    }),
                    postcss(postcssOptions),
                    vue === null || vue === void 0 ? void 0 : vue(vueOptions),
                    !useEsBuild &&
                        replace({ preventAssignment: true, values: defineValues }),
                    prod && !useEsBuild && terser(terserOptions),
                ].filter(identify),
            };
        });
    });
    console.assert(configs.length, "No configuration resolved, mark sure you've setup correctly");
    return configs;
};
export default (options = {}) => {
    const configs = [
        ...config(options),
        ...(options.prod ? config(Object.assign(Object.assign({}, options), { prod: false })) : []),
    ];
    info('configs: %O', configs);
    return configs;
};
//# sourceMappingURL=config.js.map