"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parse = void 0;
const tslib_1 = require("tslib");
const html_parser_1 = require("@markuplint/html-parser");
const parser_utils_1 = require("@markuplint/parser-utils");
const ngHtmlParser = tslib_1.__importStar(require("angular-html-parser"));
const ast_1 = require("angular-html-parser/lib/compiler/src/ml_parser/ast");
const getSourceSpan = (nodeOrSourceSpan) => 'sourceSpan' in nodeOrSourceSpan
    ? nodeOrSourceSpan.sourceSpan
    : nodeOrSourceSpan;
const getRaw = (nodeOrSourceSpan, text) => {
    if (!nodeOrSourceSpan) {
        return '';
    }
    const { start, end } = getSourceSpan(nodeOrSourceSpan);
    return text.slice(start.offset, end.offset);
};
function nodeMapper(nodeOrSourceSpan, { parentNode, text, simpleToken }) {
    const { start, end } = getSourceSpan(nodeOrSourceSpan);
    const startOffset = start.offset;
    const endOffset = end.offset;
    const token = {
        uuid: (0, parser_utils_1.uuid)(),
        raw: getRaw(nodeOrSourceSpan, text),
        startOffset,
        endOffset,
        startLine: start.line + 1,
        endLine: end.line + 1,
        startCol: start.col + 1,
        endCol: end.col + 1,
    };
    return simpleToken
        ? token
        : {
            ...token,
            parentNode,
            prevNode: null,
            nextNode: null,
            isFragment: false,
            isGhost: false,
        };
}
const DOCTYPE_REGEXP = /^<!doctype\s+html\s+public\s*(["'])([^"']*)\1\s*((["'])([^"']*)\4)?.*>$/i;
const visitor = {
    visitElement({ startSourceSpan, endSourceSpan, name: nodeName, attrs, children, }, { nodeList, namespace, ...options }) {
        var _a;
        const partialStartTag = nodeMapper(startSourceSpan, options);
        const { text } = options;
        const startTagText = getRaw(startSourceSpan, text);
        const endTagText = getRaw(endSourceSpan, text);
        const attributes = [];
        const childNodes = [];
        // https://github.com/ikatyang/angular-html-parser/issues/22
        nodeName = nodeName.startsWith(':') ? nodeName.slice(1) : nodeName;
        namespace =
            ((_a = attrs.find(attr => attr.name === 'xmlns')) === null || _a === void 0 ? void 0 : _a.value) ||
                (nodeName === 'svg' || nodeName.startsWith('svg:')
                    ? 'http://www.w3.org/2000/svg'
                    : namespace || 'http://www.w3.org/1999/xhtml');
        const { endSpace, selfClosingSolidus } = (0, html_parser_1.parseRawTag)(startTagText, partialStartTag.startLine, partialStartTag.startCol, partialStartTag.startOffset);
        const isCustomElement = nodeName.includes('-');
        const startTag = {
            ...partialStartTag,
            type: 'starttag',
            nodeName,
            namespace,
            attributes,
            childNodes,
            hasSpreadAttr: false,
            pearNode: null,
            selfClosingSolidus,
            endSpace,
            tagOpenChar: '<',
            tagCloseChar: '>',
            isCustomElement,
        };
        (0, ast_1.visitAll)(visitor, attrs, {
            parentNode: startTag,
            nodeList: attributes,
            text,
            namespace,
        });
        (0, ast_1.visitAll)(visitor, children, {
            parentNode: startTag,
            nodeList: childNodes,
            text,
            namespace,
        });
        let endTag = null;
        if (startTagText === endTagText) {
            startTag.tagCloseChar = '/>';
        }
        else if (endTagText) {
            startTag.pearNode = endTag = {
                ...nodeMapper(endSourceSpan, options),
                type: 'endtag',
                nodeName,
                namespace,
                attributes: [],
                pearNode: startTag,
                tagOpenChar: '</',
                tagCloseChar: '>',
                isCustomElement,
            };
        }
        nodeList.push(startTag);
        if (endTag) {
            nodeList.push(endTag);
        }
    },
    visitAttribute(attribute, { nodeList, ...options }) {
        const { name, sourceSpan: { start }, value, } = attribute;
        const node = (0, html_parser_1.attrTokenizer)(getRaw(attribute, options.text), start.line + 1, start.col, start.offset);
        const _value = value.trim();
        const dynamicName = // template reference or structural directive
         /^[#*]/.test(name) ||
            // dynamic attribute or Angular Input
            /^\[[^.[\]]+]$/.test(name) ||
            // event binding
            /^\([^().]+\)$/.test(name);
        const dynamicValue = /^{{.*}}$/.test(_value);
        if (dynamicName || dynamicValue) {
            node.isDynamicValue = true;
        }
        const potentialName = name
            /**
             * remove leading `[attr.`
             *
             * @example `<input [attr.type]="type" />`
             *
             * Notice `<input attr.type="number" />` is not same as `<input type="number" />`,
             * what means `[]` wrapper is required
             */
            .replace(/^\[attr\./, '')
            // remove leading `*`, `@`, `[]` and `()` wrapper
            .replace(/[()*@[\]]/g, '');
        node.potentialName = potentialName;
        nodeList.push(node);
    },
    visitText(text, { nodeList, ...options }) {
        const node = {
            ...nodeMapper(text, options),
            type: 'text',
            nodeName: '#text',
        };
        nodeList.push(node);
    },
    visitCdata(cdata, { nodeList, ...options }) {
        // mark cdata as comment
        const node = {
            ...nodeMapper(cdata, options),
            type: 'comment',
            nodeName: '#comment',
        };
        nodeList.push(node);
    },
    visitComment(comment, { nodeList, ...options }) {
        const node = {
            ...nodeMapper(comment, options),
            type: 'comment',
            nodeName: '#comment',
        };
        nodeList.push(node);
    },
    visitDocType(docType, { nodeList, ...options }) {
        var _a, _b;
        const partialDocType = nodeMapper(docType, options);
        const matched = DOCTYPE_REGEXP.exec(partialDocType.raw);
        const node = {
            ...partialDocType,
            type: 'doctype',
            name: docType.value.split(/\s/)[0],
            nodeName: '#doctype',
            publicId: (_a = matched === null || matched === void 0 ? void 0 : matched[2]) !== null && _a !== void 0 ? _a : '',
            systemId: (_b = matched === null || matched === void 0 ? void 0 : matched[5]) !== null && _b !== void 0 ? _b : '',
        };
        nodeList.push(node);
    },
    /* istanbul ignore next */
    visitExpansion(expansion, _context) {
        throw new Error('unexpected expansion node: ' + expansion.toString());
    },
    /* istanbul ignore next */
    visitExpansionCase(expansionCase, _context) {
        throw new Error('unexpected expansionCase node: ' + expansionCase.toString());
    },
};
const parse = text => {
    const { rootNodes, errors } = ngHtmlParser.parse(text);
    const nodeList = [];
    (0, ast_1.visitAll)(visitor, rootNodes, {
        parentNode: null,
        nodeList,
        text,
    });
    const document = {
        nodeList: (0, html_parser_1.flattenNodes)(nodeList, text),
        isFragment: !nodeList.some(node => node.type === 'doctype' ||
            (node.type === 'starttag' && node.nodeName.toLowerCase() === 'html')),
    };
    if (errors.length > 0) {
        document.unkownParseError = errors.map(err => err.toString()).join('\n');
    }
    return document;
};
exports.parse = parse;
//# sourceMappingURL=index.js.map