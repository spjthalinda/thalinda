import fs from 'fs';
import path from 'path';
import { pathToFileURL } from 'url';
import { createSyncFn } from 'synckit';

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const last = (items) => items && items[items.length - 1];
const arrayify = (...args) => args.reduce((arr, curr) => {
  arr.push(...Array.isArray(curr) ? curr : curr == null ? [] : [curr]);
  return arr;
}, []);
const getPhysicalFilename = (filename, child) => {
  try {
    if (fs.statSync(filename).isDirectory()) {
      return child || filename;
    }
  } catch (err) {
    const { code } = err;
    if (code === "ENOTDIR" || code === "ENOENT") {
      return getPhysicalFilename(path.dirname(filename), filename);
    }
  }
  return filename;
};
const loadEsmModule = (modulePath) => new Function("modulePath", `return import(modulePath);`)(modulePath);
const loadModule = (modulePath) => __async(undefined, null, function* () {
  const esModulePath = path.isAbsolute(modulePath) ? pathToFileURL(modulePath) : modulePath;
  switch (path.extname(modulePath)) {
    case ".mjs": {
      return (yield loadEsmModule(esModulePath)).default;
    }
    case ".cjs": {
      return require(modulePath);
    }
    default: {
      try {
        return require(modulePath);
      } catch (err) {
        if (err.code === "ERR_REQUIRE_ESM") {
          return (yield loadEsmModule(esModulePath)).default;
        }
        throw err;
      }
    }
  }
});
const requirePkg = (plugin, prefix, filePath) => __async(undefined, null, function* () {
  let packages;
  if (filePath && /^\.\.?([/\\]|$)/.test(plugin)) {
    packages = [path.resolve(path.dirname(filePath), plugin)];
  } else {
    prefix = prefix.endsWith("-") ? prefix : prefix + "-";
    packages = [
      plugin,
      plugin.startsWith("@") ? plugin.replace("/", "/" + prefix) : prefix + plugin
    ];
  }
  let error;
  for (const pkg of packages) {
    try {
      return yield loadModule(pkg);
    } catch (err) {
      if (!error) {
        error = err;
      }
    }
  }
  throw error;
});
const getPositionAtFactory = (text) => {
  const lines = text.split("\n");
  return (offset) => {
    let currOffset = 0;
    for (const [index, line_] of lines.entries()) {
      const line = index + 1;
      const nextOffset = currOffset + line_.length;
      if (nextOffset >= offset) {
        return {
          line,
          column: offset - currOffset,
          offset
        };
      }
      currOffset = nextOffset + 1;
    }
  };
};
const normalizePosition = ({
  start,
  end,
  text
}) => {
  const startOffset = start.offset;
  const endOffset = end.offset;
  const range = [startOffset, endOffset];
  const getPositionAt = text == null ? null : getPositionAtFactory(text);
  return {
    start: startOffset,
    end: endOffset,
    loc: {
      start: "line" in start ? start : getPositionAt(startOffset),
      end: "line" in end ? end : getPositionAt(endOffset)
    },
    range
  };
};
const prevCharOffsetFactory = (text) => (offset) => {
  for (let i = offset; i >= 0; i--) {
    const char = text[i];
    if (/^\S$/.test(char)) {
      return i;
    }
  }
};
const nextCharOffsetFactory = (text) => {
  const total = text.length;
  return (offset) => {
    for (let i = offset; i <= total; i++) {
      const char = text[i];
      if (/^\S$/.test(char)) {
        return i;
      }
    }
  };
};
const workerPath = require.resolve("./worker");
const performSyncWork = createSyncFn(workerPath);

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
const DEFAULT_EXTENSIONS = [".mdx"];
const MARKDOWN_EXTENSIONS = [".md"];
class Parser {
  constructor() {
    this.parse = this.parse.bind(this);
    this.parseForESLint = this.parseForESLint.bind(this);
  }
  parse(code, options) {
    return this.parseForESLint(code, options).ast;
  }
  parseForESLint(code, {
    filePath,
    sourceType,
    ignoreRemarkConfig,
    extensions,
    markdownExtensions
  }) {
    var _a;
    const extname = path.extname(filePath);
    const isMdx = [...DEFAULT_EXTENSIONS, ...arrayify(extensions)].includes(extname);
    const isMarkdown = [
      ...MARKDOWN_EXTENSIONS,
      ...arrayify(markdownExtensions)
    ].includes(extname);
    if (!isMdx && !isMarkdown) {
      throw new Error("Unsupported file extension, make sure setting the `extensions` or `markdownExtensions` option correctly.");
    }
    const physicalFilename = getPhysicalFilename(filePath);
    let result;
    try {
      result = performSyncWork({
        fileOptions: {
          path: physicalFilename,
          value: code
        },
        physicalFilename,
        isMdx,
        ignoreRemarkConfig
      });
    } catch (err) {
      const error = err;
      throw Object.assign(new SyntaxError(error.message), {
        lineNumber: error.line,
        column: error.column,
        index: (_a = error.position) == null ? void 0 : _a.start.offset
      });
    }
    const { root, body, comments, tokens } = result;
    return {
      ast: __spreadProps(__spreadValues({}, normalizePosition(root.position)), {
        type: "Program",
        sourceType,
        body,
        comments,
        tokens
      })
    };
  }
}
const parser = new Parser();
const { parse, parseForESLint } = parser;

export { DEFAULT_EXTENSIONS, MARKDOWN_EXTENSIONS, Parser, arrayify, getPhysicalFilename, getPositionAtFactory, last, loadEsmModule, loadModule, nextCharOffsetFactory, normalizePosition, parse, parseForESLint, parser, performSyncWork, prevCharOffsetFactory, requirePkg };
