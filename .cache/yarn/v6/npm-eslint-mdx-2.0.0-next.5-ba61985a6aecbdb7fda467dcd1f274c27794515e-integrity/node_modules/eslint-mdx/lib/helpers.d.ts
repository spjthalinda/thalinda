/// <reference types="node" />
import type { Position } from 'acorn';
import type { Point } from 'unist';
import type { NormalPosition, WorkerOptions, WorkerParseResult, WorkerProcessResult } from './types';
export declare const last: <T>(items: T[] | readonly T[]) => T;
export declare const arrayify: <T, R = T extends (infer S)[] ? S : T>(...args: T[]) => R[];
/**
 * Given a filepath, get the nearest path that is a regular file.
 * The filepath provided by eslint may be a virtual filepath rather than a file
 * on disk. This attempts to transform a virtual path into an on-disk path
 */
export declare const getPhysicalFilename: (filename: string, child?: string) => string;
/**
 * ! copied from https://github.com/just-jeb/angular-builders/blob/master/packages/custom-webpack/src/utils.ts#L53-L67
 *
 * This uses a dynamic import to load a module which may be ESM.
 * CommonJS code can load ESM code via a dynamic import. Unfortunately, TypeScript
 * will currently, unconditionally downlevel dynamic import into a require call.
 * require calls cannot load ESM code and will result in a runtime error. To workaround
 * this, a Function constructor is used to prevent TypeScript from changing the dynamic import.
 * Once TypeScript provides support for keeping the dynamic import this workaround can
 * be dropped.
 *
 * @param modulePath The path of the module to load.
 * @returns A Promise that resolves to the dynamically imported module.
 */
export declare const loadEsmModule: <T>(modulePath: URL | string) => Promise<T>;
/**
 * Loads CJS and ESM modules based on extension
 * @param modulePath path to the module
 * @returns
 */
export declare const loadModule: <T>(modulePath: string) => Promise<T>;
export declare const requirePkg: <T>(plugin: string, prefix: string, filePath?: string) => Promise<T>;
export declare const getPositionAtFactory: (text: string) => (offset: number) => Position;
export declare const normalizePosition: ({ start, end, text, }: {
    start: Point | {
        offset: number;
    };
    end: Point | {
        offset: number;
    };
    text?: string;
}) => NormalPosition;
export declare const prevCharOffsetFactory: (text: string) => (offset: number) => number;
export declare const nextCharOffsetFactory: (text: string) => (offset: number) => number;
export declare const performSyncWork: ((options: Omit<WorkerOptions, 'process'>) => WorkerParseResult) & ((options: WorkerOptions & {
    process: true;
}) => WorkerProcessResult);
