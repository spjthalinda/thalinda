"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRemarkProcessor = exports.processorCache = void 0;
const tslib_1 = require("tslib");
/* eslint-disable @typescript-eslint/consistent-type-imports */
/* eslint-disable unicorn/no-await-expression-member */
const path_1 = tslib_1.__importDefault(require("path"));
const url_1 = require("url");
const cosmiconfig_1 = require("cosmiconfig");
const synckit_1 = require("synckit");
const assert_1 = require("uvu/assert");
const helpers_1 = require("./helpers");
const tokens_1 = require("./tokens");
let acorn;
let tokTypes;
let jsxTokTypes;
let tt;
let TokenTranslator;
const explorer = (0, cosmiconfig_1.cosmiconfig)('remark', {
    packageProp: 'remarkConfig',
});
exports.processorCache = new Map();
const getRemarkMdxOptions = (tokens) => ({
    acornOptions: {
        ecmaVersion: 'latest',
        sourceType: 'module',
        locations: true,
        ranges: true,
        onToken: tokens,
    },
});
const sharedTokens = [];
const getRemarkProcessor = (searchFrom, isMdx, ignoreRemarkConfig) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const initCacheKey = `${String(isMdx)}-${searchFrom}`;
    let cachedProcessor = exports.processorCache.get(initCacheKey);
    if (cachedProcessor) {
        return cachedProcessor;
    }
    const result = ignoreRemarkConfig
        ? null
        : yield explorer.search(searchFrom);
    const cacheKey = result ? `${String(isMdx)}-${result.filepath}` : '';
    cachedProcessor = exports.processorCache.get(cacheKey);
    if (cachedProcessor) {
        return cachedProcessor;
    }
    const { unified } = yield (0, helpers_1.loadEsmModule)('unified');
    const remarkParse = (yield (0, helpers_1.loadEsmModule)('remark-parse')).default;
    const remarkStringify = (yield (0, helpers_1.loadEsmModule)('remark-stringify')).default;
    const remarkMdx = (yield (0, helpers_1.loadEsmModule)('remark-mdx')).default;
    const remarkProcessor = unified().use(remarkParse).freeze();
    if (result) {
        /* istanbul ignore next */
        const { plugins = [], settings } = 
        // type-coverage:ignore-next-line -- cosmiconfig's typings issue
        (result.config || {});
        // disable this rule automatically since we already have a parser option `extensions`
        // only disable this plugin if there are at least one plugin enabled
        // otherwise it is redundant
        /* istanbul ignore else */
        if (plugins.length > 0) {
            try {
                plugins.push([yield (0, helpers_1.requirePkg)('lint-file-extension', 'remark'), false]);
            }
            catch (_a) {
                // just ignore if the package does not exist
            }
        }
        const initProcessor = remarkProcessor()
            .use({ settings })
            .use(remarkStringify);
        if (isMdx) {
            initProcessor.use(remarkMdx, getRemarkMdxOptions(sharedTokens));
        }
        cachedProcessor = (yield plugins.reduce((processor, pluginWithSettings) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const [plugin, ...pluginSettings] = (0, helpers_1.arrayify)(pluginWithSettings);
            return (yield processor).use(
            /* istanbul ignore next */
            typeof plugin === 'string'
                ? yield (0, helpers_1.requirePkg)(plugin, 'remark', result.filepath)
                : plugin, ...pluginSettings);
        }), Promise.resolve(initProcessor))).freeze();
    }
    else {
        const initProcessor = remarkProcessor().use(remarkStringify);
        if (isMdx) {
            initProcessor.use(remarkMdx, getRemarkMdxOptions(sharedTokens));
        }
        cachedProcessor = initProcessor.freeze();
    }
    exports.processorCache
        .set(initCacheKey, cachedProcessor)
        .set(cacheKey, cachedProcessor);
    return cachedProcessor;
});
exports.getRemarkProcessor = getRemarkProcessor;
(0, synckit_1.runAsWorker)(({ fileOptions, physicalFilename, isMdx, process, ignoreRemarkConfig, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    sharedTokens.length = 0;
    const processor = yield (0, exports.getRemarkProcessor)(physicalFilename, isMdx, ignoreRemarkConfig);
    if (process) {
        const { VFile } = yield (0, helpers_1.loadEsmModule)('vfile');
        const file = new VFile(fileOptions);
        try {
            yield processor.process(file);
        }
        catch (err) {
            const error = err;
            if (!file.messages.includes(error)) {
                file.message(error).fatal = true;
            }
        }
        return {
            messages: file.messages.map(message => (0, synckit_1.extractProperties)(message)),
            content: file.toString(),
        };
    }
    /**
     * unified plugins are using ESM version of acorn,
     * so we have to use the same version as well,
     * otherwise the TokenType will be different class
     * @see also https://github.com/acornjs/acorn-jsx/issues/133
     */
    if (!acorn) {
        acorn = yield (0, helpers_1.loadEsmModule)('acorn');
    }
    if (!tokTypes) {
        tokTypes = acorn.tokTypes;
    }
    if (!jsxTokTypes) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access
        jsxTokTypes = (yield (0, helpers_1.loadEsmModule)('acorn-jsx')).default({
            allowNamespacedObjects: true,
        })(acorn.Parser).acornJsx.tokTypes;
    }
    if (!TokenTranslator) {
        TokenTranslator = (yield (0, helpers_1.loadEsmModule)((0, url_1.pathToFileURL)(path_1.default.resolve(require.resolve('espree/package.json'), '../lib/token-translator.js')))).default;
    }
    if (!tt) {
        tt = Object.assign(Object.assign({}, tokTypes), jsxTokTypes);
    }
    const text = fileOptions.value;
    const tokenTranslator = new TokenTranslator(tt, text);
    const root = processor.parse(fileOptions);
    const body = [];
    const comments = [];
    const tokens = [];
    const { visit } = yield (0, helpers_1.loadEsmModule)('unist-util-visit');
    const processed = new WeakSet();
    // TODO: merge with `tokens.ts`
    if (isMdx) {
        const prevCharOffset = (0, helpers_1.prevCharOffsetFactory)(text);
        const nextCharOffset = (0, helpers_1.nextCharOffsetFactory)(text);
        const normalizeNode = (start, end) => (Object.assign(Object.assign({}, (0, helpers_1.normalizePosition)({
            start: { offset: start },
            end: { offset: end },
            text,
        })), { raw: text.slice(start, end) }));
        visit(root, node => {
            var _a;
            if (processed.has(node) ||
                (node.type !== 'mdxFlowExpression' &&
                    node.type !== 'mdxJsxFlowElement' &&
                    node.type !== 'mdxJsxTextElement' &&
                    node.type !== 'mdxTextExpression' &&
                    node.type !== 'mdxjsEsm')) {
                return;
            }
            processed.add(node);
            function handleChildren(node) {
                return 'children' in node
                    ? node.children.reduce((acc, child) => {
                        processed.add(child);
                        if (child.data && 'estree' in child.data && child.data.estree) {
                            const estree = child.data.estree;
                            (0, assert_1.ok)(estree.body.length <= 1);
                            const expStat = estree.body[0];
                            if (expStat) {
                                const expression = expStat.expression;
                                acc.push(expression);
                            }
                            comments.push(...estree.comments);
                        }
                        else {
                            const expression = handleNode(child);
                            if (expression) {
                                acc.push(expression);
                            }
                        }
                        return acc;
                    }, [])
                    : [];
            }
            function handleNode(node) {
                if (node.type !== 'mdxJsxTextElement' &&
                    node.type !== 'mdxJsxFlowElement') {
                    return;
                }
                const children = handleChildren(node);
                const nodePos = node.position;
                const nodeStart = nodePos.start.offset;
                const nodeEnd = nodePos.end.offset;
                const lastCharOffset = prevCharOffset(nodeEnd - 2);
                let expression;
                if (node.name) {
                    const nodeNameLength = node.name.length;
                    const nodeNameStart = nextCharOffset(nodeStart + 1);
                    const selfClosing = text[lastCharOffset] === '/';
                    let lastAttrOffset = nodeNameStart + nodeNameLength - 1;
                    let closingElement = null;
                    if (!selfClosing) {
                        const prevOffset = prevCharOffset(lastCharOffset);
                        const slashOffset = prevCharOffset(prevOffset - nodeNameLength);
                        (0, assert_1.ok)(text[slashOffset] === '/');
                        const tagStartOffset = prevCharOffset(slashOffset - 1);
                        (0, assert_1.ok)(text[tagStartOffset] === '<');
                        closingElement = Object.assign(Object.assign({}, normalizeNode(tagStartOffset, nodeEnd)), { type: 'JSXClosingElement', name: Object.assign(Object.assign({}, normalizeNode(prevOffset + 1 - nodeNameLength, prevOffset + 1)), { type: 'JSXIdentifier', name: node.name }) });
                    }
                    const jsxEl = Object.assign(Object.assign({}, normalizeNode(nodeStart, nodeEnd)), { type: 'JSXElement', openingElement: {
                            type: 'JSXOpeningElement',
                            name: Object.assign(Object.assign({}, normalizeNode(nodeNameStart, nodeNameStart + nodeNameLength)), { type: 'JSXIdentifier', name: node.name }),
                            attributes: node.attributes.map(attr => {
                                if (attr.type === 'mdxJsxExpressionAttribute') {
                                    (0, assert_1.ok)(attr.data);
                                    (0, assert_1.ok)(attr.data.estree);
                                    (0, assert_1.ok)(attr.data.estree.range);
                                    let [attrValStart, attrValEnd] = attr.data.estree.range;
                                    attrValStart = prevCharOffset(attrValStart - 1);
                                    attrValEnd = nextCharOffset(attrValEnd);
                                    (0, assert_1.ok)(text[attrValStart] === '{');
                                    (0, assert_1.ok)(text[attrValEnd] === '}');
                                    lastAttrOffset = attrValEnd;
                                    return Object.assign(Object.assign({}, normalizeNode(attrValStart, attrValEnd + 1)), { type: 'JSXSpreadAttribute', 
                                        // https://github.com/mdx-js/eslint-mdx/pull/394#discussion_r872974843
                                        argument: attr.data.estree.body[0]
                                            .expression.properties[0].argument });
                                }
                                const attrStart = nextCharOffset(lastAttrOffset + 1);
                                (0, assert_1.ok)(attrStart != null);
                                const attrName = attr.name;
                                const attrNameLength = attrName.length;
                                const attrValue = attr.value;
                                lastAttrOffset = attrStart + attrNameLength;
                                const attrNamePos = normalizeNode(attrStart, lastAttrOffset);
                                if (attrValue == null) {
                                    return Object.assign(Object.assign({}, attrNamePos), { type: 'JSXAttribute', name: Object.assign(Object.assign({}, attrNamePos), { type: 'JSXIdentifier', name: attrName }), value: null });
                                }
                                const attrEqualOffset = nextCharOffset(attrStart + attrNameLength);
                                (0, assert_1.ok)(text[attrEqualOffset] === '=');
                                let attrValuePos;
                                if (typeof attrValue === 'string') {
                                    const attrQuoteOffset = nextCharOffset(attrEqualOffset + 1);
                                    const attrQuote = text[attrQuoteOffset];
                                    (0, assert_1.ok)(attrQuote === '"' || attrQuote === "'");
                                    lastAttrOffset = nextCharOffset(attrQuoteOffset + attrValue.length + 1);
                                    (0, assert_1.ok)(text[lastAttrOffset] === attrQuote);
                                    attrValuePos = normalizeNode(attrQuoteOffset, lastAttrOffset + 1);
                                }
                                else {
                                    const data = attrValue.data;
                                    let [attrValStart, attrValEnd] = data.estree.range;
                                    attrValStart = prevCharOffset(attrValStart - 1);
                                    attrValEnd = nextCharOffset(attrValEnd);
                                    (0, assert_1.ok)(text[attrValStart] === '{');
                                    (0, assert_1.ok)(text[attrValEnd] === '}');
                                    lastAttrOffset = attrValEnd;
                                    attrValuePos = normalizeNode(attrValStart, attrValEnd + 1);
                                }
                                return Object.assign(Object.assign({}, attrNamePos), { type: 'JSXAttribute', name: Object.assign(Object.assign({}, normalizeNode(attrStart, lastAttrOffset + 1)), { type: 'JSXIdentifier', name: attrName }), value: typeof attr.value === 'string'
                                        ? Object.assign(Object.assign({}, attrValuePos), { type: 'Literal', value: attr.value }) : Object.assign(Object.assign({}, attrValuePos), { type: 'JSXExpressionContainer', expression: attr.value.data.estree
                                            .body[0].expression }) });
                            }),
                            selfClosing,
                        }, closingElement,
                        children });
                    const nextOffset = nextCharOffset(lastAttrOffset + 1);
                    const nextChar = text[nextOffset];
                    (0, assert_1.ok)(nextChar === (selfClosing ? '/' : '>'));
                    Object.assign(jsxEl.openingElement, normalizeNode(nodeStart, selfClosing ? nodeEnd : nextOffset + 1));
                    expression = jsxEl;
                }
                else {
                    const openEndOffset = nextCharOffset(nodeStart + 1);
                    const openPos = normalizeNode(nodeStart, openEndOffset);
                    const closeStartOffset = prevCharOffset(lastCharOffset - 1);
                    const jsxFrg = Object.assign(Object.assign({}, openPos), { type: 'JSXFragment', openingFragment: Object.assign(Object.assign({}, openPos), { type: 'JSXOpeningFragment' }), closingFragment: Object.assign(Object.assign({}, normalizeNode(closeStartOffset, nodeEnd)), { type: 'JSXClosingFragment' }), children });
                    expression = jsxFrg;
                }
                return expression;
            }
            const expression = handleNode(node);
            if (expression) {
                body.push(Object.assign(Object.assign({}, (0, helpers_1.normalizePosition)(node.position)), { type: 'ExpressionStatement', expression: handleNode(node) }));
            }
            const estree = (((_a = node.data) === null || _a === void 0 ? void 0 : _a.estree) || {
                body: [],
                comments: [],
            });
            body.push(...estree.body);
            comments.push(...estree.comments);
        });
    }
    const { visit: visitEstree } = yield (0, helpers_1.loadEsmModule)('estree-util-visit');
    visitEstree({
        type: 'Program',
        sourceType: 'module',
        body,
    }, node => {
        if (node.type !== 'TemplateElement') {
            return;
        }
        /**
         * Copied from @see https://github.com/eslint/espree/blob/main/lib/espree.js#L206-L220
         */
        const templateElement = node;
        const startOffset = -1;
        const endOffset = templateElement.tail ? 1 : 2;
        // @ts-expect-error - unavailable for typing from estree
        templateElement.start += startOffset;
        // @ts-expect-error - unavailable for typing from estree
        templateElement.end += endOffset;
        if (templateElement.range) {
            templateElement.range[0] += startOffset;
            templateElement.range[1] += endOffset;
        }
        if (templateElement.loc) {
            templateElement.loc.start.column += startOffset;
            templateElement.loc.end.column += endOffset;
        }
    });
    for (const token of (0, tokens_1.restoreTokens)(text, root, sharedTokens, tt, visit)) {
        tokenTranslator.onToken(token, {
            ecmaVersion: 'latest',
            tokens: tokens,
        });
    }
    return {
        root,
        body,
        comments,
        tokens,
    };
}));
//# sourceMappingURL=worker.js.map