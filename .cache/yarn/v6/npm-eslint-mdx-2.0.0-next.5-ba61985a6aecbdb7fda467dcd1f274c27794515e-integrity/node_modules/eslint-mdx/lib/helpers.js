"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.performSyncWork = exports.nextCharOffsetFactory = exports.prevCharOffsetFactory = exports.normalizePosition = exports.getPositionAtFactory = exports.requirePkg = exports.loadModule = exports.loadEsmModule = exports.getPhysicalFilename = exports.arrayify = exports.last = void 0;
const tslib_1 = require("tslib");
/* eslint-disable unicorn/no-await-expression-member */
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const url_1 = require("url");
const synckit_1 = require("synckit");
const last = (items) => items && items[items.length - 1];
exports.last = last;
const arrayify = (...args) => args.reduce((arr, curr) => {
    arr.push(...(Array.isArray(curr) ? curr : curr == null ? [] : [curr]));
    return arr;
}, []);
exports.arrayify = arrayify;
/**
 * Given a filepath, get the nearest path that is a regular file.
 * The filepath provided by eslint may be a virtual filepath rather than a file
 * on disk. This attempts to transform a virtual path into an on-disk path
 */
const getPhysicalFilename = (filename, child) => {
    try {
        if (fs_1.default.statSync(filename).isDirectory()) {
            return child || filename;
        }
    }
    catch (err) {
        const { code } = err;
        // https://github.com/eslint/eslint/issues/11989
        // Additionally, it seems there is no `ENOTDIR` code on Windows...
        if (code === 'ENOTDIR' || code === 'ENOENT') {
            return (0, exports.getPhysicalFilename)(path_1.default.dirname(filename), filename);
        }
    }
    return filename;
};
exports.getPhysicalFilename = getPhysicalFilename;
/**
 * ! copied from https://github.com/just-jeb/angular-builders/blob/master/packages/custom-webpack/src/utils.ts#L53-L67
 *
 * This uses a dynamic import to load a module which may be ESM.
 * CommonJS code can load ESM code via a dynamic import. Unfortunately, TypeScript
 * will currently, unconditionally downlevel dynamic import into a require call.
 * require calls cannot load ESM code and will result in a runtime error. To workaround
 * this, a Function constructor is used to prevent TypeScript from changing the dynamic import.
 * Once TypeScript provides support for keeping the dynamic import this workaround can
 * be dropped.
 *
 * @param modulePath The path of the module to load.
 * @returns A Promise that resolves to the dynamically imported module.
 */
/* istanbul ignore next */
const loadEsmModule = (modulePath) => 
// eslint-disable-next-line @typescript-eslint/no-implied-eval, no-new-func
new Function('modulePath', `return import(modulePath);`)(modulePath);
exports.loadEsmModule = loadEsmModule;
/**
 * Loads CJS and ESM modules based on extension
 * @param modulePath path to the module
 * @returns
 */
const loadModule = (modulePath) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const esModulePath = path_1.default.isAbsolute(modulePath)
        ? (0, url_1.pathToFileURL)(modulePath)
        : modulePath;
    switch (path_1.default.extname(modulePath)) {
        /* istanbul ignore next */
        case '.mjs': {
            return (yield (0, exports.loadEsmModule)(esModulePath)).default;
        }
        /* istanbul ignore next */
        case '.cjs': {
            // eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/no-unsafe-return
            return require(modulePath);
        }
        default: {
            // The file could be either CommonJS or ESM.
            // CommonJS is tried first then ESM if loading fails.
            try {
                // eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/no-unsafe-return
                return require(modulePath);
            }
            catch (err) {
                /* istanbul ignore if */
                if (err.code === 'ERR_REQUIRE_ESM') {
                    // Load the ESM configuration file using the TypeScript dynamic import workaround.
                    // Once TypeScript provides support for keeping the dynamic import this workaround can be
                    // changed to a direct dynamic import.
                    return (yield (0, exports.loadEsmModule)(esModulePath)).default;
                }
                throw err;
            }
        }
    }
});
exports.loadModule = loadModule;
const requirePkg = (plugin, prefix, filePath) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    let packages;
    if (filePath && /^\.\.?([/\\]|$)/.test(plugin)) {
        packages = [path_1.default.resolve(path_1.default.dirname(filePath), plugin)];
    }
    else {
        prefix = prefix.endsWith('-') ? prefix : prefix + '-';
        packages = [
            plugin,
            /* istanbul ignore next */
            plugin.startsWith('@')
                ? plugin.replace('/', '/' + prefix)
                : prefix + plugin,
        ];
    }
    let error;
    for (const pkg of packages) {
        try {
            return yield (0, exports.loadModule)(pkg);
        }
        catch (err) {
            if (!error) {
                error = err;
            }
        }
    }
    throw error;
});
exports.requirePkg = requirePkg;
/* istanbul ignore next -- used in worker */
const getPositionAtFactory = (text) => {
    const lines = text.split('\n');
    return (offset) => {
        let currOffset = 0;
        for (const [index, line_] of lines.entries()) {
            const line = index + 1;
            const nextOffset = currOffset + line_.length;
            if (nextOffset >= offset) {
                return {
                    line,
                    column: offset - currOffset,
                    offset,
                };
            }
            currOffset = nextOffset + 1; // add a line break `\n` offset
        }
    };
};
exports.getPositionAtFactory = getPositionAtFactory;
const normalizePosition = ({ start, end, text, }) => {
    const startOffset = start.offset;
    const endOffset = end.offset;
    const range = [startOffset, endOffset];
    const getPositionAt = text == null
        ? null
        : /* istanbul ignore next -- used in worker */ (0, exports.getPositionAtFactory)(text);
    return {
        start: startOffset,
        end: endOffset,
        loc: {
            start: 
            /* istanbul ignore next -- used in worker */ 'line' in start
                ? start
                : getPositionAt(startOffset),
            end: 
            /* istanbul ignore next -- used in worker */ 'line' in end
                ? end
                : getPositionAt(endOffset),
        },
        range,
    };
};
exports.normalizePosition = normalizePosition;
/* istanbul ignore next -- used in worker */
const prevCharOffsetFactory = (text) => (offset) => {
    for (let i = offset; i >= 0; i--) {
        const char = text[i];
        if (/^\S$/.test(char)) {
            return i;
        }
    }
};
exports.prevCharOffsetFactory = prevCharOffsetFactory;
/* istanbul ignore next -- used in worker */
const nextCharOffsetFactory = (text) => {
    const total = text.length;
    return (offset) => {
        for (let i = offset; i <= total; i++) {
            const char = text[i];
            if (/^\S$/.test(char)) {
                return i;
            }
        }
    };
};
exports.nextCharOffsetFactory = nextCharOffsetFactory;
const workerPath = require.resolve('./worker');
exports.performSyncWork = (0, synckit_1.createSyncFn)(workerPath);
//# sourceMappingURL=helpers.js.map