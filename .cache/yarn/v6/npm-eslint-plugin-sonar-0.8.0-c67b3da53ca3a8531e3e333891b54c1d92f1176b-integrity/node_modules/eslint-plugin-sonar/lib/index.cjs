'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var regexpp = require('regexpp');
var createTree = require('functional-red-black-tree');
var ts = require('typescript');
var parserServices = require('eslint-plugin-sonarjs/lib/utils/parser-services');
var nodes = require('eslint-plugin-sonarjs/lib/utils/nodes');
var locations = require('eslint-plugin-sonarjs/lib/utils/locations');
var bytes = require('bytes');
var path = require('path');
var equivalence = require('eslint-plugin-sonarjs/lib/utils/equivalence');
var url = require('url');
var eslint = require('eslint');
var babel = require('@babel/eslint-parser');
var fs = require('fs');
var net = require('net');
var builtins = require('builtin-modules');
var scslre = require('scslre');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var regexpp__namespace = /*#__PURE__*/_interopNamespace(regexpp);
var createTree__default = /*#__PURE__*/_interopDefaultLegacy(createTree);
var ts__default = /*#__PURE__*/_interopDefaultLegacy(ts);
var ts__namespace = /*#__PURE__*/_interopNamespace(ts);
var path__default = /*#__PURE__*/_interopDefaultLegacy(path);
var path__namespace = /*#__PURE__*/_interopNamespace(path);
var babel__namespace = /*#__PURE__*/_interopNamespace(babel);
var fs__namespace = /*#__PURE__*/_interopNamespace(fs);
var builtins__default = /*#__PURE__*/_interopDefaultLegacy(builtins);

const base = {
    plugins: ['sonar'],
    rules: {
        'no-labels': 0,
        'sonar/argument-type': 2,
        'sonar/arguments-order': 2,
        'sonar/array-callback-without-return': 2,
        'sonar/bitwise-operators': 2,
        'sonar/call-argument-line': 2,
        'sonar/comma-or-logical-or-case': 2,
        'sonar/code-eval': 2,
        'sonar/deprecation': 1,
        'sonar/different-types-comparison': 2,
        'sonar/for-in': 2,
        'sonar/for-loop-increment-sign': 2,
        'sonar/function-inside-loop': 2,
        'sonar/future-reserved-words': 1,
        'sonar/generator-without-yield': 2,
        'sonar/in-operator-type-error': 2,
        'sonar/inconsistent-function-call': 2,
        'sonar/label-position': 2,
        'sonar/new-operator-misuse': [2, { considerJSDoc: false }],
        'sonar/no-accessor-field-mismatch': 2,
        'sonar/no-alphabetical-sort': 2,
        'sonar/no-array-delete': 2,
        'sonar/no-associative-arrays': 2,
        // https://community.sonarsource.com/t/incorrect-no-built-in-override-report-from-imports/40053
        // 'sonar/no-built-in-override': 2,
        'sonar/no-case-label-in-switch': 2,
        'sonar/no-dead-store': 2,
        'sonar/no-delete-var': 2,
        'sonar/no-duplicate-in-composite': 2,
        'sonar/no-equals-in-for-termination': 1,
        'sonar/no-function-declaration-in-block': 1,
        'sonar/no-global-this': 1,
        'sonar/no-globals-shadowing': 1,
        'sonar/no-implicit-global': 2,
        'sonar/no-in-misuse': 2,
        'sonar/no-infinite-loop': 2,
        'sonar/no-invalid-await': 2,
        'sonar/no-labels': 1,
        // 'sonar/no-misleading-array-reverse': 1,
        'sonar/no-new-symbol': 2,
        'sonar/no-parameter-reassignment': 1,
        'sonar/no-primitive-wrappers': 1,
        'sonar/no-redundant-assignments': 1,
        'sonar/no-redundant-optional': 1,
        'sonar/no-try-promise': 2,
        'sonar/no-undefined-argument': 1,
        'sonar/no-unthrown-error': 2,
        'sonar/no-useless-increment': 2,
        'sonar/operation-returning-nan': 2,
        'sonar/post-message': 1,
        'sonar/sonar-block-scoped-var': 1,
        'sonar/sonar-no-fallthrough': 1,
        'sonar/sonar-no-unused-vars': 2,
        'sonar/strings-comparison': 2,
        'sonar/super-invocation': 2,
        'sonar/unused-import': 2,
        'sonar/updated-loop-counter': 1,
        'sonar/useless-string-operation': 2,
        'sonar/values-not-convertible-to-numbers': 1,
    },
    overrides: [
        {
            files: '*.{ts,tsx}',
            rules: {
                'sonar/argument-type': 0,
                'sonar/arguments-order': 0,
                'sonar/array-callback-without-return': 0,
                'sonar/call-argument-line': 0,
                'sonar/different-types-comparison': 0,
                'sonar/inconsistent-function-call': 0,
                'sonar/new-operator-misuse': 0,
                'sonar/no-associative-arrays': 0,
                'sonar/no-gratuitous-expressions': 0,
                'sonar/no-implicit-global': 0,
                'sonar/no-invalid-await': 0,
                'sonar/no-new-symbol': 0,
                'sonar/no-primitive-wrappers': 0,
                'sonar/operation-returning-nan': 0,
                'sonar/sonar-block-scoped-var': 0,
                'sonar/sonar-no-fallthrough': 0,
                'sonar/sonar-no-unused-vars': 0,
                'sonar/strings-comparison': 0,
                'sonar/super-invocation': 0,
                'sonar/unused-import': 0,
                'sonar/values-not-convertible-to-numbers': 0,
            },
        },
    ],
};
const recommended = Object.assign(Object.assign({}, base), { rules: Object.assign(Object.assign({}, base.rules), { 'sonar/array-constructor': 2, 'sonar/class-prototype': 2, 'sonar/destructuring-assignment-syntax': 2, 'sonar/function-name': [2, { format: '^_?[a-zA-Z][a-zA-Z0-9]*\\$?$' }], 'sonar/future-reserved-words': 2, 'sonar/max-union-size': [1, 5], 'sonar/misplaced-loop-counter': 2, 'sonar/no-equals-in-for-termination': 2, 'sonar/no-for-in-iterable': 2, 'sonar/no-labels': 2, 
        // https://jira.sonarsource.com/browse/RSPEC-4043?focusedCommentId=245770&page=com.atlassian.jira.plugin.system.issuetabpanels%3Acomment-tabpanel#comment-245770
        // 'sonar/no-misleading-array-reverse': 2,
        'sonar/no-parameter-reassignment': 2, 'sonar/no-primitive-wrappers': 2, 'sonar/no-redundant-assignments': 2, 'sonar/no-redundant-optional': 2, 'sonar/no-return-type-any': 1, 'sonar/no-undefined-argument': 2, 'sonar/no-unused-function-argument': 1, 'sonar/no-useless-intersection': 2, 'sonar/no-variable-usage-before-declaration': 2, 'sonar/non-number-in-arithmetic-expression': 1, 'sonar/null-dereference': 2, 'sonar/prefer-default-last': 1, 'sonar/prefer-promise-shorthand': 2, 'sonar/sonar-block-scoped-var': 2, 'sonar/sonar-no-fallthrough': 2, 'sonar/updated-loop-counter': 2, 'sonar/values-not-convertible-to-numbers': 2 }), overrides: [
        ...base.overrides,
        {
            files: '*.{ts,tsx}',
            rules: {
                'sonar/array-constructor': 0,
                // doesn't work with constructor with accessibility
                'sonar/no-unused-function-argument': 0,
                'sonar/class-prototype': 0,
                'sonar/no-for-in-iterable': 0,
                'sonar/no-variable-usage-before-declaration': 0,
                'sonar/non-number-in-arithmetic-expression': 0,
                'sonar/null-dereference': 0,
                'sonar/sonar-block-scoped-var': 0,
            },
        },
    ] });

var _configs = /*#__PURE__*/Object.freeze({
  __proto__: null,
  base: base,
  recommended: recommended
});

const MAX_CODE_POINT = 0x10ffff;
class SimplifiedRegexCharacterClass {
    constructor(flags, element) {
        this.flags = flags;
        /**
         * This map defines the contents of the character class in the following way:<br>
         * For any entry {@code codepoint -> tree}, all the codepoints from {@code codepoint} up to (and excluding) the next
         * entry are in the character class and belong to the given tree.<br>
         * For any entry {@code codepoint -> null}, all the codepoints from {@code codepoint} up to (and excluding) the next
         * entry are not part of the character class.<br>
         * So a codepoint is contained in this class if and only if {@code contents.le(codePoint).value} is
         * non-null and the tree returned by {@code value} will be the element of the character class which matches that
         * code point.
         */
        this.contents = createTree__default["default"]();
        if (element) {
            this.add(element);
        }
    }
    add(element) {
        new SimplifiedRegexCharacterClass.Builder(this).visit(element);
    }
    findIntersections(that) {
        const iter = that.contents.begin;
        const intersections = [];
        if (iter.key === undefined) {
            return intersections;
        }
        while (iter.hasNext) {
            const { key, value } = iter;
            iter.next();
            const to = iter.value ? iter.key : iter.key - 1;
            if (value && this.hasEntryBetween(key, to)) {
                intersections.push(value);
            }
        }
        if (iter.value && this.hasEntryBetween(iter.key, MAX_CODE_POINT)) {
            intersections.push(iter.value);
        }
        return intersections;
    }
    hasEntryBetween(from, to) {
        const before = this.contents.le(from);
        return (before.key !== undefined && before.value) || !this.isRangeEmpty(from + 1, to + 1);
    }
    isRangeEmpty(from, to) {
        let isEmpty = true;
        this.contents.forEach(() => (isEmpty = false), from, to);
        return isEmpty;
    }
    addRange(from, to, element) {
        const oldEntry = this.contents.le(to);
        const oldEnd = oldEntry.key === undefined ? undefined : this.contents.gt(oldEntry.key).key;
        this.contents = this.put(from, element, this.contents);
        const iterator = this.contents.begin;
        while (iterator.key !== undefined) {
            if (iterator.key > from && iterator.key <= to && iterator.value === undefined) {
                this.contents = iterator.update(element);
            }
            iterator.next();
        }
        const next = to + 1;
        if (next <= MAX_CODE_POINT) {
            if (oldEntry.key !== undefined && oldEntry.value && (oldEnd === undefined || oldEnd > next)) {
                this.contents = this.put(next, oldEntry.value, this.contents);
            }
            else if (this.contents.find(next).key === undefined) {
                this.contents = this.put(next, undefined, this.contents);
            }
        }
    }
    put(key, value, tree) {
        const entry = tree.find(key);
        if (entry.valid) {
            return entry.update(value);
        }
        return tree.insert(key, value);
    }
}
SimplifiedRegexCharacterClass.Builder = class {
    constructor(characters) {
        this.characters = characters;
    }
    visit(element) {
        switch (element.type) {
            case 'Character':
                this.visitCharacter(element);
                break;
            case 'CharacterClassRange':
                this.visitCharacterClassRange(element);
                break;
            case 'CharacterSet':
                this.visitCharacterSet(element);
                break;
        }
    }
    visitCharacter(character) {
        this.addRange(character.value, character.value, character);
    }
    visitCharacterClassRange(characterRange) {
        this.addRange(characterRange.min.value, characterRange.max.value, characterRange);
    }
    visitCharacterSet(characterSet) {
        switch (characterSet.kind) {
            case 'digit':
                if (characterSet.negate) {
                    this.characters.addRange(0x00, this.codePoint('0') - 1, characterSet);
                    if (this.characters.flags.unicode) {
                        this.characters.addRange(this.codePoint('9') + 1, 0xff, characterSet);
                    }
                    else {
                        this.characters.addRange(this.codePoint('9') + 1, MAX_CODE_POINT, characterSet);
                    }
                }
                else {
                    this.characters.addRange(this.codePoint('0'), this.codePoint('9'), characterSet);
                }
                break;
            case 'space':
                if (characterSet.negate) {
                    this.characters.addRange(0x00, this.codePoint('\t') - 1, characterSet);
                    this.characters.addRange(this.codePoint('\r') + 1, this.codePoint(' ') - 1, characterSet);
                    if (this.characters.flags.unicode) {
                        this.characters.addRange(this.codePoint(' ') + 1, 0x84, characterSet);
                        this.characters.addRange(0x86, 0x9f, characterSet);
                        this.characters.addRange(0xa1, 0x167f, characterSet);
                        this.characters.addRange(0x1681, 0x1fff, characterSet);
                        this.characters.addRange(0x200b, 0x2027, characterSet);
                        this.characters.addRange(0x202a, 0x202e, characterSet);
                        this.characters.addRange(0x2030, 0x205e, characterSet);
                        this.characters.addRange(0x2060, 0x2fff, characterSet);
                        this.characters.addRange(0x3001, MAX_CODE_POINT, characterSet);
                    }
                    else {
                        this.characters.addRange(this.codePoint(' ') + 1, MAX_CODE_POINT, characterSet);
                    }
                }
                else {
                    this.characters.addRange(this.codePoint('\t'), this.codePoint('\r'), characterSet);
                    this.characters.addRange(this.codePoint(' '), this.codePoint(' '), characterSet);
                    if (this.characters.flags.unicode) {
                        this.characters.addRange(0x85, 0x85, characterSet);
                        this.characters.addRange(0xa0, 0xa0, characterSet);
                        this.characters.addRange(0x1680, 0x1680, characterSet);
                        this.characters.addRange(0x2000, 0x200a, characterSet);
                        this.characters.addRange(0x2028, 0x2029, characterSet);
                        this.characters.addRange(0x202f, 0x202f, characterSet);
                        this.characters.addRange(0x205f, 0x205f, characterSet);
                        this.characters.addRange(0x3000, 0x3000, characterSet);
                    }
                }
                break;
            case 'word':
                if (characterSet.negate) {
                    this.characters.addRange(0x00, this.codePoint('0') - 1, characterSet);
                    this.characters.addRange(this.codePoint('9') + 1, this.codePoint('A') - 1, characterSet);
                    this.characters.addRange(this.codePoint('Z') + 1, this.codePoint('_') - 1, characterSet);
                    this.characters.addRange(this.codePoint('`'), this.codePoint('`'), characterSet);
                    if (this.characters.flags.unicode) {
                        this.characters.addRange(this.codePoint('z') + 1, this.codePoint('µ') - 1, characterSet);
                    }
                    else {
                        this.characters.addRange(this.codePoint('z') + 1, MAX_CODE_POINT, characterSet);
                    }
                }
                else {
                    this.characters.addRange(this.codePoint('0'), this.codePoint('9'), characterSet);
                    this.characters.addRange(this.codePoint('A'), this.codePoint('Z'), characterSet);
                    this.characters.addRange(this.codePoint('_'), this.codePoint('_'), characterSet);
                    this.characters.addRange(this.codePoint('a'), this.codePoint('z'), characterSet);
                }
                break;
        }
    }
    addRange(from, to, element) {
        const upperCaseFrom = this.codePoint(String.fromCodePoint(from).toUpperCase());
        const upperCaseTo = this.codePoint(String.fromCodePoint(to).toUpperCase());
        const lowerCaseFrom = this.codePoint(String.fromCodePoint(upperCaseFrom).toLowerCase());
        const lowerCaseTo = this.codePoint(String.fromCodePoint(upperCaseTo).toLowerCase());
        if (this.characters.flags.ignoreCase &&
            lowerCaseFrom !== upperCaseFrom &&
            lowerCaseTo !== upperCaseTo &&
            ((this.isAscii(from) && this.isAscii(to)) || this.characters.flags.unicode)) {
            this.characters.addRange(upperCaseFrom, upperCaseTo, element);
            this.characters.addRange(lowerCaseFrom, lowerCaseTo, element);
        }
        else {
            this.characters.addRange(from, to, element);
        }
    }
    isAscii(c) {
        return c < 128;
    }
    codePoint(c) {
        const cp = c.codePointAt(0);
        if (cp === undefined) {
            throw new Error(`failed to compute code point for: ${c}`);
        }
        return cp;
    }
};

const FUNCTION_NODES = [
    'FunctionDeclaration',
    'FunctionExpression',
    'ArrowFunctionExpression',
];
const functionLike$1 = new Set([
    'FunctionDeclaration',
    'FunctionExpression',
    'ArrowFunctionExpression',
    'MethodDefinition',
]);
function isIdentifier(node, ...values) {
    return ((node === null || node === void 0 ? void 0 : node.type) === 'Identifier' &&
        (values.length === 0 || values.some(value => value === node.name)));
}
function isMemberWithProperty$1(node, ...values) {
    return node.type === 'MemberExpression' && isIdentifier(node.property, ...values);
}
function isMemberExpression(node, objectValue, ...propertyValue) {
    if (node.type === 'MemberExpression') {
        const { object, property } = node;
        if (isIdentifier(object, objectValue) && isIdentifier(property, ...propertyValue)) {
            return true;
        }
    }
    return false;
}
function isBinaryPlus(node) {
    return node.type === 'BinaryExpression' && node.operator === '+';
}
function isUnaryExpression(node) {
    return node !== undefined && node.type === 'UnaryExpression';
}
function isArrayExpression(node) {
    return node !== undefined && node.type === 'ArrayExpression';
}
function isRequireModule(node, ...moduleNames) {
    if (isIdentifier(node.callee, 'require') && node.arguments.length === 1) {
        const argument = node.arguments[0];
        if (argument.type === 'Literal') {
            return moduleNames.includes(String(argument.value));
        }
    }
    return false;
}
function isMethodInvocation(callExpression, objectIdentifierName, methodName, minArgs) {
    return (callExpression.callee.type === 'MemberExpression' &&
        isIdentifier(callExpression.callee.object, objectIdentifierName) &&
        isIdentifier(callExpression.callee.property, methodName) &&
        callExpression.callee.property.type === 'Identifier' &&
        callExpression.arguments.length >= minArgs);
}
function isFunctionInvocation(callExpression, functionName, minArgs) {
    return (callExpression.callee.type === 'Identifier' &&
        isIdentifier(callExpression.callee, functionName) &&
        callExpression.arguments.length >= minArgs);
}
function isFunctionCall(node) {
    return node.type === 'CallExpression' && node.callee.type === 'Identifier';
}
function isMethodCall(callExpr) {
    return (callExpr.callee.type === 'MemberExpression' &&
        !callExpr.callee.computed &&
        callExpr.callee.property.type === 'Identifier');
}
function isCallingMethod(callExpr, arity, ...methodNames) {
    return (isMethodCall(callExpr) &&
        callExpr.arguments.length === arity &&
        methodNames.includes(callExpr.callee.property.name));
}
function isNamespaceSpecifier(importDeclaration, name) {
    return importDeclaration.specifiers.some(({ type, local }) => type === 'ImportNamespaceSpecifier' && local.name === name);
}
function isDefaultSpecifier(importDeclaration, name) {
    return importDeclaration.specifiers.some(({ type, local }) => type === 'ImportDefaultSpecifier' && local.name === name);
}
function isModuleExports(node) {
    return (node.type === 'MemberExpression' &&
        node.object.type === 'Identifier' &&
        node.object.name === 'module' &&
        node.property.type === 'Identifier' &&
        node.property.name === 'exports');
}
function isFunctionNode(node) {
    return FUNCTION_NODES.includes(node.type);
}
// we have similar function in eslint-plugin-sonarjs, however this one accepts null
// eventually we should update eslint-plugin-sonarjs
function isLiteral$2(n) {
    return n != null && n.type === 'Literal';
}
function isNullLiteral(n) {
    return isLiteral$2(n) && n.value === null;
}
/**
 * Detect expression statements like the following:
 *  myArray[1] = 42;
 *  myArray[1] += 42;
 *  myObj.prop1 = 3;
 *  myObj.prop1 += 3;
 */
function isElementWrite(statement, ref) {
    if (statement.expression.type === 'AssignmentExpression') {
        const assignmentExpression = statement.expression;
        const lhs = assignmentExpression.left;
        return isMemberExpressionReference(lhs, ref);
    }
    return false;
}
function isMemberExpressionReference(lhs, ref) {
    return (lhs.type === 'MemberExpression' &&
        (isReferenceTo(ref, lhs.object) || isMemberExpressionReference(lhs.object, ref)));
}
function isReferenceTo(ref, node) {
    return node.type === 'Identifier' && node === ref.identifier;
}
function getUniqueWriteUsage(context, name) {
    const variable = getVariableFromName(context, name);
    if (variable) {
        const writeReferences = variable.references.filter(reference => reference.isWrite());
        if (writeReferences.length === 1 && writeReferences[0].writeExpr) {
            return writeReferences[0].writeExpr;
        }
    }
    return undefined;
}
function getUniqueWriteUsageOrNode(context, node) {
    if (node.type === 'Identifier') {
        return getUniqueWriteUsage(context, node.name) || node;
    }
    else {
        return node;
    }
}
function getValueOfExpression(context, expr, type) {
    if (!expr) {
        return undefined;
    }
    if (expr.type === 'Identifier') {
        const usage = getUniqueWriteUsage(context, expr.name);
        if (usage && isNodeType(usage, type)) {
            return usage;
        }
    }
    if (isNodeType(expr, type)) {
        return expr;
    }
    return undefined;
}
// see https://stackoverflow.com/questions/64262105/narrowing-return-value-of-function-based-on-argument
function isNodeType(node, type) {
    return node.type === type;
}
/**
 * for `x = 42` or `let x = 42` when visiting '42' returns 'x' variable
 */
function getLhsVariable(context) {
    const parent = context.getAncestors()[context.getAncestors().length - 1];
    let formIdentifier;
    if (parent.type === 'VariableDeclarator' && parent.id.type === 'Identifier') {
        formIdentifier = parent.id;
    }
    else if (parent.type === 'AssignmentExpression' && parent.left.type === 'Identifier') {
        formIdentifier = parent.left;
    }
    if (formIdentifier) {
        return getVariableFromName(context, formIdentifier.name);
    }
    return undefined;
}
function getVariableFromName(context, name) {
    let scope = context.getScope();
    let variable;
    while (variable == null && scope != null) {
        variable = scope.variables.find(value => value.name === name);
        scope = scope.upper;
    }
    return variable;
}
/**
 * Takes array of arguments. Keeps following variable definitions
 * and unpacking arrays as long as possible. Returns flattened
 * array with all collected nodes.
 *
 * A usage example should clarify why this might be useful.
 * According to ExpressJs `app.use` spec, the arguments can be:
 *
 * - A middleware function.
 * - A series of middleware functions (separated by commas).
 * - An array of middleware functions.
 * - A combination of all of the above.
 *
 * This means that methods like `app.use` accept variable arguments,
 * but also arrays, or combinations thereof. This methods helps
 * to flatten out such complicated composed argument lists.
 */
function flattenArgs(context, args) {
    // Invokes `getUniqueWriteUsageOrNode` at most once, from then on
    // only flattens arrays.
    function recHelper(nodePossiblyIdentifier) {
        const n = getUniqueWriteUsageOrNode(context, nodePossiblyIdentifier);
        if (n.type === 'ArrayExpression') {
            return flatMap(n.elements, recHelper);
        }
        else {
            return [n];
        }
    }
    return flatMap(args, recHelper);
}
function resolveIdentifiers(node, acceptShorthand = false) {
    const identifiers = [];
    resolveIdentifiersAcc(node, identifiers, acceptShorthand);
    return identifiers;
}
function resolveIdentifiersAcc(node, identifiers, acceptShorthand) {
    if (!node) {
        return;
    }
    switch (node.type) {
        case 'Identifier':
            identifiers.push(node);
            break;
        case 'ObjectPattern':
            node.properties.forEach(prop => resolveIdentifiersAcc(prop, identifiers, acceptShorthand));
            break;
        case 'ArrayPattern':
            node.elements.forEach(elem => elem && resolveIdentifiersAcc(elem, identifiers, acceptShorthand));
            break;
        case 'Property':
            if (acceptShorthand || !node.shorthand) {
                resolveIdentifiersAcc(node.value, identifiers, acceptShorthand);
            }
            break;
        case 'RestElement':
            resolveIdentifiersAcc(node.argument, identifiers, acceptShorthand);
            break;
        case 'AssignmentPattern':
            resolveIdentifiersAcc(node.left, identifiers, acceptShorthand);
            break;
        case 'TSParameterProperty':
            resolveIdentifiersAcc(node.parameter, identifiers, acceptShorthand);
            break;
    }
}
function getObjectExpressionProperty(node, propertyKey) {
    if ((node === null || node === void 0 ? void 0 : node.type) === 'ObjectExpression') {
        const properties = node.properties.filter(p => p.type === 'Property' &&
            (isIdentifier(p.key, propertyKey) || (isLiteral$2(p.key) && p.key.value === propertyKey)));
        // if property is duplicated, we return the last defined
        return properties[properties.length - 1];
    }
    return undefined;
}
function getPropertyWithValue(context, objectExpression, propertyName, propertyValue) {
    const maybeProperty = getObjectExpressionProperty(objectExpression, propertyName);
    if (maybeProperty) {
        const maybePropertyValue = getValueOfExpression(context, maybeProperty.value, 'Literal');
        if ((maybePropertyValue === null || maybePropertyValue === void 0 ? void 0 : maybePropertyValue.value) === propertyValue) {
            return maybeProperty;
        }
    }
    return undefined;
}
function resolveFromFunctionReference(context, functionIdentifier) {
    const { scopeManager } = context.getSourceCode();
    for (const scope of scopeManager.scopes) {
        const reference = scope.references.find(r => r.identifier === functionIdentifier);
        if ((reference === null || reference === void 0 ? void 0 : reference.resolved) &&
            reference.resolved.defs.length === 1 &&
            reference.resolved.defs[0].type === 'FunctionName') {
            return reference.resolved.defs[0].node;
        }
    }
    return null;
}
function resolveFunction(context, node) {
    if (isFunctionNode(node)) {
        return node;
    }
    else if (node.type === 'Identifier') {
        return resolveFromFunctionReference(context, node);
    }
    else {
        return null;
    }
}
function checkSensitiveCall(context, callExpression, sensitiveArgumentIndex, sensitiveProperty, sensitivePropertyValue, message) {
    if (callExpression.arguments.length < sensitiveArgumentIndex + 1) {
        return;
    }
    const sensitiveArgument = callExpression.arguments[sensitiveArgumentIndex];
    const options = getValueOfExpression(context, sensitiveArgument, 'ObjectExpression');
    if (!options) {
        return;
    }
    const unsafeProperty = getPropertyWithValue(context, options, sensitiveProperty, sensitivePropertyValue);
    if (unsafeProperty) {
        context.report({
            node: callExpression.callee,
            message: toEncodedMessage$1(message, [unsafeProperty]),
        });
    }
}
function isStringLiteral(node) {
    return node && node.type === 'Literal' && typeof node.value === 'string';
}
function isNumberLiteral(node) {
    return node && node.type === 'Literal' && typeof node.value === 'number';
}
function isRegexLiteral(node) {
    return node.type === 'Literal' && node.value instanceof RegExp;
}
function isDotNotation(node) {
    return node.type === 'MemberExpression' && !node.computed && node.property.type === 'Identifier';
}
function isObjectDestructuring(node) {
    return ((node.type === 'VariableDeclarator' && node.id.type === 'ObjectPattern') ||
        (node.type === 'AssignmentExpression' && node.left.type === 'ObjectPattern'));
}
function isStaticTemplateLiteral(node) {
    return (node.type === 'TemplateLiteral' && node.expressions.length === 0 && node.quasis.length === 1);
}
function isThisExpression(node) {
    return node.type === 'ThisExpression';
}

var Chai;
(function (Chai) {
    function isImported(context) {
        return (getRequireCalls(context).some(r => r.arguments[0].type === 'Literal' && r.arguments[0].value === 'chai') || getImportDeclarations(context).some(i => i.source.value === 'chai'));
    }
    Chai.isImported = isImported;
    function isAssertion(node) {
        return isAssertUsage(node) || isExpectUsage(node) || isShouldUsage(node);
    }
    Chai.isAssertion = isAssertion;
    function isAssertUsage(node) {
        // assert(), assert.<expr>(), chai.assert(), chai.assert.<expr>()
        return (node.type === 'CallExpression' &&
            (isMethodInvocation(node, 'chai', 'assert', 1) ||
                isFunctionInvocation(node, 'assert', 1) ||
                (isMethodCall(node) && isIdentifier(node.callee.object, 'assert')) ||
                (isMethodCall(node) &&
                    node.callee.object.type === 'MemberExpression' &&
                    isIdentifier(node.callee.object.object, 'chai') &&
                    isIdentifier(node.callee.object.property, 'assert'))));
    }
    function isExpectUsage(node) {
        // expect(), chai.expect()
        return (node.type === 'CallExpression' &&
            (isMethodInvocation(node, 'chai', 'expect', 1) || isFunctionInvocation(node, 'expect', 1)));
    }
    function isShouldUsage(node) {
        // <expr>.should.<expr>
        return node.type === 'MemberExpression' && isIdentifier(node.property, 'should');
    }
})(Chai || (Chai = {}));

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const sortLike = ['sort', '"sort"', "'sort'"];
function flatMap(xs, f) {
    const acc = [];
    for (const x of xs) {
        acc.push(...f(x));
    }
    return acc;
}
function last$1(arr) {
    return arr[arr.length - 1];
}

const NUM_ARGS_NODE_MESSAGE = 2;
/**
 * Modifies the behavior of `context.report(descriptor)` for a given rule.
 *
 * Useful for performing additional checks before reporting an issue.
 *
 * @param rule the original rule
 * @param onReport replacement for `context.report(descr)`
 *                 invocations used inside of the rule
 */
function interceptReport(rule, onReport) {
    return Object.assign(Object.assign({}, (!!rule.meta && { meta: rule.meta })), { create(originalContext) {
            const interceptingContext = {
                id: originalContext.id,
                options: originalContext.options,
                settings: originalContext.settings,
                parserPath: originalContext.parserPath,
                parserOptions: originalContext.parserOptions,
                parserServices: originalContext.parserServices,
                getCwd() {
                    return originalContext.getCwd();
                },
                getPhysicalFilename() {
                    return originalContext.getPhysicalFilename();
                },
                getAncestors() {
                    return originalContext.getAncestors();
                },
                getDeclaredVariables(node) {
                    return originalContext.getDeclaredVariables(node);
                },
                getFilename() {
                    return originalContext.getFilename();
                },
                getScope() {
                    return originalContext.getScope();
                },
                getSourceCode() {
                    return originalContext.getSourceCode();
                },
                markVariableAsUsed(name) {
                    return originalContext.markVariableAsUsed(name);
                },
                report(...args) {
                    let descr = undefined;
                    if (args.length === 1) {
                        descr = args[0];
                    }
                    else if (args.length === NUM_ARGS_NODE_MESSAGE && typeof args[1] === 'string') {
                        // not declared in the `.d.ts`, but used in practice by rules written in JS
                        descr = {
                            node: args[0],
                            message: args[1],
                        };
                    }
                    if (descr) {
                        onReport(originalContext, descr);
                    }
                },
            };
            return rule.create(interceptingContext);
        } });
}

var FileType;
(function (FileType) {
    FileType["MAIN"] = "MAIN";
    FileType["TEST"] = "TEST";
})(FileType || (FileType = {}));
function isTestCode(context) {
    return getFileType(context) === FileType.TEST;
}
function getFileType(context) {
    return context.settings['fileType'];
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
// copied from javascript-frontend/src/main/resources/org/sonar/javascript/tree/symbols/globals.json ,
// which should be deleted once the frontend migration is over
const globalsByLibraries = {
    builtin: [
        'Array',
        'ArrayBuffer',
        'Boolean',
        'DataView',
        'Date',
        'Error',
        'EvalError',
        'Float32Array',
        'Float64Array',
        'Function',
        'Infinity',
        'Int16Array',
        'Int32Array',
        'Int8Array',
        'JSON',
        'Map',
        'Math',
        'NaN',
        'Number',
        'Object',
        'Promise',
        'Proxy',
        'RangeError',
        'ReferenceError',
        'Reflect',
        'RegExp',
        'Set',
        'String',
        'Symbol',
        'SyntaxError',
        'System',
        'TypeError',
        'URIError',
        'Uint16Array',
        'Uint32Array',
        'Uint8Array',
        'Uint8ClampedArray',
        'WeakMap',
        'WeakSet',
        'constructor',
        'decodeURI',
        'decodeURIComponent',
        'encodeURI',
        'encodeURIComponent',
        'escape',
        'eval',
        'hasOwnProperty',
        'isFinite',
        'isNaN',
        'isPrototypeOf',
        'parseFloat',
        'parseInt',
        'propertyIsEnumerable',
        'toLocaleString',
        'toString',
        'unescape',
        'valueOf',
    ],
    // https://developer.mozilla.org/en-US/docs/Web/API/Window
    // https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model
    browser: [
        'addEventListener',
        'alert',
        'AnalyserNode',
        'Animation',
        'AnimationEffectReadOnly',
        'AnimationEffectTiming',
        'AnimationEffectTimingReadOnly',
        'AnimationEvent',
        'AnimationPlaybackEvent',
        'AnimationTimeline',
        'applicationCache',
        'ApplicationCache',
        'ApplicationCacheErrorEvent',
        'atob',
        'Attr',
        'Audio',
        'AudioBuffer',
        'AudioBufferSourceNode',
        'AudioContext',
        'AudioDestinationNode',
        'AudioListener',
        'AudioNode',
        'AudioParam',
        'AudioProcessingEvent',
        'AutocompleteErrorEvent',
        'BarProp',
        'BatteryManager',
        'BeforeUnloadEvent',
        'BiquadFilterNode',
        'Blob',
        'blur',
        'btoa',
        'Cache',
        'caches',
        'CacheStorage',
        'cancelAnimationFrame',
        'CanvasGradient',
        'CanvasPattern',
        'CanvasRenderingContext2D',
        'CDATASection',
        'ChannelMergerNode',
        'ChannelSplitterNode',
        'CharacterData',
        'clearInterval',
        'clearTimeout',
        'clientInformation',
        'ClientRect',
        'ClientRectList',
        'ClipboardEvent',
        'close',
        'closed',
        'CloseEvent',
        'Comment',
        'CompositionEvent',
        'confirm',
        'console',
        'ConvolverNode',
        'Credential',
        'CredentialsContainer',
        'crypto',
        'Crypto',
        'CryptoKey',
        'CSS',
        'CSSAnimation',
        'CSSFontFaceRule',
        'CSSImportRule',
        'CSSKeyframeRule',
        'CSSKeyframesRule',
        'CSSMediaRule',
        'CSSPageRule',
        'CSSRule',
        'CSSRuleList',
        'CSSStyleDeclaration',
        'CSSStyleRule',
        'CSSStyleSheet',
        'CSSSupportsRule',
        'CSSTransition',
        'CSSUnknownRule',
        'CSSViewportRule',
        'customElements',
        'CustomEvent',
        'DataTransfer',
        'DataTransferItem',
        'DataTransferItemList',
        'Debug',
        'defaultStatus',
        'defaultstatus',
        'DelayNode',
        'DeviceMotionEvent',
        'DeviceOrientationEvent',
        'devicePixelRatio',
        'dispatchEvent',
        'document',
        'Document',
        'DocumentFragment',
        'DocumentTimeline',
        'DocumentType',
        'DOMError',
        'DOMException',
        'DOMImplementation',
        'DOMParser',
        'DOMSettableTokenList',
        'DOMStringList',
        'DOMStringMap',
        'DOMTokenList',
        'DragEvent',
        'DynamicsCompressorNode',
        'Element',
        'ElementTimeControl',
        'ErrorEvent',
        'event',
        'Event',
        'EventSource',
        'EventTarget',
        'external',
        'FederatedCredential',
        'fetch',
        'File',
        'FileError',
        'FileList',
        'FileReader',
        'find',
        'focus',
        'FocusEvent',
        'FontFace',
        'FormData',
        'frameElement',
        'frames',
        'GainNode',
        'Gamepad',
        'GamepadButton',
        'GamepadEvent',
        'getComputedStyle',
        'getSelection',
        'HashChangeEvent',
        'Headers',
        'history',
        'History',
        'HTMLAllCollection',
        'HTMLAnchorElement',
        'HTMLAppletElement',
        'HTMLAreaElement',
        'HTMLAudioElement',
        'HTMLBaseElement',
        'HTMLBlockquoteElement',
        'HTMLBodyElement',
        'HTMLBRElement',
        'HTMLButtonElement',
        'HTMLCanvasElement',
        'HTMLCollection',
        'HTMLContentElement',
        'HTMLDataListElement',
        'HTMLDetailsElement',
        'HTMLDialogElement',
        'HTMLDirectoryElement',
        'HTMLDivElement',
        'HTMLDListElement',
        'HTMLDocument',
        'HTMLElement',
        'HTMLEmbedElement',
        'HTMLFieldSetElement',
        'HTMLFontElement',
        'HTMLFormControlsCollection',
        'HTMLFormElement',
        'HTMLFrameElement',
        'HTMLFrameSetElement',
        'HTMLHeadElement',
        'HTMLHeadingElement',
        'HTMLHRElement',
        'HTMLHtmlElement',
        'HTMLIFrameElement',
        'HTMLImageElement',
        'HTMLInputElement',
        'HTMLIsIndexElement',
        'HTMLKeygenElement',
        'HTMLLabelElement',
        'HTMLLayerElement',
        'HTMLLegendElement',
        'HTMLLIElement',
        'HTMLLinkElement',
        'HTMLMapElement',
        'HTMLMarqueeElement',
        'HTMLMediaElement',
        'HTMLMenuElement',
        'HTMLMetaElement',
        'HTMLMeterElement',
        'HTMLModElement',
        'HTMLObjectElement',
        'HTMLOListElement',
        'HTMLOptGroupElement',
        'HTMLOptionElement',
        'HTMLOptionsCollection',
        'HTMLOutputElement',
        'HTMLParagraphElement',
        'HTMLParamElement',
        'HTMLPictureElement',
        'HTMLPreElement',
        'HTMLProgressElement',
        'HTMLQuoteElement',
        'HTMLScriptElement',
        'HTMLSelectElement',
        'HTMLShadowElement',
        'HTMLSourceElement',
        'HTMLSpanElement',
        'HTMLStyleElement',
        'HTMLTableCaptionElement',
        'HTMLTableCellElement',
        'HTMLTableColElement',
        'HTMLTableElement',
        'HTMLTableRowElement',
        'HTMLTableSectionElement',
        'HTMLTemplateElement',
        'HTMLTextAreaElement',
        'HTMLTitleElement',
        'HTMLTrackElement',
        'HTMLUListElement',
        'HTMLUnknownElement',
        'HTMLVideoElement',
        'IDBCursor',
        'IDBCursorWithValue',
        'IDBDatabase',
        'IDBEnvironment',
        'IDBFactory',
        'IDBIndex',
        'IDBKeyRange',
        'IDBObjectStore',
        'IDBOpenDBRequest',
        'IDBRequest',
        'IDBTransaction',
        'IDBVersionChangeEvent',
        'Image',
        'ImageBitmap',
        'ImageData',
        'indexedDB',
        'innerHeight',
        'innerWidth',
        'InputEvent',
        'InputMethodContext',
        'IntersectionObserver',
        'IntersectionObserverEntry',
        'Intl',
        'KeyboardEvent',
        'KeyframeEffect',
        'KeyframeEffectReadOnly',
        'length',
        'localStorage',
        'location',
        'Location',
        'locationbar',
        'matchMedia',
        'MediaElementAudioSourceNode',
        'MediaEncryptedEvent',
        'MediaError',
        'MediaKeyError',
        'MediaKeyEvent',
        'MediaKeyMessageEvent',
        'MediaKeys',
        'MediaKeySession',
        'MediaKeyStatusMap',
        'MediaKeySystemAccess',
        'MediaList',
        'MediaQueryList',
        'MediaQueryListEvent',
        'MediaSource',
        'MediaStream',
        'MediaStreamAudioDestinationNode',
        'MediaStreamAudioSourceNode',
        'MediaStreamEvent',
        'MediaStreamTrack',
        'menubar',
        'MessageChannel',
        'MessageEvent',
        'MessagePort',
        'MIDIAccess',
        'MIDIConnectionEvent',
        'MIDIInput',
        'MIDIInputMap',
        'MIDIMessageEvent',
        'MIDIOutput',
        'MIDIOutputMap',
        'MIDIPort',
        'MimeType',
        'MimeTypeArray',
        'MouseEvent',
        'moveBy',
        'moveTo',
        'MutationEvent',
        'MutationObserver',
        'MutationRecord',
        'name',
        'NamedNodeMap',
        'navigator',
        'Navigator',
        'Node',
        'NodeFilter',
        'NodeIterator',
        'NodeList',
        'Notification',
        'OfflineAudioCompletionEvent',
        'OfflineAudioContext',
        'offscreenBuffering',
        'onbeforeunload',
        'onblur',
        'onerror',
        'onfocus',
        'onload',
        'onresize',
        'onunload',
        'open',
        'openDatabase',
        'opener',
        'opera',
        'Option',
        'OscillatorNode',
        'outerHeight',
        'outerWidth',
        'PageTransitionEvent',
        'pageXOffset',
        'pageYOffset',
        'parent',
        'PasswordCredential',
        'Path2D',
        'performance',
        'Performance',
        'PerformanceEntry',
        'PerformanceMark',
        'PerformanceMeasure',
        'PerformanceNavigation',
        'PerformanceResourceTiming',
        'PerformanceTiming',
        'PeriodicWave',
        'Permissions',
        'PermissionStatus',
        'personalbar',
        'Plugin',
        'PluginArray',
        'PopStateEvent',
        'postMessage',
        'print',
        'ProcessingInstruction',
        'ProgressEvent',
        'PromiseRejectionEvent',
        'prompt',
        'PushManager',
        'PushSubscription',
        'RadioNodeList',
        'Range',
        'ReadableByteStream',
        'ReadableStream',
        'removeEventListener',
        'Request',
        'requestAnimationFrame',
        'requestIdleCallback',
        'resizeBy',
        'resizeTo',
        'Response',
        'RTCIceCandidate',
        'RTCSessionDescription',
        'RTCPeerConnection',
        'screen',
        'Screen',
        'screenLeft',
        'ScreenOrientation',
        'screenTop',
        'screenX',
        'screenY',
        'ScriptProcessorNode',
        'scroll',
        'scrollbars',
        'scrollBy',
        'scrollTo',
        'scrollX',
        'scrollY',
        'SecurityPolicyViolationEvent',
        'Selection',
        'self',
        'ServiceWorker',
        'ServiceWorkerContainer',
        'ServiceWorkerRegistration',
        'sessionStorage',
        'setInterval',
        'setTimeout',
        'ShadowRoot',
        'SharedKeyframeList',
        'SharedWorker',
        'showModalDialog',
        'SiteBoundCredential',
        'speechSynthesis',
        'SpeechSynthesisEvent',
        'SpeechSynthesisUtterance',
        'status',
        'statusbar',
        'stop',
        'Storage',
        'StorageEvent',
        'styleMedia',
        'StyleSheet',
        'StyleSheetList',
        'SubtleCrypto',
        'SVGAElement',
        'SVGAltGlyphDefElement',
        'SVGAltGlyphElement',
        'SVGAltGlyphItemElement',
        'SVGAngle',
        'SVGAnimateColorElement',
        'SVGAnimatedAngle',
        'SVGAnimatedBoolean',
        'SVGAnimatedEnumeration',
        'SVGAnimatedInteger',
        'SVGAnimatedLength',
        'SVGAnimatedLengthList',
        'SVGAnimatedNumber',
        'SVGAnimatedNumberList',
        'SVGAnimatedPathData',
        'SVGAnimatedPoints',
        'SVGAnimatedPreserveAspectRatio',
        'SVGAnimatedRect',
        'SVGAnimatedString',
        'SVGAnimatedTransformList',
        'SVGAnimateElement',
        'SVGAnimateMotionElement',
        'SVGAnimateTransformElement',
        'SVGAnimationElement',
        'SVGCircleElement',
        'SVGClipPathElement',
        'SVGColor',
        'SVGColorProfileElement',
        'SVGColorProfileRule',
        'SVGComponentTransferFunctionElement',
        'SVGCSSRule',
        'SVGCursorElement',
        'SVGDefsElement',
        'SVGDescElement',
        'SVGDiscardElement',
        'SVGDocument',
        'SVGElement',
        'SVGElementInstance',
        'SVGElementInstanceList',
        'SVGEllipseElement',
        'SVGEvent',
        'SVGExternalResourcesRequired',
        'SVGFEBlendElement',
        'SVGFEColorMatrixElement',
        'SVGFEComponentTransferElement',
        'SVGFECompositeElement',
        'SVGFEConvolveMatrixElement',
        'SVGFEDiffuseLightingElement',
        'SVGFEDisplacementMapElement',
        'SVGFEDistantLightElement',
        'SVGFEDropShadowElement',
        'SVGFEFloodElement',
        'SVGFEFuncAElement',
        'SVGFEFuncBElement',
        'SVGFEFuncGElement',
        'SVGFEFuncRElement',
        'SVGFEGaussianBlurElement',
        'SVGFEImageElement',
        'SVGFEMergeElement',
        'SVGFEMergeNodeElement',
        'SVGFEMorphologyElement',
        'SVGFEOffsetElement',
        'SVGFEPointLightElement',
        'SVGFESpecularLightingElement',
        'SVGFESpotLightElement',
        'SVGFETileElement',
        'SVGFETurbulenceElement',
        'SVGFilterElement',
        'SVGFilterPrimitiveStandardAttributes',
        'SVGFitToViewBox',
        'SVGFontElement',
        'SVGFontFaceElement',
        'SVGFontFaceFormatElement',
        'SVGFontFaceNameElement',
        'SVGFontFaceSrcElement',
        'SVGFontFaceUriElement',
        'SVGForeignObjectElement',
        'SVGGElement',
        'SVGGeometryElement',
        'SVGGlyphElement',
        'SVGGlyphRefElement',
        'SVGGradientElement',
        'SVGGraphicsElement',
        'SVGHKernElement',
        'SVGICCColor',
        'SVGImageElement',
        'SVGLangSpace',
        'SVGLength',
        'SVGLengthList',
        'SVGLinearGradientElement',
        'SVGLineElement',
        'SVGLocatable',
        'SVGMarkerElement',
        'SVGMaskElement',
        'SVGMatrix',
        'SVGMetadataElement',
        'SVGMissingGlyphElement',
        'SVGMPathElement',
        'SVGNumber',
        'SVGNumberList',
        'SVGPaint',
        'SVGPathElement',
        'SVGPathSeg',
        'SVGPathSegArcAbs',
        'SVGPathSegArcRel',
        'SVGPathSegClosePath',
        'SVGPathSegCurvetoCubicAbs',
        'SVGPathSegCurvetoCubicRel',
        'SVGPathSegCurvetoCubicSmoothAbs',
        'SVGPathSegCurvetoCubicSmoothRel',
        'SVGPathSegCurvetoQuadraticAbs',
        'SVGPathSegCurvetoQuadraticRel',
        'SVGPathSegCurvetoQuadraticSmoothAbs',
        'SVGPathSegCurvetoQuadraticSmoothRel',
        'SVGPathSegLinetoAbs',
        'SVGPathSegLinetoHorizontalAbs',
        'SVGPathSegLinetoHorizontalRel',
        'SVGPathSegLinetoRel',
        'SVGPathSegLinetoVerticalAbs',
        'SVGPathSegLinetoVerticalRel',
        'SVGPathSegList',
        'SVGPathSegMovetoAbs',
        'SVGPathSegMovetoRel',
        'SVGPatternElement',
        'SVGPoint',
        'SVGPointList',
        'SVGPolygonElement',
        'SVGPolylineElement',
        'SVGPreserveAspectRatio',
        'SVGRadialGradientElement',
        'SVGRect',
        'SVGRectElement',
        'SVGRenderingIntent',
        'SVGScriptElement',
        'SVGSetElement',
        'SVGStopElement',
        'SVGStringList',
        'SVGStylable',
        'SVGStyleElement',
        'SVGSVGElement',
        'SVGSwitchElement',
        'SVGSymbolElement',
        'SVGTests',
        'SVGTextContentElement',
        'SVGTextElement',
        'SVGTextPathElement',
        'SVGTextPositioningElement',
        'SVGTitleElement',
        'SVGTransform',
        'SVGTransformable',
        'SVGTransformList',
        'SVGTRefElement',
        'SVGTSpanElement',
        'SVGUnitTypes',
        'SVGURIReference',
        'SVGUseElement',
        'SVGViewElement',
        'SVGViewSpec',
        'SVGVKernElement',
        'SVGZoomAndPan',
        'SVGZoomEvent',
        'Text',
        'TextDecoder',
        'TextEncoder',
        'TextEvent',
        'TextMetrics',
        'TextTrack',
        'TextTrackCue',
        'TextTrackCueList',
        'TextTrackList',
        'TimeEvent',
        'TimeRanges',
        'toolbar',
        'top',
        'Touch',
        'TouchEvent',
        'TouchList',
        'TrackEvent',
        'TransitionEvent',
        'TreeWalker',
        'UIEvent',
        'URL',
        'URLSearchParams',
        'ValidityState',
        'VTTCue',
        'WaveShaperNode',
        'WebGLActiveInfo',
        'WebGLBuffer',
        'WebGLContextEvent',
        'WebGLFramebuffer',
        'WebGLProgram',
        'WebGLRenderbuffer',
        'WebGLRenderingContext',
        'WebGLShader',
        'WebGLShaderPrecisionFormat',
        'WebGLTexture',
        'WebGLUniformLocation',
        'WebSocket',
        'WheelEvent',
        'window',
        'Window',
        'Worker',
        'XDomainRequest',
        'XMLDocument',
        'XMLHttpRequest',
        'XMLHttpRequestEventTarget',
        'XMLHttpRequestProgressEvent',
        'XMLHttpRequestUpload',
        'XMLSerializer',
        'XPathEvaluator',
        'XPathException',
        'XPathExpression',
        'XPathNamespace',
        'XPathNSResolver',
        'XPathResult',
        'XSLTProcessor',
    ],
    worker: [
        'applicationCache',
        'atob',
        'Blob',
        'BroadcastChannel',
        'btoa',
        'Cache',
        'caches',
        'clearInterval',
        'clearTimeout',
        'close',
        'console',
        'fetch',
        'FileReaderSync',
        'FormData',
        'Headers',
        'IDBCursor',
        'IDBCursorWithValue',
        'IDBDatabase',
        'IDBFactory',
        'IDBIndex',
        'IDBKeyRange',
        'IDBObjectStore',
        'IDBOpenDBRequest',
        'IDBRequest',
        'IDBTransaction',
        'IDBVersionChangeEvent',
        'ImageData',
        'importScripts',
        'indexedDB',
        'location',
        'MessageChannel',
        'MessagePort',
        'name',
        'navigator',
        'Notification',
        'onclose',
        'onconnect',
        'onerror',
        'onlanguagechange',
        'onmessage',
        'onoffline',
        'ononline',
        'onrejectionhandled',
        'onunhandledrejection',
        'performance',
        'Performance',
        'PerformanceEntry',
        'PerformanceMark',
        'PerformanceMeasure',
        'PerformanceNavigation',
        'PerformanceResourceTiming',
        'PerformanceTiming',
        'postMessage',
        'Promise',
        'Request',
        'Response',
        'self',
        'ServiceWorkerRegistration',
        'setInterval',
        'setTimeout',
        'TextDecoder',
        'TextEncoder',
        'URL',
        'URLSearchParams',
        'WebSocket',
        'Worker',
        'XMLHttpRequest',
    ],
    // https://nodejs.org/api/globals.html
    node: [
        '__dirname',
        '__filename',
        'Buffer',
        'clearImmediate',
        'clearInterval',
        'clearTimeout',
        'console',
        'exports',
        'global',
        'module',
        'process',
        'require',
        'setImmediate',
        'setInterval',
        'setTimeout',
    ],
    commonjs: ['exports', 'module', 'require', 'global'],
    amd: ['define', 'require'],
    // https://mochajs.org/
    mocha: [
        'after',
        'afterEach',
        'before',
        'beforeEach',
        'context',
        'describe',
        'it',
        'mocha',
        'run',
        'setup',
        'specify',
        'suite',
        'suiteSetup',
        'suiteTeardown',
        'teardown',
        'test',
        'xcontext',
        'xdescribe',
        'xit',
        'xspecify',
    ],
    // https://jasmine.github.io/2.0/introduction.html
    jasmine: [
        'afterAll',
        'afterEach',
        'beforeAll',
        'beforeEach',
        'describe',
        'expect',
        'fail',
        'fdescribe',
        'fit',
        'it',
        'jasmine',
        'pending',
        'runs',
        'spyOn',
        'waits',
        'waitsFor',
        'xdescribe',
        'xit',
    ],
    jest: [
        'afterAll',
        'afterEach',
        'beforeAll',
        'beforeEach',
        'check',
        'describe',
        'expect',
        'gen',
        'it',
        'fit',
        'jest',
        'pit',
        'require',
        'test',
        'xdescribe',
        'xit',
        'xtest',
    ],
    qunit: [
        'asyncTest',
        'deepEqual',
        'equal',
        'expect',
        'module',
        'notDeepEqual',
        'notEqual',
        'notOk',
        'notPropEqual',
        'notStrictEqual',
        'ok',
        'propEqual',
        'QUnit',
        'raises',
        'start',
        'stop',
        'strictEqual',
        'test',
        'throws',
    ],
    phantomjs: ['console', 'exports', 'phantom', 'require', 'WebPage'],
    couch: [
        'emit',
        'exports',
        'getRow',
        'log',
        'module',
        'provides',
        'require',
        'respond',
        'send',
        'start',
        'sum',
    ],
    rhino: [
        'defineClass',
        'deserialize',
        'gc',
        'help',
        'importClass',
        'importPackage',
        'java',
        'load',
        'loadClass',
        'Packages',
        'print',
        'quit',
        'readFile',
        'readUrl',
        'runCommand',
        'seal',
        'serialize',
        'spawn',
        'sync',
        'toint32',
        'version',
    ],
    nashorn: [
        '__DIR__',
        '__FILE__',
        '__LINE__',
        'com',
        'edu',
        'exit',
        'Java',
        'java',
        'javafx',
        'JavaImporter',
        'javax',
        'JSAdapter',
        'load',
        'loadWithNewGlobal',
        'org',
        'Packages',
        'print',
        'quit',
    ],
    wsh: [
        'ActiveXObject',
        'Enumerator',
        'GetObject',
        'ScriptEngine',
        'ScriptEngineBuildVersion',
        'ScriptEngineMajorVersion',
        'ScriptEngineMinorVersion',
        'VBArray',
        'WScript',
        'WSH',
        'XDomainRequest',
    ],
    jquery: ['$', 'jQuery'],
    yui: ['Y', 'YUI', 'YUI_config'],
    shelljs: [
        'cat',
        'cd',
        'chmod',
        'config',
        'cp',
        'dirs',
        'echo',
        'env',
        'error',
        'exec',
        'exit',
        'find',
        'grep',
        'ls',
        'ln',
        'mkdir',
        'mv',
        'popd',
        'pushd',
        'pwd',
        'rm',
        'sed',
        'set',
        'target',
        'tempdir',
        'test',
        'touch',
        'which',
    ],
    prototypejs: [
        '$',
        '$$',
        '$A',
        '$break',
        '$continue',
        '$F',
        '$H',
        '$R',
        '$w',
        'Abstract',
        'Ajax',
        'Autocompleter',
        'Builder',
        'Class',
        'Control',
        'Draggable',
        'Draggables',
        'Droppables',
        'Effect',
        'Element',
        'Enumerable',
        'Event',
        'Field',
        'Form',
        'Hash',
        'Insertion',
        'ObjectRange',
        'PeriodicalExecuter',
        'Position',
        'Prototype',
        'Scriptaculous',
        'Selector',
        'Sortable',
        'SortableObserver',
        'Sound',
        'Template',
        'Toggle',
        'Try',
    ],
    meteor: [
        '$',
        '_',
        'Accounts',
        'AccountsClient',
        'AccountsServer',
        'AccountsCommon',
        'App',
        'Assets',
        'Blaze',
        'check',
        'Cordova',
        'DDP',
        'DDPServer',
        'DDPRateLimiter',
        'Deps',
        'EJSON',
        'Email',
        'HTTP',
        'Log',
        'Match',
        'Meteor',
        'Mongo',
        'MongoInternals',
        'Npm',
        'Package',
        'Plugin',
        'process',
        'Random',
        'ReactiveDict',
        'ReactiveVar',
        'Router',
        'ServiceConfiguration',
        'Session',
        'share',
        'Spacebars',
        'Template',
        'Tinytest',
        'Tracker',
        'UI',
        'Utils',
        'WebApp',
        'WebAppInternals',
    ],
    mongo: [
        '_isWindows',
        '_rand',
        'BulkWriteResult',
        'cat',
        'cd',
        'connect',
        'db',
        'getHostName',
        'getMemInfo',
        'hostname',
        'ISODate',
        'listFiles',
        'load',
        'ls',
        'md5sumFile',
        'mkdir',
        'Mongo',
        'NumberInt',
        'NumberLong',
        'ObjectId',
        'PlanCache',
        'print',
        'printjson',
        'pwd',
        'quit',
        'removeFile',
        'rs',
        'sh',
        'UUID',
        'version',
        'WriteResult',
    ],
    applescript: [
        '$',
        'Application',
        'Automation',
        'console',
        'delay',
        'Library',
        'ObjC',
        'ObjectSpecifier',
        'Path',
        'Progress',
        'Ref',
    ],
    serviceworker: [
        'caches',
        'Cache',
        'CacheStorage',
        'Client',
        'clients',
        'Clients',
        'ExtendableEvent',
        'ExtendableMessageEvent',
        'FetchEvent',
        'importScripts',
        'registration',
        'self',
        'ServiceWorker',
        'ServiceWorkerContainer',
        'ServiceWorkerGlobalScope',
        'ServiceWorkerMessageEvent',
        'ServiceWorkerRegistration',
        'skipWaiting',
        'WindowClient',
    ],
    atomtest: [
        'advanceClock',
        'fakeClearInterval',
        'fakeClearTimeout',
        'fakeSetInterval',
        'fakeSetTimeout',
        'resetTimeouts',
        'waitsForPromise',
    ],
    // https://guides.emberjs.com/v1.10.0/testing/test-helpers/
    embertest: [
        'andThen',
        'click',
        'currentPath',
        'currentRouteName',
        'currentURL',
        'fillIn',
        'find',
        'findWithAssert',
        'keyEvent',
        'pauseTest',
        'triggerEvent',
        'visit',
    ],
    protractor: ['$', '$$', 'browser', 'By', 'by', 'DartObject', 'element', 'protractor'],
    'shared-node-browser': ['clearInterval', 'clearTimeout', 'console', 'setInterval', 'setTimeout'],
    webextensions: ['browser', 'chrome', 'opr'],
    greasemonkey: [
        'GM_addStyle',
        'GM_deleteValue',
        'GM_getResourceText',
        'GM_getResourceURL',
        'GM_getValue',
        'GM_info',
        'GM_listValues',
        'GM_log',
        'GM_openInTab',
        'GM_registerMenuCommand',
        'GM_setClipboard',
        'GM_setValue',
        'GM_xmlhttpRequest',
        'unsafeWindow',
    ],
    flow: [
        'boolean',
        'number',
        'string',
        'null',
        'void',
        'mixed',
        'any',
        'empty',
        'Array',
        'Class',
        '$Call',
        '$TupleMap',
        '$ObjMap',
        '$ElementType',
        '$PropertyType',
        '$Rest',
        '$Diff',
        '$Exact',
        '$ReadOnly',
        '$ReadOnlyArray',
        '$Values',
        '$Keys',
        '$SuperType',
        '$Subtype',
        'RegExp$flags',
        'stream$Writable',
        'stream$Readable',
        'tty$WriteStream',
        'tty$ReadStream',
    ],
};

function toEncodedMessage$1(message, secondaryLocationsHolder, secondaryMessages, cost) {
    const encodedMessage = {
        message,
        cost,
        secondaryLocations: secondaryLocationsHolder.map((locationHolder, index) => toSecondaryLocation$1(locationHolder, !!secondaryMessages ? secondaryMessages[index] : undefined)),
    };
    return JSON.stringify(encodedMessage);
}
function toSecondaryLocation$1(locationHolder, message) {
    if (!locationHolder.loc) {
        throw new Error('Invalid secondary location');
    }
    return {
        message,
        column: locationHolder.loc.start.column,
        line: locationHolder.loc.start.line,
        endColumn: locationHolder.loc.end.column,
        endLine: locationHolder.loc.end.line,
    };
}

var Mocha;
(function (Mocha) {
    const TEST_CONSTRUCTS = [
        'describe',
        'context',
        'it',
        'specify',
        'before',
        'after',
        'beforeEach',
        'afterEach',
    ];
    function isTestConstruct(node, constructs = TEST_CONSTRUCTS) {
        return constructs.some(construct => {
            return (node.type === 'CallExpression' &&
                (isIdentifier(node.callee, construct) ||
                    (node.callee.type === 'MemberExpression' &&
                        isIdentifier(node.callee.object, construct) &&
                        isIdentifier(node.callee.property, 'only', 'skip'))));
        });
    }
    Mocha.isTestConstruct = isTestConstruct;
    function extractTestCase(node) {
        if (isTestCase(node)) {
            const callExpr = node;
            const [, callback] = callExpr.arguments;
            if (callback && FUNCTION_NODES.includes(callback.type)) {
                return { node: callExpr.callee, callback: callback };
            }
        }
        return null;
    }
    Mocha.extractTestCase = extractTestCase;
    function isTestCase(node) {
        return isTestConstruct(node, ['it', 'specify']);
    }
    Mocha.isTestCase = isTestCase;
})(Mocha || (Mocha = {}));

/**
 * Returns the module name, when an identifier either represents a namespace for that module,
 * or is an alias for the default exported value.
 *
 * Returns undefined otherwise.
 * example: Given `import * as X from 'module_name'`, `getModuleNameOfIdentifier(X)`
 * returns `module_name`.
 */
function getModuleNameOfIdentifier(context, identifier) {
    const { name } = identifier;
    // check if importing using `import * as X from 'module_name'`
    const importDeclaration = getImportDeclarations(context).find(importDecl => isNamespaceSpecifier(importDecl, name) || isDefaultSpecifier(importDecl, name));
    if (importDeclaration) {
        return importDeclaration.source;
    }
    // check if importing using `const X = require('module_name')`
    const writeExpression = getUniqueWriteUsage(context, name);
    if (writeExpression) {
        return getModuleNameFromRequire(writeExpression);
    }
    return undefined;
}
/**
 * Returns the module name of either a directly `require`d or referenced module in
 * the following cases:
 *
 *  1. If `node` is a `require('m')` call;
 *  2. If `node` is an identifier `i` bound by an import, as in `import i from 'm'`;
 *  3. If `node` is an identifier `i`, and there is a single assignment with a `require`
 *     on the right hand side, i.e. `var i = require('m')`;
 *
 * then, in all three cases, the returned value will be the name of the module `'m'`.
 *
 * @param node the expression that is expected to evaluate to a module
 * @param context the rule context
 * @return literal with the name of the module or `undefined`.
 */
function getModuleNameOfNode(context, node) {
    if (node.type === 'Identifier') {
        return getModuleNameOfIdentifier(context, node);
    }
    else {
        return getModuleNameFromRequire(node);
    }
}
/**
 * Returns the module name, when an identifier represents a binding imported from another module.
 * Returns undefined otherwise.
 * example: Given `import { f } from 'module_name'`, `getModuleNameOfImportedIdentifier(f)` returns `module_name`
 */
function getModuleNameOfImportedIdentifier(context, identifier) {
    // check if importing using `import { f } from 'module_name'`
    const importedDeclaration = getImportDeclarations(context).find(({ specifiers }) => specifiers.some(spec => spec.type === 'ImportSpecifier' && spec.imported.name === identifier.name));
    if (importedDeclaration) {
        return importedDeclaration.source;
    }
    // check if importing using `const f = require('module_name').f`
    const writeExpression = getUniqueWriteUsage(context, identifier.name);
    if (writeExpression &&
        writeExpression.type === 'MemberExpression' &&
        isIdentifier(writeExpression.property, identifier.name)) {
        return getModuleNameFromRequire(writeExpression.object);
    }
    return undefined;
}
function getImportDeclarations(context) {
    const program = context.getSourceCode().ast;
    if (program.sourceType === 'module') {
        return program.body.filter(node => node.type === 'ImportDeclaration');
    }
    return [];
}
function getRequireCalls(context) {
    const required = [];
    const { scopeManager } = context.getSourceCode();
    scopeManager.scopes.forEach(scope => scope.variables.forEach(variable => variable.defs.forEach(def => {
        if (def.type === 'Variable' && def.node.init) {
            if (isRequire$1(def.node.init)) {
                required.push(def.node.init);
            }
            else if (def.node.init.type === 'MemberExpression' && isRequire$1(def.node.init.object)) {
                required.push(def.node.init.object);
            }
        }
    })));
    return required;
}
function isRequire$1(node) {
    return (node.type === 'CallExpression' &&
        node.callee.type === 'Identifier' &&
        node.callee.name === 'require' &&
        node.arguments.length === 1);
}
function getModuleNameFromRequire(node) {
    if (node.type === 'CallExpression' &&
        isIdentifier(node.callee, 'require') &&
        node.arguments.length === 1) {
        const moduleName = node.arguments[0];
        if (moduleName.type === 'Literal') {
            return moduleName;
        }
    }
    return undefined;
}
function isCallToFQN(context, callExpression, moduleName, functionName) {
    const { callee } = callExpression;
    if (callee.type !== 'MemberExpression') {
        return false;
    }
    const module = getModuleNameOfNode(context, callee.object);
    return (module === null || module === void 0 ? void 0 : module.value) === moduleName && isIdentifier(callee.property, functionName);
}
function getModuleAndCalledMethod(callee, context) {
    let module;
    let method;
    if (callee.type === 'MemberExpression' && callee.object.type === 'Identifier') {
        module = getModuleNameOfIdentifier(context, callee.object);
        method = callee.property;
    }
    if (callee.type === 'Identifier') {
        module = getModuleNameOfImportedIdentifier(context, callee);
        method = callee;
    }
    return { module, method };
}

function findFirstMatchingAncestor(node, predicate) {
    return ancestorsChain(node, new Set()).find(predicate);
}
function localAncestorsChain(node) {
    return ancestorsChain(node, functionLike$1);
}
function ancestorsChain(node, boundaryTypes) {
    const chain = [];
    let currentNode = node.parent;
    while (currentNode) {
        chain.push(currentNode);
        if (boundaryTypes.has(currentNode.type)) {
            break;
        }
        currentNode = currentNode.parent;
    }
    return chain;
}
function getParent(context) {
    const ancestors = context.getAncestors();
    return ancestors.length > 0 ? ancestors[ancestors.length - 1] : undefined;
}

const UNICODE_ESCAPE_LENGTH = 4;
const HEX_ESCAPE_LENGTH = 2;
const CP_BACK_SLASH = cp('\\');
const CP_FORWARD_SLASH = cp('/');
const CP_CR = cp('\r');
const CP_LF = cp('\n');
const CP_n = cp('n');
const CP_r = cp('r');
const CP_t = cp('t');
const CP_b = cp('b');
const CP_v = cp('v');
const CP_f = cp('f');
const CP_u = cp('u');
const CP_x = cp('x');
/**
 * Parse 's' and return array of tokens with range. We assume 's' is correctly terminated because it was already parsed
 * into AST.
 *
 * Inspired by https://github.com/ota-meshi/eslint-plugin-regexp/blob/61ae9424e0f3bde62569718b597cdc036fec9f71/lib/utils/string-literal-parser/tokenizer.ts
 *
 */
function tokenizeString(s) {
    const tokens = [];
    let pos = 0;
    function next() {
        const c = cp(s, pos);
        pos = inc(pos, c);
        return c;
    }
    function readEscape() {
        const c = next();
        switch (c) {
            case CP_n:
                return '\n';
            case CP_r:
                return '\r';
            case CP_t:
                return '\t';
            case CP_b:
                return '\b';
            case CP_v:
                return '\v';
            case CP_f:
                return '\f';
            case CP_BACK_SLASH:
                return '\\';
            case CP_CR:
                if (cp(s, pos) === CP_LF) {
                    pos++; // \r\n
                }
                return '';
            case CP_LF:
                return '';
            case CP_u:
                return String.fromCodePoint(readUnicode());
            case CP_x:
                return String.fromCodePoint(readHex());
            default:
                if (isOctalDigit(c)) {
                    return readOctal(c);
                }
                return String.fromCodePoint(c);
        }
    }
    /**
     * read unicode escape like \u0061 or \u{61}
     */
    function readUnicode() {
        let u;
        if (s.charAt(pos) === '{') {
            pos++;
            const close = s.indexOf('}', pos);
            u = s.substring(pos, close);
            pos = close + 1;
        }
        else {
            u = s.substring(pos, pos + UNICODE_ESCAPE_LENGTH);
            pos += UNICODE_ESCAPE_LENGTH;
        }
        return Number.parseInt(u, 16);
    }
    /**
     * read hex escape like \xA9
     */
    function readHex() {
        const x = Number.parseInt(s.substring(pos, pos + HEX_ESCAPE_LENGTH), 16);
        pos += HEX_ESCAPE_LENGTH;
        return x;
    }
    /**
     * read octal escapes like \251. Octal escape sequences can have 1 - 3 digits
     * and can be padded with 0
     *
     * @param firstDigit digit on the current 'pos' position
     */
    function readOctal(firstDigit) {
        let octal = String.fromCodePoint(firstDigit);
        let i = pos;
        while (isOctalDigit(cp(s, i)) && i - pos < 2) {
            octal += s.charAt(i);
            i++;
        }
        const res = Number.parseInt(octal, 8);
        pos = i;
        return String.fromCodePoint(res);
    }
    while (pos < s.length) {
        const start = pos;
        const c = next();
        if (c === CP_BACK_SLASH) {
            const value = readEscape();
            if (value !== '') {
                tokens.push({ value, range: [start, pos] });
            }
        }
        else if (c === CP_FORWARD_SLASH) {
            const forwardSlash = {
                value: String.fromCodePoint(c),
                range: [start, pos],
            };
            tokens.push(forwardSlash);
            tokens.push(forwardSlash);
        }
        else {
            tokens.push({ value: String.fromCodePoint(c), range: [start, pos] });
        }
    }
    return tokens;
}
function inc(pos, c) {
    // account for UTF-16 low surrogate
    return pos + (c >= 0x10000 ? 2 : 1);
}
function isOctalDigit(c) {
    return c !== undefined && cp('0') <= c && c <= cp('7');
}
function cp(s, i = 0) {
    return s.codePointAt(i);
}

function isArray(node, services) {
    const type = getTypeFromTreeNode$1(node, services);
    return type.symbol && type.symbol.name === 'Array';
}
function isString$1(node, services) {
    const checker = services.program.getTypeChecker();
    const typ = checker.getTypeAtLocation(services.esTreeNodeToTSNodeMap.get(node));
    return (typ.getFlags() & ts__default["default"].TypeFlags.StringLike) !== 0;
}
function isNumber$1(node, services) {
    const checker = services.program.getTypeChecker();
    const typ = checker.getTypeAtLocation(services.esTreeNodeToTSNodeMap.get(node));
    return (typ.getFlags() & ts__default["default"].TypeFlags.NumberLike) !== 0;
}
function isStringType$1(type) {
    var _a;
    return (type.flags & ts__default["default"].TypeFlags.StringLike) > 0 || ((_a = type.symbol) === null || _a === void 0 ? void 0 : _a.name) === 'String';
}
function isFunction$2(node, services) {
    const checker = services.program.getTypeChecker();
    const type = checker.getTypeAtLocation(services.esTreeNodeToTSNodeMap.get(node));
    return type.symbol && (type.symbol.flags & ts__default["default"].SymbolFlags.Function) !== 0;
}
function isUndefinedOrNull(node, services) {
    const checker = services.program.getTypeChecker();
    const typ = checker.getTypeAtLocation(services.esTreeNodeToTSNodeMap.get(node));
    return ((typ.getFlags() & ts__default["default"].TypeFlags.Undefined) !== 0 || (typ.getFlags() & ts__default["default"].TypeFlags.Null) !== 0);
}
function isThenable(node, services) {
    const mapped = services.esTreeNodeToTSNodeMap.get(node);
    const tp = services.program.getTypeChecker().getTypeAtLocation(mapped);
    const thenProperty = tp.getProperty('then');
    return Boolean(thenProperty && thenProperty.flags & ts__default["default"].SymbolFlags.Method);
}
function isAny$2(type) {
    return type.flags === ts__default["default"].TypeFlags.Any;
}
function getTypeFromTreeNode$1(node, services) {
    const checker = services.program.getTypeChecker();
    return checker.getTypeAtLocation(services.esTreeNodeToTSNodeMap.get(node));
}
function getTypeAsString(node, services) {
    const { typeToString, getBaseTypeOfLiteralType } = services.program.getTypeChecker();
    return typeToString(getBaseTypeOfLiteralType(getTypeFromTreeNode$1(node, services)));
}
function getSymbolAtLocation(node, services) {
    const checker = services.program.getTypeChecker();
    return checker.getSymbolAtLocation(services.esTreeNodeToTSNodeMap.get(node));
}
function getSignatureFromCallee(node, services) {
    const checker = services.program.getTypeChecker();
    return checker.getResolvedSignature(services.esTreeNodeToTSNodeMap.get(node));
}

function getParsedRegex(node, context) {
    const patternAndFlags = getPatternFromNode(node, context);
    if (patternAndFlags) {
        try {
            return regexpp__namespace.parseRegExpLiteral(new RegExp(patternAndFlags.pattern, patternAndFlags.flags));
        }
        catch (_a) {
            // do nothing for invalid regex
        }
    }
    return null;
}
function getPatternFromNode(node, context) {
    var _a;
    if (isRegExpConstructor(node)) {
        const patternOnly = getPatternFromNode(node.arguments[0], context);
        const flags = getFlags(node);
        if (patternOnly && flags !== null) {
            return { pattern: patternOnly.pattern, flags };
        }
    }
    else if (isRegexLiteral(node)) {
        return node.regex;
    }
    else if (isStringLiteral(node)) {
        return { pattern: node.value, flags: '' };
    }
    else if (isStaticTemplateLiteral(node)) {
        return { pattern: node.quasis[0].value.raw, flags: '' };
    }
    else if (isIdentifier(node)) {
        const assignedExpression = getUniqueWriteUsage(context, node.name);
        if (assignedExpression &&
            ((_a = assignedExpression.parent) === null || _a === void 0 ? void 0 : _a.type) === 'VariableDeclarator') {
            return getPatternFromNode(assignedExpression, context);
        }
    }
    else if (isBinaryPlus(node)) {
        const left = getPatternFromNode(node.left, context);
        const right = getPatternFromNode(node.right, context);
        if (left && right) {
            return { pattern: left.pattern + right.pattern, flags: '' };
        }
    }
    return null;
}
function isRegExpWithGlobalThis(node) {
    return (node.type === 'NewExpression' &&
        node.callee.type === 'MemberExpression' &&
        isIdentifier(node.callee.object, 'globalThis') &&
        isIdentifier(node.callee.property, 'RegExp') &&
        node.arguments.length > 0);
}
function isRegExpConstructor(node) {
    return (((node.type === 'CallExpression' || node.type === 'NewExpression') &&
        node.callee.type === 'Identifier' &&
        node.callee.name === 'RegExp' &&
        node.arguments.length > 0) ||
        isRegExpWithGlobalThis(node));
}
function getFlags(callExpr) {
    if (callExpr.arguments.length < 2) {
        return '';
    }
    const flags = callExpr.arguments[1];
    if (flags.type === 'Literal' && typeof flags.value === 'string') {
        return flags.value;
    }
    return null;
}
function getRegexpLocation(node, regexpNode, context, offset = [0, 0]) {
    let loc;
    if (isRegexLiteral(node) || isStringLiteral(node)) {
        const source = context.getSourceCode();
        const [start] = node.range;
        const [reStart, reEnd] = getRegexpRange(node, regexpNode);
        loc = {
            start: source.getLocFromIndex(start + reStart + offset[0]),
            end: source.getLocFromIndex(start + reEnd + offset[1]),
        };
    }
    else {
        loc = node.loc;
    }
    return loc;
}
/**
 * Returns the location of regexpNode relative to the node, which is regexp string or literal. If the computation
 * of location fails, it returns the range of the whole node.
 */
function getRegexpRange(node, regexpNode) {
    if (isRegexLiteral(node)) {
        return [regexpNode.start, regexpNode.end];
    }
    if (isStringLiteral(node)) {
        if (node.value === '') {
            return [0, 2];
        }
        const s = node.raw;
        const tokens = tokenizeString(unquote(s));
        if (regexpNode.start === regexpNode.end) {
            // this happens in case of empty alternative node like '|'
            if (regexpNode.start - 1 < tokens.length) {
                // '|' first empty alternative will have start = 1, end = 1
                // +1 is to account for string quote
                return [
                    tokens[regexpNode.start - 1].range[0] + 1,
                    tokens[regexpNode.start - 1].range[0] + 1,
                ];
            }
            else {
                // '|' second empty alternative regex node will have start = 2, end = 2
                // +1 is to account for string quote
                return [last$1(tokens).range[1] + 1, last$1(tokens).range[1] + 1];
            }
        }
        // regexpNode positions are 1 - based, we need to -1 to report as 0 - based
        // it's possible for node start to be outside of range, e.g. `a` in new RegExp('//a')
        const startToken = regexpNode.start - 1;
        if (tokens[startToken] === undefined) {
            // fallback when something is broken
            return nodeRange(node);
        }
        const start = tokens[startToken].range[0];
        // it's possible for node end to be outside of range, e.g. new RegExp('\n(|)')
        const endToken = Math.min(regexpNode.end - 2, tokens.length - 1);
        if (tokens[endToken] === undefined) {
            // fallback when something is broken
            return nodeRange(node);
        }
        const end = tokens[endToken].range[1];
        // +1 is needed to account for string quotes
        return [start + 1, end + 1];
    }
    if (node.type === 'TemplateLiteral') {
        // we don't support these properly
        return nodeRange(node);
    }
    throw new Error(`Expected regexp or string literal, got ${node.type}`);
}
function nodeRange(node) {
    return [0, node.range[1] - node.range[0]];
}
function unquote(s) {
    if (s.charAt(0) !== "'" && s.charAt(0) !== '"') {
        throw new Error(`invalid string to unquote: ${s}`);
    }
    return s.substring(1, s.length - 1);
}
function isStringRegexMethodCall(call, services) {
    return (call.callee.type === 'MemberExpression' &&
        call.callee.property.type === 'Identifier' &&
        !call.callee.computed &&
        ['match', 'matchAll', 'search'].includes(call.callee.property.name) &&
        call.arguments.length > 0 &&
        isString$1(call.callee.object, services) &&
        isString$1(call.arguments[0], services));
}

function childrenOf$1(node, visitorKeys) {
    const keys = visitorKeys[node.type];
    const children = [];
    if (keys) {
        for (const key of keys) {
            const child = node[key];
            if (Array.isArray(child)) {
                children.push(...child);
            }
            else {
                children.push(child);
            }
        }
    }
    return children.filter(Boolean);
}

/**
 * Rule template to create regex rules.
 * @param handlers - the regexpp node handlers
 * @param meta - the (optional) rule metadata
 * @returns the resulting rule module
 */
function createRegExpRule(handlers, metadata = { meta: {} }) {
    return Object.assign(Object.assign({}, metadata), { create(context) {
            const services = parserServices.isRequiredParserServices(context.parserServices)
                ? context.parserServices
                : null;
            function checkRegex(node, regExpAST) {
                if (!regExpAST) {
                    return;
                }
                const ctx = Object.create(context);
                ctx.node = node;
                ctx.reportRegExpNode = reportRegExpNode;
                regexpp__namespace.visitRegExpAST(regExpAST, handlers(ctx));
            }
            function reportRegExpNode(descriptor) {
                const { node, regexpNode, message, offset = [0, 0] } = descriptor;
                const loc = getRegexpLocation(node, regexpNode, context, offset);
                context.report({ message, loc });
            }
            function checkLiteral(literal) {
                checkRegex(literal, getParsedRegex(literal, context));
            }
            function checkCallExpression(callExpr) {
                let parsedRegex = getParsedRegex(callExpr, context);
                if (!parsedRegex && services && isStringRegexMethodCall(callExpr, services)) {
                    const [implicitRegex] = callExpr.arguments;
                    parsedRegex = getParsedRegex(implicitRegex, context);
                }
                checkRegex(callExpr.arguments[0], parsedRegex);
            }
            return {
                'Literal[regex]': checkLiteral,
                NewExpression: checkCallExpression,
                CallExpression: checkCallExpression,
            };
        } });
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
var Position;
(function (Position) {
    Position[Position["BEGINNING"] = 0] = "BEGINNING";
    Position[Position["END"] = 1] = "END";
})(Position || (Position = {}));
const rule$2$ = createRegExpRule(context => {
    return {
        onPatternEnter: (pattern) => {
            const { alternatives } = pattern;
            if (alternatives.length > 1 &&
                (anchoredAt(alternatives, Position.BEGINNING) || anchoredAt(alternatives, Position.END)) &&
                notAnchoredElseWhere(alternatives)) {
                context.reportRegExpNode({
                    message: 'Group parts of the regex together to make the intended operator precedence explicit.',
                    node: context.node,
                    regexpNode: pattern,
                });
            }
        },
    };
});
function anchoredAt(alternatives, position) {
    const itemIndex = position === Position.BEGINNING ? 0 : alternatives.length - 1;
    const firstOrLast = alternatives[itemIndex];
    return isAnchored(firstOrLast, position);
}
function notAnchoredElseWhere(alternatives) {
    if (isAnchored(alternatives[0], Position.END) ||
        isAnchored(alternatives[alternatives.length - 1], Position.BEGINNING)) {
        return false;
    }
    for (const alternative of alternatives.slice(1, alternatives.length - 1)) {
        if (isAnchored(alternative, Position.BEGINNING) || isAnchored(alternative, Position.END)) {
            return false;
        }
    }
    return true;
}
function isAnchored(alternative, position) {
    const { elements } = alternative;
    if (elements.length === 0) {
        return false;
    }
    const index = position === Position.BEGINNING ? 0 : elements.length - 1;
    const firstOrLast = elements[index];
    return isAnchor(firstOrLast);
}
function isAnchor(element) {
    return element.type === 'Assertion' && (element.kind === 'start' || element.kind === 'end');
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$2_ = {
    create(context) {
        const services = context.parserServices;
        if (!parserServices.isRequiredParserServices(services)) {
            return {};
        }
        const tc = services.program.getTypeChecker();
        function isBuiltInMethod(symbol) {
            var _a;
            const parent = (_a = symbol.valueDeclaration) === null || _a === void 0 ? void 0 : _a.parent;
            if (!parent || parent.kind !== ts.SyntaxKind.InterfaceDeclaration) {
                return false;
            }
            const parentSymbol = tc.getSymbolAtLocation(parent.name);
            if (!parentSymbol) {
                return false;
            }
            const fqn = tc.getFullyQualifiedName(parentSymbol);
            // some of the built-in objects are deliberately excluded, because they generate many FPs
            // and no relevant TP, e.g. RegExp, Function
            return ['String', 'Math', 'Array', 'Number', 'Date'].includes(fqn);
        }
        function isVarArg(param) {
            return !!param.dotDotDotToken;
        }
        function isTypeParameter(type) {
            return type.getFlags() & ts__default["default"].TypeFlags.TypeParameter;
        }
        function declarationMismatch(declaration, callExpression) {
            const parameters = declaration.parameters;
            for (let i = 0; i < Math.min(parameters.length, callExpression.arguments.length); i++) {
                const parameterType = parameters[i].type;
                if (!parameterType) {
                    return null;
                }
                const declaredType = tc.getTypeFromTypeNode(parameterType);
                const actualType = getTypeFromTreeNode$1(callExpression.arguments[i], services);
                if (
                // @ts-ignore private API, see https://github.com/microsoft/TypeScript/issues/9879
                !tc.isTypeAssignableTo(actualType, declaredType) &&
                    !isTypeParameter(declaredType) &&
                    !ts__default["default"].isFunctionTypeNode(parameterType) &&
                    !isVarArg(parameters[i])) {
                    return { actualType, declaredType, node: callExpression.arguments[i] };
                }
            }
            return null;
        }
        function typeToString(type) {
            return tc.typeToString(tc.getBaseTypeOfLiteralType(type));
        }
        return {
            CallExpression: (node) => {
                const callExpression = node;
                const tsCallExpr = services.esTreeNodeToTSNodeMap.get(callExpression.callee);
                const symbol = tc.getSymbolAtLocation(tsCallExpr);
                if (symbol && symbol.declarations && isBuiltInMethod(symbol)) {
                    let mismatch = null;
                    for (const declaration of symbol.declarations) {
                        mismatch = declarationMismatch(declaration, callExpression);
                        if (!mismatch) {
                            return;
                        }
                    }
                    if (mismatch) {
                        context.report({
                            node: mismatch.node,
                            message: `Verify that argument is of correct type: expected '${typeToString(mismatch.declaredType)}' instead of '${typeToString(mismatch.actualType)}'.`,
                        });
                    }
                }
            },
        };
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$2Z = {
    meta: {
        schema: [
            {
                // internal parameter for rules having secondary locations
                enum: ['sonar-runtime'],
            },
        ],
    },
    create(context) {
        const services = context.parserServices;
        const canResolveType = parserServices.isRequiredParserServices(services);
        function checkArguments(functionCall) {
            const resolvedFunction = resolveFunctionDeclaration(functionCall);
            if (!resolvedFunction) {
                return;
            }
            const { params: functionParameters, declaration: functionDeclaration } = resolvedFunction;
            const argumentNames = functionCall.arguments.map(arg => {
                const argument = arg;
                return nodes.isIdentifier(argument) ? argument.name : undefined;
            });
            for (let argumentIndex = 0; argumentIndex < argumentNames.length; argumentIndex++) {
                const argumentName = argumentNames[argumentIndex];
                if (argumentName) {
                    const swappedArgumentName = getSwappedArgumentName(argumentNames, functionParameters, argumentName, argumentIndex, functionCall);
                    if (swappedArgumentName && !areComparedArguments([argumentName, swappedArgumentName])) {
                        raiseIssue(argumentName, swappedArgumentName, functionDeclaration, functionCall);
                        return;
                    }
                }
            }
        }
        function areComparedArguments(argumentNames) {
            function getName(node) {
                switch (node.type) {
                    case 'Identifier':
                        return node.name;
                    case 'CallExpression':
                        return getName(node.callee);
                    case 'MemberExpression':
                        return getName(node.object);
                    default:
                        return undefined;
                }
            }
            function checkComparedArguments(lhs, rhs) {
                return ([lhs, rhs].map(getName).filter(name => name && argumentNames.includes(name)).length ===
                    argumentNames.length);
            }
            const maybeIfStmt = context
                .getAncestors()
                .reverse()
                .find(ancestor => ancestor.type === 'IfStatement');
            if (maybeIfStmt) {
                const { test } = maybeIfStmt;
                switch (test.type) {
                    case 'BinaryExpression':
                        const binExpr = test;
                        if (['==', '!=', '===', '!==', '<', '<=', '>', '>='].includes(binExpr.operator)) {
                            const { left: lhs, right: rhs } = binExpr;
                            return checkComparedArguments(lhs, rhs);
                        }
                        break;
                    case 'CallExpression':
                        const callExpr = test;
                        if (callExpr.arguments.length === 1 && callExpr.callee.type === 'MemberExpression') {
                            const [lhs, rhs] = [callExpr.callee.object, callExpr.arguments[0]];
                            return checkComparedArguments(lhs, rhs);
                        }
                        break;
                }
            }
            return false;
        }
        function resolveFunctionDeclaration(node) {
            if (canResolveType) {
                return resolveFromTSSignature(node);
            }
            let functionDeclaration = null;
            if (isFunctionNode(node.callee)) {
                functionDeclaration = node.callee;
            }
            else if (node.callee.type === 'Identifier') {
                functionDeclaration = resolveFromFunctionReference(context, node.callee);
            }
            if (!functionDeclaration) {
                return null;
            }
            return {
                params: extractFunctionParameters(functionDeclaration),
                declaration: functionDeclaration,
            };
        }
        function resolveFromTSSignature(node) {
            const signature = getSignatureFromCallee(node, services);
            if (signature && signature.declaration) {
                return {
                    params: signature.parameters.map(param => param.name),
                    declaration: services.tsNodeToESTreeNodeMap.get(signature.declaration),
                };
            }
            return null;
        }
        function getSwappedArgumentName(argumentNames, functionParameters, argumentName, argumentIndex, node) {
            const indexInFunctionDeclaration = functionParameters.findIndex(functionParameterName => functionParameterName === argumentName);
            if (indexInFunctionDeclaration >= 0 && indexInFunctionDeclaration !== argumentIndex) {
                const potentiallySwappedArgument = argumentNames[indexInFunctionDeclaration];
                if (potentiallySwappedArgument &&
                    potentiallySwappedArgument === functionParameters[argumentIndex] &&
                    haveCompatibleTypes(node.arguments[argumentIndex], node.arguments[indexInFunctionDeclaration])) {
                    return potentiallySwappedArgument;
                }
            }
            return null;
        }
        function haveCompatibleTypes(arg1, arg2) {
            if (canResolveType) {
                const type1 = normalizeType(getTypeAsString(arg1, services));
                const type2 = normalizeType(getTypeAsString(arg2, services));
                return type1 === type2;
            }
            return true;
        }
        function raiseIssue(arg1, arg2, functionDeclaration, node) {
            const primaryMessage = `Arguments '${arg1}' and '${arg2}' have the same names but not the same order as the function parameters.`;
            const encodedMessage = {
                message: primaryMessage,
                secondaryLocations: getSecondaryLocations(functionDeclaration),
            };
            context.report({
                message: JSON.stringify(encodedMessage),
                loc: getParametersClauseLocation(node.arguments),
            });
        }
        return {
            NewExpression: (node) => {
                checkArguments(node);
            },
            CallExpression: (node) => {
                checkArguments(node);
            },
        };
    },
};
function extractFunctionParameters(functionDeclaration) {
    return functionDeclaration.params.map(param => {
        const identifiers = resolveIdentifiers(param);
        if (identifiers.length === 1 && identifiers[0]) {
            return identifiers[0].name;
        }
        return undefined;
    });
}
function getSecondaryLocations(functionDeclaration) {
    if (functionDeclaration && functionDeclaration.params && functionDeclaration.params.length > 0) {
        const { start, end } = getParametersClauseLocation(functionDeclaration.params);
        return [
            {
                message: 'Formal parameters',
                line: start.line,
                column: start.column,
                endLine: end.line,
                endColumn: end.column,
            },
        ];
    }
    return [];
}
function getParametersClauseLocation(parameters) {
    const firstParam = parameters[0];
    const lastParam = parameters[parameters.length - 1];
    return { start: firstParam.loc.start, end: lastParam.loc.end };
}
function normalizeType(typeAsString) {
    switch (typeAsString) {
        case 'String':
            return 'string';
        case 'Boolean':
            return 'boolean';
        case 'Number':
            return 'number';
        default:
            return typeAsString;
    }
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const MESSAGE$7 = "Use the rest syntax to declare this function's arguments.";
const SECONDARY_MESSAGE = 'Replace this reference to "arguments".';
const rule$2Y = {
    meta: {
        schema: [
            {
                // internal parameter for rules having secondary locations
                enum: ['sonar-runtime'],
            },
        ],
    },
    create(context) {
        return {
            // Ignore root scope containing global variables
            'Program:exit': () => context
                .getScope()
                .childScopes.forEach(child => checkArgumentsUsageInScopeRecursively(context, child)),
        };
    },
};
function checkArgumentsUsageInScopeRecursively(context, scope) {
    scope.variables
        .filter(variable => variable.name === 'arguments')
        .forEach(variable => checkArgumentsVariableWithoutDefinition(context, variable));
    scope.childScopes.forEach(child => checkArgumentsUsageInScopeRecursively(context, child));
}
function checkArgumentsVariableWithoutDefinition(context, variable) {
    // if variable is a parameter, variable.defs contains one ParameterDefinition with a type: 'Parameter'
    // if variable is a local variable, variable.defs contains one Definition with a type: 'Variable'
    // but if variable is the function arguments, variable.defs is just empty without other hint
    const isLocalVariableOrParameter = variable.defs.length > 0;
    const references = variable.references.filter(ref => !isFollowedByLengthProperty(ref));
    if (!isLocalVariableOrParameter && references.length > 0) {
        const firstReference = references[0];
        const secondaryLocations = references.slice(1).map(ref => ref.identifier);
        context.report({
            node: firstReference.identifier,
            message: toEncodedMessage$1(MESSAGE$7, secondaryLocations, Array(secondaryLocations.length).fill(SECONDARY_MESSAGE)),
        });
    }
}
function isFollowedByLengthProperty(reference) {
    const parent = reference.identifier.parent;
    return (!!parent &&
        parent.type === 'MemberExpression' &&
        parent.property.type === 'Identifier' &&
        parent.property.name === 'length');
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const message$6 = `Add a "return" statement to this callback.`;
const methodsWithCallback = [
    'every',
    'filter',
    'find',
    'findIndex',
    'map',
    'reduce',
    'reduceRight',
    'some',
    'sort',
];
function hasCallBackWithoutReturn(argument, services) {
    const checker = services.program.getTypeChecker();
    const type = checker.getTypeAtLocation(services.esTreeNodeToTSNodeMap.get(argument));
    const signatures = type.getCallSignatures();
    return (signatures.length > 0 &&
        signatures.every(sig => checker.typeToString(sig.getReturnType()) === 'void'));
}
const rule$2X = {
    create(context) {
        const services = context.parserServices;
        if (!parserServices.isRequiredParserServices(services)) {
            return {};
        }
        return {
            'CallExpression[callee.type="MemberExpression"]'(node) {
                const callExpression = node;
                const args = callExpression.arguments;
                const memberExpression = callExpression.callee;
                const { property, object } = memberExpression;
                if (memberExpression.computed || property.type !== 'Identifier' || args.length === 0) {
                    return;
                }
                if (methodsWithCallback.includes(property.name) &&
                    isArray(object, services) &&
                    hasCallBackWithoutReturn(args[0], services)) {
                    context.report(Object.assign({ message: message$6 }, getNodeToReport(args[0], node, context)));
                }
                else if (isMemberExpression(callExpression.callee, 'Array', 'from') &&
                    args.length > 1 &&
                    hasCallBackWithoutReturn(args[1], services)) {
                    context.report(Object.assign({ message: message$6 }, getNodeToReport(args[1], node, context)));
                }
            },
        };
    },
};
function getNodeToReport(node, parent, context) {
    if (node.type === 'FunctionDeclaration' ||
        node.type === 'FunctionExpression' ||
        node.type === 'ArrowFunctionExpression') {
        return {
            loc: locations.getMainFunctionTokenLocation(node, parent, context),
        };
    }
    return {
        node,
    };
}

const rule$2W = {
    create(context) {
        function checkNewExpression(node) {
            const newExpression = node;
            if (newExpression.callee.type === 'Identifier' && newExpression.callee.name === 'Array') {
                let message = 'Use either a literal or "Array.from()" instead of the "Array" constructor.';
                if (newExpression.arguments.length === 1 &&
                    newExpression.arguments[0].type === 'Literal' &&
                    typeof newExpression.arguments[0].value === 'number') {
                    message = 'Use "Array.from()" instead of the "Array" constructor.';
                }
                context.report({ node, message });
            }
        }
        return {
            NewExpression: checkNewExpression,
        };
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
// https://jira.sonarsource.com/browse/RSPEC-3524
const MESSAGE_ADD_PARAMETER = 'Add parentheses around the parameter of this arrow function.';
const MESSAGE_REMOVE_PARAMETER = 'Remove parentheses around the parameter of this arrow function.';
const MESSAGE_ADD_BODY = 'Add curly braces and "return" to this arrow function body.';
const MESSAGE_REMOVE_BODY = 'Remove curly braces and "return" from this arrow function body.';
const rule$2V = {
    meta: {
        schema: [
            {
                type: 'object',
                properties: {
                    requireParameterParentheses: {
                        type: 'boolean',
                    },
                    requireBodyBraces: {
                        type: 'boolean',
                    },
                },
                additionalProperties: false,
            },
        ],
    },
    create(context) {
        const options = context.options[0] || {};
        const requireParameterParentheses = !!options.requireParameterParentheses;
        const requireBodyBraces = !!options.requireBodyBraces;
        return {
            ArrowFunctionExpression(node) {
                const arrowFunction = node;
                checkParameters(context, requireParameterParentheses, arrowFunction);
                checkBody(context, requireBodyBraces, arrowFunction);
            },
        };
    },
};
function checkParameters(context, requireParameterParentheses, arrowFunction) {
    if (arrowFunction.params.length !== 1) {
        return;
    }
    const parameter = arrowFunction.params[0];
    // Looking at the closing parenthesis after the parameter to avoid problems with cases like
    // `functionTakingCallbacks(x => {...})` where the opening parenthesis before `x` isn't part
    // of the function literal
    const tokenAfterParameter = context.getSourceCode().getTokenAfter(parameter);
    const hasParameterParentheses = tokenAfterParameter && tokenAfterParameter.value === ')';
    if (requireParameterParentheses && !hasParameterParentheses) {
        context.report({ node: parameter, message: MESSAGE_ADD_PARAMETER });
    }
    else if (!requireParameterParentheses &&
        !hasGeneric(context, arrowFunction) &&
        hasParameterParentheses) {
        const arrowFunctionComments = context.getSourceCode().getCommentsInside(arrowFunction);
        const arrowFunctionBodyComments = context.getSourceCode().getCommentsInside(arrowFunction.body);
        // parameters comments inside parentheses are not available, so use the following subtraction:
        const hasArrowFunctionParamsComments = arrowFunctionComments.filter(comment => !arrowFunctionBodyComments.includes(comment)).length >
            0;
        if (parameter.type === 'Identifier' &&
            !hasArrowFunctionParamsComments &&
            !parameter.typeAnnotation &&
            !arrowFunction.returnType) {
            context.report({ node: parameter, message: MESSAGE_REMOVE_PARAMETER });
        }
    }
}
function hasGeneric(context, arrowFunction) {
    const offset = arrowFunction.async ? 1 : 0;
    const firstTokenIgnoreAsync = context.getSourceCode().getFirstToken(arrowFunction, offset);
    return firstTokenIgnoreAsync && firstTokenIgnoreAsync.value === '<';
}
function checkBody(context, requireBodyBraces, arrowFunction) {
    const hasBodyBraces = arrowFunction.body.type === 'BlockStatement';
    if (requireBodyBraces && !hasBodyBraces) {
        context.report({ node: arrowFunction.body, message: MESSAGE_ADD_BODY });
    }
    else if (!requireBodyBraces && hasBodyBraces) {
        const statements = arrowFunction.body.body;
        if (statements.length === 1) {
            const statement = statements[0];
            if (isRemovableReturn(statement)) {
                context.report({ node: arrowFunction.body, message: MESSAGE_REMOVE_BODY });
            }
        }
    }
}
function isRemovableReturn(statement) {
    if (statement.type === 'ReturnStatement') {
        const returnStatement = statement;
        const returnExpression = returnStatement.argument;
        if (returnExpression && returnExpression.type !== 'ObjectExpression') {
            const location = returnExpression.loc;
            return location && location.start.line === location.end.line;
        }
    }
    return false;
}

const rule$2U = {
    create(context) {
        const testCases = [];
        return {
            'CallExpression:exit': (node) => {
                const testCase = Mocha.extractTestCase(node);
                if (testCase !== null) {
                    testCases.push(testCase);
                }
            },
            'Program:exit': () => {
                if (Chai.isImported(context)) {
                    testCases.forEach(testCase => checkAssertions(testCase, context));
                }
            },
        };
    },
};
function checkAssertions(testCase, context) {
    const { node, callback } = testCase;
    const visitor = new TestCaseAssertionVisitor(context);
    visitor.visit(callback.body);
    if (visitor.missingAssertions()) {
        context.report({ node, message: 'Add at least one assertion to this test case.' });
    }
}
class TestCaseAssertionVisitor {
    constructor(context) {
        this.context = context;
        this.visitorKeys = context.getSourceCode().visitorKeys;
        this.hasAssertions = false;
    }
    visit(node) {
        if (this.hasAssertions) {
            return;
        }
        if (Chai.isAssertion(node)) {
            this.hasAssertions = true;
            return;
        }
        if (isFunctionCall(node)) {
            const functionDef = resolveFunction(this.context, node.callee);
            if (functionDef) {
                this.visit(functionDef.body);
            }
        }
        for (const child of childrenOf$1(node, this.visitorKeys)) {
            this.visit(child);
        }
    }
    missingAssertions() {
        return !this.hasAssertions;
    }
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const BITWISE_AND_OR = ['&', '|'];
const BITWISE_OPERATORS = [
    '&',
    '|',
    '^',
    '~',
    '<<',
    '>>',
    '>>>',
    '&=',
    '|=',
    '^=',
    '<<=',
    '>>=',
    '>>>=',
];
const rule$2T = {
    create(context) {
        const isNumeric = getNumericTypeChecker(context);
        let lonelyBitwiseAndOr = null;
        let lonelyBitwiseAndOrAncestors = [];
        let fileContainsSeveralBitwiseOperations = false;
        return {
            BinaryExpression(node) {
                const expression = node;
                if (!lonelyBitwiseAndOr &&
                    BITWISE_AND_OR.includes(expression.operator) &&
                    !isNumeric(expression.left) &&
                    !isNumeric(expression.right)) {
                    lonelyBitwiseAndOr = expression;
                    lonelyBitwiseAndOrAncestors = [...context.getAncestors()];
                }
                else if (BITWISE_OPERATORS.includes(expression.operator)) {
                    fileContainsSeveralBitwiseOperations = true;
                }
            },
            'Program:exit': function () {
                if (!fileContainsSeveralBitwiseOperations &&
                    lonelyBitwiseAndOr &&
                    insideCondition(lonelyBitwiseAndOr, lonelyBitwiseAndOrAncestors)) {
                    const op = lonelyBitwiseAndOr.operator;
                    const operatorToken = context.getSourceCode().getTokenAfter(lonelyBitwiseAndOr.left);
                    if (operatorToken) {
                        context.report({
                            loc: operatorToken.loc,
                            message: `Review this use of bitwise "${op}" operator; conditional "${op}${op}" might have been intended.`,
                        });
                    }
                }
            },
        };
    },
};
function insideCondition(node, ancestors) {
    let child = node;
    for (let i = ancestors.length - 1; i >= 0; i--) {
        const parent = ancestors[i];
        if (parent.type === 'IfStatement' ||
            parent.type === 'ForStatement' ||
            parent.type === 'WhileStatement' ||
            parent.type === 'DoWhileStatement' ||
            parent.type === 'ConditionalExpression') {
            return parent.test === child;
        }
        child = parent;
    }
    return false;
}
function getNumericTypeChecker(context) {
    const services = context.parserServices;
    if (!!services && !!services.program && !!services.esTreeNodeToTSNodeMap) {
        return (node) => isNumericType(getTypeFromTreeNode$1(node, services));
    }
    else {
        const numericTypes = ['number', 'bigint'];
        return (node) => node.type === 'Literal' ? numericTypes.includes(typeof node.value) : false;
    }
    function isNumericType(type) {
        return ((type.getFlags() & (ts__namespace.TypeFlags.NumberLike | ts__namespace.TypeFlags.BigIntLike)) !== 0 ||
            (type.isUnionOrIntersection() && !!type.types.find(isNumericType)));
    }
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
// https://jira.sonarsource.com/browse/RSPEC-4798
const rule$2S = {
    meta: {
        messages: {
            provideDefault: "Provide a default value for '{{parameter}}' so that " +
                'the logic of the function is more evident when this parameter is missing. ' +
                'Consider defining another function if providing default value is not possible.',
        },
    },
    create(context) {
        return {
            'FunctionDeclaration, FunctionExpression, ArrowFunctionExpression': (node) => {
                const functionLike = node;
                for (const param of functionLike.params) {
                    if (param.type === 'Identifier' && isOptionalBoolean(param)) {
                        context.report({
                            messageId: 'provideDefault',
                            data: {
                                parameter: param.name,
                            },
                            node: param,
                        });
                    }
                }
            },
        };
    },
};
function isOptionalBoolean(node) {
    return usesQuestionOptionalSyntax(node) || usesUnionUndefinedOptionalSyntax(node);
}
/**
 * Matches "param?: boolean"
 */
function usesQuestionOptionalSyntax(node) {
    return (!!node.optional &&
        !!node.typeAnnotation &&
        node.typeAnnotation.typeAnnotation.type === 'TSBooleanKeyword');
}
/**
 * Matches "boolean | undefined"
 */
function usesUnionUndefinedOptionalSyntax(node) {
    if (!!node.typeAnnotation && node.typeAnnotation.typeAnnotation.type === 'TSUnionType') {
        const types = node.typeAnnotation.typeAnnotation.types;
        return (types.length === 2 &&
            types.some(tp => tp.type === 'TSBooleanKeyword') &&
            types.some(tp => tp.type === 'TSUndefinedKeyword'));
    }
    return false;
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
// https://jira.sonarsource.com/browse/RSPEC-1472
const rule$2R = {
    meta: {
        messages: {
            moveArguments: 'Make those call arguments start on line {{line}}.',
        },
    },
    create(context) {
        return {
            CallExpression: (node) => {
                const call = node;
                if (call.callee.type !== 'CallExpression' && call.arguments.length === 1) {
                    const sourceCode = context.getSourceCode();
                    const parenthesis = sourceCode.getLastTokenBetween(call.callee, call.arguments[0], token => token.type === 'Punctuator' && token.value === ')');
                    const calleeLastLine = (parenthesis ? parenthesis : sourceCode.getLastToken(call.callee))
                        .loc.end.line;
                    const { start } = sourceCode.getTokenAfter(call.callee).loc;
                    if (calleeLastLine !== start.line) {
                        const { end } = sourceCode.getLastToken(call).loc;
                        if (end.line !== start.line) {
                            //If arguments span multiple lines, we only report the first one
                            reportIssue$2(start, calleeLastLine, context);
                        }
                        else {
                            reportIssue$2({ start, end }, calleeLastLine, context);
                        }
                    }
                }
            },
        };
    },
};
function reportIssue$2(loc, line, context) {
    context.report({
        messageId: 'moveArguments',
        data: {
            line: line.toString(),
        },
        loc,
    });
}

/**
 * This modules provides utilities for writing rules about Express.js.
 */
var Express;
(function (Express) {
    const EXPRESS = 'express';
    /**
     * Checks whether the declaration looks somewhat like `<id> = express()`
     * and returns `<id>` if it matches.
     */
    function attemptFindAppInstantiation(varDecl, context) {
        var _a;
        const rhs = varDecl.init;
        if (rhs && rhs.type === 'CallExpression') {
            const { callee } = rhs;
            if (((_a = getModuleNameOfNode(context, callee)) === null || _a === void 0 ? void 0 : _a.value) === EXPRESS) {
                const pattern = varDecl.id;
                return pattern.type === 'Identifier' ? pattern : undefined;
            }
        }
        return undefined;
    }
    Express.attemptFindAppInstantiation = attemptFindAppInstantiation;
    /**
     * Checks whether the function injects an instantiated app and is exported like `module.exports = function(app) {}`
     * or `module.exports.property = function(app) {}`, and returns app if it matches.
     */
    function attemptFindAppInjection(functionDef, context) {
        const app = functionDef.params.find(param => param.type === 'Identifier' && param.name === 'app');
        if (app) {
            const parent = getParent(context);
            if ((parent === null || parent === void 0 ? void 0 : parent.type) === 'AssignmentExpression') {
                const { left } = parent;
                if (left.type === 'MemberExpression' &&
                    (isModuleExports(left) || isModuleExports(left.object))) {
                    return app;
                }
            }
        }
        return undefined;
    }
    Express.attemptFindAppInjection = attemptFindAppInjection;
    /**
     * Checks whether the expression looks somewhat like `app.use(m1, [m2, m3], ..., mN)`,
     * where one of `mK`-nodes satisfies the given predicate.
     */
    function isUsingMiddleware(context, callExpression, app, middlewareNodePredicate) {
        if (isMethodInvocation(callExpression, app.name, 'use', 1)) {
            const flattenedArgs = flattenArgs(context, callExpression.arguments);
            return Boolean(flattenedArgs.find(middlewareNodePredicate));
        }
        return false;
    }
    Express.isUsingMiddleware = isUsingMiddleware;
    /**
     * Checks whether a node looks somewhat like `require('m')()` for
     * some middleware `m` from the list of middlewares.
     */
    function isMiddlewareInstance(context, middlewares, n) {
        var _a;
        if (n.type === 'CallExpression') {
            const usedMiddleware = (_a = getModuleNameOfNode(context, n.callee)) === null || _a === void 0 ? void 0 : _a.value;
            if (usedMiddleware) {
                return middlewares.includes(String(usedMiddleware));
            }
        }
        return false;
    }
    Express.isMiddlewareInstance = isMiddlewareInstance;
    /**
     * Rule factory for detecting sensitive settings that are passed to
     * middlewares eventually used by Express.js applications:
     *
     * app.use(
     *   middleware(settings)
     * )
     *
     * or
     *
     * app.use(
     *   middleware.method(settings)
     * )
     *
     * @param sensitivePropertyFinder - a function looking for a sensitive setting on a middleware call
     * @param message - the reported message when an issue is raised
     * @returns a rule module that raises issues when a sensitive property is found
     */
    function SensitiveMiddlewarePropertyRule(sensitivePropertyFinder, message) {
        return {
            meta: {
                schema: [
                    {
                        // internal parameter for rules having secondary locations
                        enum: ['sonar-runtime'],
                    },
                ],
            },
            create(context) {
                let app;
                let sensitiveProperties;
                function isExposing(middlewareNode) {
                    return Boolean(sensitiveProperties.push(...findSensitiveProperty(middlewareNode)));
                }
                function findSensitiveProperty(middlewareNode) {
                    if (middlewareNode.type === 'CallExpression') {
                        return sensitivePropertyFinder(context, middlewareNode);
                    }
                    return [];
                }
                return {
                    Program: () => {
                        app = null;
                        sensitiveProperties = [];
                    },
                    CallExpression: (node) => {
                        if (app) {
                            const callExpr = node;
                            const isSafe = !isUsingMiddleware(context, callExpr, app, isExposing);
                            if (!isSafe) {
                                for (const sensitive of sensitiveProperties) {
                                    context.report({
                                        node: callExpr,
                                        message: toEncodedMessage$1(message, [sensitive]),
                                    });
                                }
                                sensitiveProperties = [];
                            }
                        }
                    },
                    VariableDeclarator: (node) => {
                        if (!app) {
                            const varDecl = node;
                            const instantiatedApp = attemptFindAppInstantiation(varDecl, context);
                            if (instantiatedApp) {
                                app = instantiatedApp;
                            }
                        }
                    },
                    ':function': (node) => {
                        if (!app) {
                            const functionDef = node;
                            const injectedApp = attemptFindAppInjection(functionDef, context);
                            if (injectedApp) {
                                app = injectedApp;
                            }
                        }
                    },
                };
            },
        };
    }
    Express.SensitiveMiddlewarePropertyRule = SensitiveMiddlewarePropertyRule;
})(Express || (Express = {}));

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const HELMET$7 = 'helmet';
const EXPECT_CERTIFICATE_TRANSPARENCY = 'expectCt';
const rule$2Q = Express.SensitiveMiddlewarePropertyRule(findFalseCertificateTransparencyPropertyFromHelmet, `Make sure disabling Certificate Transparency monitoring is safe here.`);
/**
 * Looks for property `expectCt: false` in node looking
 * somewhat similar to `helmet(<options>?)`, and returns it.
 */
function findFalseCertificateTransparencyPropertyFromHelmet(context, node) {
    var _a;
    let sensitive;
    const { callee, arguments: args } = node;
    if (callee.type === 'Identifier' &&
        ((_a = getModuleNameOfNode(context, callee)) === null || _a === void 0 ? void 0 : _a.value) === HELMET$7 &&
        args.length === 1 &&
        args[0].type === 'ObjectExpression') {
        sensitive = getPropertyWithValue(context, args[0], EXPECT_CERTIFICATE_TRANSPARENCY, false);
    }
    return sensitive ? [sensitive] : [];
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const message$5 = 'Refactor this uncertain assertion; it can succeed for multiple reasons.';
const rule$2P = {
    create(context) {
        if (!Chai.isImported(context)) {
            return {};
        }
        return {
            ExpressionStatement: (node) => {
                const elements = retrieveAssertionChainElements(node.expression);
                if (elements.length > 1 &&
                    (isIdentifier(elements[0].identifier, 'expect') ||
                        getElementIndex(elements, 'should') >= 0)) {
                    checkNotThrow(context, elements);
                    checkNotInclude(context, elements);
                    checkNotHaveProperty(context, elements);
                    checkNotHaveOwnPropertyDescriptor(context, elements);
                    checkNotHaveMembers(context, elements);
                    checkChangeBy(context, elements);
                    checkNotIncDec(context, elements);
                    checkNotBy(context, elements);
                    checkNotFinite(context, elements);
                }
            },
        };
    },
};
function checkNotThrow(context, elements) {
    checkWithCondition(context, elements, 'not', 'throw', args => !!args && args.length > 0);
}
function checkNotInclude(context, elements) {
    checkWithCondition(context, elements, 'not', 'include', args => !!args && args.length > 0 && args[0].type === 'ObjectExpression');
}
function checkNotHaveProperty(context, elements) {
    checkWithCondition(context, elements, 'not', 'property', args => !!args && args.length > 1);
}
function checkNotHaveOwnPropertyDescriptor(context, elements) {
    checkWithCondition(context, elements, 'not', 'ownPropertyDescriptor', args => !!args && args.length > 1);
}
function checkNotHaveMembers(context, elements) {
    checkWithCondition(context, elements, 'not', 'members');
}
function checkChangeBy(context, elements) {
    checkWithCondition(context, elements, 'change', 'by');
}
function checkNotIncDec(context, elements) {
    checkWithCondition(context, elements, 'not', 'increase');
    checkWithCondition(context, elements, 'not', 'decrease');
}
function checkNotBy(context, elements) {
    checkWithCondition(context, elements, 'not', 'by');
}
function checkNotFinite(context, elements) {
    checkWithCondition(context, elements, 'not', 'finite');
}
function checkWithCondition(context, elements, first, second, condition = () => true) {
    const firstIndex = getElementIndex(elements, first);
    const firstElement = elements[firstIndex];
    const secondIndex = getElementIndex(elements, second);
    const secondElement = elements[secondIndex];
    if (firstElement &&
        secondElement &&
        neighborIndexes(firstIndex, secondIndex, elements) &&
        condition(secondElement.arguments)) {
        context.report({
            message: message$5,
            loc: locFromTwoNodes(firstElement.identifier, secondElement.identifier),
        });
    }
}
// first element is not applied to second if between them function call (e.g. fist.foo().second())
function neighborIndexes(firstIndex, secondIndex, elements) {
    if (firstIndex === secondIndex - 2) {
        return !elements[firstIndex + 1].arguments;
    }
    return firstIndex === secondIndex - 1;
}
function retrieveAssertionChainElements(node) {
    let currentNode = node;
    const result = [];
    let currentArguments = undefined;
    while (true) {
        if (isDotNotation(currentNode)) {
            result.push({ identifier: currentNode.property, arguments: currentArguments });
            currentNode = currentNode.object;
            currentArguments = undefined;
        }
        else if (currentNode.type === 'CallExpression') {
            currentArguments = currentNode.arguments;
            currentNode = currentNode.callee;
        }
        else if (isIdentifier(currentNode)) {
            result.push({ identifier: currentNode, arguments: currentArguments });
            break;
        }
        else {
            break;
        }
    }
    return result.reverse();
}
function getElementIndex(elements, name) {
    return elements.findIndex(element => isIdentifier(element.identifier, name));
}
function locFromTwoNodes(start, end) {
    return {
        start: start.loc.start,
        end: end.loc.end,
    };
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
// https://jira.sonarsource.com/browse/RSPEC-101
const rule$2O = {
    meta: {
        messages: {
            renameClass: 'Rename {{symbolType}} "{{symbol}}" to match the regular expression {{format}}.',
        },
    },
    create(context) {
        return {
            ClassDeclaration: (node) => checkName(node, 'class', context),
            TSInterfaceDeclaration: (node) => checkName(node, 'interface', context),
        };
    },
};
function checkName(node, declarationType, context) {
    const [{ format }] = context.options;
    if (node.id) {
        const name = node.id.name;
        if (!name.match(format)) {
            context.report({
                messageId: 'renameClass',
                data: {
                    symbol: name,
                    symbolType: declarationType,
                    format,
                },
                node: node.id,
            });
        }
    }
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$2N = {
    meta: {
        messages: {
            declareClass: 'Declare a "{{class}}" class and move this declaration of "{{declaration}}" into it.',
        },
    },
    create(context) {
        const services = context.parserServices;
        const isFunction = parserServices.isRequiredParserServices(services) ? isFunctionType : isFunctionLike;
        return {
            AssignmentExpression: (node) => {
                const { left, right } = node;
                if (left.type === 'MemberExpression' && isFunction(right, services)) {
                    const [member, prototype] = [left.object, left.property];
                    if (member.type === 'MemberExpression' && prototype.type === 'Identifier') {
                        const [klass, property] = [member.object, member.property];
                        if (klass.type === 'Identifier' &&
                            property.type === 'Identifier' &&
                            property.name === 'prototype') {
                            context.report({
                                messageId: 'declareClass',
                                data: {
                                    class: klass.name,
                                    declaration: prototype.name,
                                },
                                node: left,
                            });
                        }
                    }
                }
            },
        };
    },
};
function isFunctionType(node, services) {
    const type = getTypeFromTreeNode$1(node, services);
    return type.symbol && (type.symbol.flags & ts__namespace.SymbolFlags.Function) !== 0;
}
function isFunctionLike(node, _services) {
    return ['FunctionDeclaration', 'FunctionExpression', 'ArrowFunctionExpression'].includes(node.type);
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
// https://jira.sonarsource.com/browse/RSPEC-1523
// SQ key 'eval'
const rule$2M = {
    meta: {
        messages: {
            safeCode: 'Make sure that this dynamic injection or execution of code is safe.',
        },
    },
    create(context) {
        return {
            CallExpression: (node) => checkCallExpression$5(node, context),
            NewExpression: (node) => checkCallExpression$5(node, context),
        };
    },
};
function checkCallExpression$5(node, context) {
    if (node.callee.type === 'Identifier') {
        const { name } = node.callee;
        if ((name === 'eval' || name === 'Function') && hasAtLeastOneVariableArgument(node.arguments)) {
            context.report({
                messageId: 'safeCode',
                node: node.callee,
            });
        }
    }
}
function hasAtLeastOneVariableArgument(args) {
    return !!args.find(arg => !isLiteral$1(arg));
}
function isLiteral$1(node) {
    if (node.type === 'Literal') {
        return true;
    }
    if (node.type === 'TemplateLiteral') {
        return node.expressions.length === 0;
    }
    return false;
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
// https://jira.sonarsource.com/browse/RSPEC-3616
const rule$2L = {
    meta: {
        messages: {
            specifyCase: `Explicitly specify {{nesting}} separate cases that fall through; currently this case clause only works for "{{expression}}".`,
        },
    },
    create(context) {
        function reportIssue(node, clause, nestingLvl) {
            context.report({
                messageId: 'specifyCase',
                data: {
                    nesting: nestingLvl.toString(),
                    expression: String(getTextFromNode(clause)),
                },
                node,
            });
        }
        function getTextFromNode(node) {
            if (node.type === 'Literal') {
                return node.value;
            }
            else {
                return context.getSourceCode().getText(node);
            }
        }
        return {
            'SwitchCase > SequenceExpression': function (node) {
                const expressions = node.expressions;
                reportIssue(node, expressions[expressions.length - 1], expressions.length);
            },
            'SwitchCase > LogicalExpression': function (node) {
                const firstElemAndNesting = getFirstElementAndNestingLevel(node, 0);
                if (firstElemAndNesting) {
                    reportIssue(node, firstElemAndNesting[0], firstElemAndNesting[1] + 1);
                }
            },
        };
    },
};
function getFirstElementAndNestingLevel(logicalExpression, currentLvl) {
    if (logicalExpression.operator === '||') {
        if (logicalExpression.left.type === 'LogicalExpression') {
            return getFirstElementAndNestingLevel(logicalExpression.left, currentLvl + 1);
        }
        else {
            return [logicalExpression.left, currentLvl + 1];
        }
    }
    return undefined;
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
// https://jira.sonarsource.com/browse/RSPEC-124
const rule$2K = {
    meta: {
        schema: [
            {
                type: 'object',
                properties: {
                    regularExpression: {
                        type: 'string',
                    },
                    message: {
                        type: 'string',
                    },
                    flags: {
                        type: 'string',
                    },
                },
                additionalProperties: false,
            },
        ],
    },
    create(context) {
        const options = context.options[0] || {};
        const flags = options.flags || '';
        const cleanedFlags = 'gimusy'
            .split('')
            .filter(c => flags.includes(c))
            .join('');
        const pattern = options.regularExpression
            ? new RegExp(options.regularExpression, cleanedFlags)
            : undefined;
        const message = options.message || 'The regular expression matches this comment.';
        return {
            'Program:exit': () => {
                context.getSourceCode().getAllComments().forEach(comment => {
                    const rawTextTrimmed = comment.value.trim();
                    if (pattern && pattern.test(rawTextTrimmed)) {
                        context.report({
                            message,
                            loc: comment.loc,
                        });
                    }
                });
            },
        };
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$2J = createRegExpRule(context => {
    let flags;
    return {
        onRegExpLiteralEnter: (node) => {
            ({ flags } = node);
        },
        onCharacterClassEnter: (node) => {
            checkBulkyAnyCharacterClass(node, flags, context);
            checkBulkyNumericCharacterClass(node, context);
            checkBulkyAlphaNumericCharacterClass(node, context);
        },
        onQuantifierEnter: (node) => {
            checkBulkyQuantifier(node, context);
        },
    };
});
function checkBulkyAnyCharacterClass(node, flags, context) {
    if (node.negate || node.elements.length !== 2) {
        return;
    }
    let hasLowerEscapeW = false;
    let hasUpperEscapeW = false;
    let hasLowerEscapeD = false;
    let hasUpperEscapeD = false;
    let hasLowerEscapeS = false;
    let hasUpperEscapeS = false;
    node.elements.forEach(element => {
        hasLowerEscapeW || (hasLowerEscapeW = element.type === 'CharacterSet' && element.kind === 'word' && !element.negate);
        hasUpperEscapeW || (hasUpperEscapeW = element.type === 'CharacterSet' && element.kind === 'word' && element.negate);
        hasLowerEscapeD || (hasLowerEscapeD = element.type === 'CharacterSet' && element.kind === 'digit' && !element.negate);
        hasUpperEscapeD || (hasUpperEscapeD = element.type === 'CharacterSet' && element.kind === 'digit' && element.negate);
        hasLowerEscapeS || (hasLowerEscapeS = element.type === 'CharacterSet' && element.kind === 'space' && !element.negate);
        hasUpperEscapeS || (hasUpperEscapeS = element.type === 'CharacterSet' && element.kind === 'space' && element.negate);
    });
    const isBulkyAnyCharacterClass = (hasLowerEscapeW && hasUpperEscapeW) ||
        (hasLowerEscapeD && hasUpperEscapeD) ||
        (hasLowerEscapeS && hasUpperEscapeS && flags.dotAll);
    if (isBulkyAnyCharacterClass) {
        context.reportRegExpNode({
            message: `Use concise character class syntax '.' instead of '${node.raw}'.`,
            node: context.node,
            regexpNode: node,
        });
    }
}
function checkBulkyNumericCharacterClass(node, context) {
    if (node.elements.length === 1) {
        const [element] = node.elements;
        const hasDigit = element.type === 'CharacterClassRange' && element.raw === '0-9';
        if (hasDigit) {
            const expected = node.negate ? '\\D' : '\\d';
            const actual = node.raw;
            context.reportRegExpNode({
                message: `Use concise character class syntax '${expected}' instead of '${actual}'.`,
                node: context.node,
                regexpNode: node,
            });
        }
    }
}
function checkBulkyAlphaNumericCharacterClass(node, context) {
    if (node.elements.length === 4) {
        let hasDigit = false, hasLowerCase = false, hasUpperCase = false, hasUnderscore = false;
        for (const element of node.elements) {
            hasDigit || (hasDigit = element.type === 'CharacterClassRange' && element.raw === '0-9');
            hasLowerCase || (hasLowerCase = element.type === 'CharacterClassRange' && element.raw === 'a-z');
            hasUpperCase || (hasUpperCase = element.type === 'CharacterClassRange' && element.raw === 'A-Z');
            hasUnderscore || (hasUnderscore = element.type === 'Character' && element.raw === '_');
        }
        if (hasDigit && hasLowerCase && hasUpperCase && hasUnderscore) {
            const expected = node.negate ? '\\W' : '\\w';
            const actual = node.raw;
            context.reportRegExpNode({
                message: `Use concise character class syntax '${expected}' instead of '${actual}'.`,
                node: context.node,
                regexpNode: node,
            });
        }
    }
}
function checkBulkyQuantifier(node, context) {
    const { raw } = node;
    let bulkyQuantifier;
    if (/\{0,1\}\??$/.test(raw)) {
        bulkyQuantifier = { concise: '?', verbose: '{0,1}' };
    }
    else if (/\{0,\}\??$/.test(raw)) {
        bulkyQuantifier = { concise: '*', verbose: '{0,}' };
    }
    else if (/\{1,\}\??$/.test(raw)) {
        bulkyQuantifier = { concise: '+', verbose: '{1,}' };
    }
    else if (/\{(\d+),\1\}\??$/.test(raw)) {
        bulkyQuantifier = { concise: `{${node.min}}`, verbose: `{${node.min},${node.min}}` };
    }
    if (bulkyQuantifier) {
        context.reportRegExpNode({
            message: `Use concise quantifier syntax '${bulkyQuantifier.concise}' instead of '${bulkyQuantifier.verbose}'.`,
            node: context.node,
            regexpNode: node,
        });
    }
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$2I = {
    meta: {
        schema: [
            {
                // internal parameter for rules having secondary locations
                enum: ['sonar-runtime'],
            },
        ],
    },
    create(context) {
        const sourceCode = context.getSourceCode();
        return {
            IfStatement: (node) => {
                const ifStatement = node;
                const parent = getParent(context);
                if (parent && parent.type !== 'IfStatement') {
                    const firstToken = sourceCode.getFirstToken(node);
                    checkIndentation(firstToken, ifStatement.consequent, context);
                }
                if (ifStatement.alternate) {
                    const elseToken = sourceCode.getTokenBefore(ifStatement.alternate, token => token.type === 'Keyword' && token.value === 'else');
                    const alternate = ifStatement.alternate;
                    if (alternate.type === 'IfStatement') {
                        //case with "else if", we have to check the consequent of the next if
                        checkIndentation(elseToken, alternate.consequent, context);
                    }
                    else {
                        checkIndentation(getPrecedingBrace(elseToken, sourceCode) || elseToken, alternate, context, elseToken);
                    }
                }
            },
            'WhileStatement, ForStatement, ForInStatement, ForOfStatement': (node) => {
                const firstToken = sourceCode.getFirstToken(node);
                checkIndentation(firstToken, node.body, context);
            },
        };
    },
};
function checkIndentation(firstToken, statement, context, tokenToReport = firstToken) {
    if (firstToken && tokenToReport && statement.type !== 'BlockStatement') {
        const firstStatementToken = context.getSourceCode().getFirstToken(statement);
        if (firstStatementToken &&
            firstToken.loc.start.column >= firstStatementToken.loc.start.column) {
            const message = `Use curly braces or indentation to denote the code conditionally ` +
                `executed by this "${tokenToReport.value}".`;
            context.report({
                message: toEncodedMessage$1(message, [firstStatementToken]),
                loc: tokenToReport.loc,
            });
        }
    }
}
function getPrecedingBrace(elseToken, sourceCode) {
    if (elseToken) {
        const tokenBeforeElse = sourceCode.getTokenBefore(elseToken);
        if ((tokenBeforeElse === null || tokenBeforeElse === void 0 ? void 0 : tokenBeforeElse.value) === '}' &&
            tokenBeforeElse.loc.start.line === elseToken.loc.start.line) {
            return tokenBeforeElse;
        }
    }
    return undefined;
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const MESSAGE$6 = 'Make sure confidential information is not logged here.';
const rule$2H = {
    meta: {
        schema: [
            {
                // internal parameter for rules having secondary locations
                enum: ['sonar-runtime'],
            },
        ],
    },
    create(context) {
        return {
            NewExpression: (node) => {
                var _a, _b;
                const newExpression = node;
                const { callee } = newExpression;
                let isSignaleCall = false;
                if (callee.type !== 'MemberExpression') {
                    isSignaleCall =
                        ((_a = getModuleNameOfNode(context, callee)) === null || _a === void 0 ? void 0 : _a.value) === 'signale' &&
                            isIdentifier(callee, 'Signale');
                }
                else {
                    isSignaleCall =
                        ((_b = getModuleNameOfNode(context, callee.object)) === null || _b === void 0 ? void 0 : _b.value) === 'signale' &&
                            isIdentifier(callee.property, 'Signale');
                }
                if (!isSignaleCall) {
                    return;
                }
                if (newExpression.arguments.length === 0) {
                    context.report({ node: callee, message: toEncodedMessage$1(MESSAGE$6, []) });
                    return;
                }
                const firstArgument = getValueOfExpression(context, newExpression.arguments[0], 'ObjectExpression');
                if (!firstArgument) {
                    // Argument exists but its value is unknown
                    return;
                }
                const secrets = getObjectExpressionProperty(firstArgument, 'secrets');
                if (secrets &&
                    secrets.value.type === 'ArrayExpression' &&
                    secrets.value.elements.length === 0) {
                    context.report({
                        node: callee,
                        message: toEncodedMessage$1(MESSAGE$6, [secrets]),
                    });
                }
                else if (!secrets) {
                    context.report({
                        node: callee,
                        message: toEncodedMessage$1(MESSAGE$6, [firstArgument]),
                    });
                }
            },
        };
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$2G = {
    meta: {
        messages: {
            removeInstantiationOf: 'Either remove this useless object instantiation of "{{constructor}}" or use it.',
            removeInstantiation: 'Either remove this useless object instantiation or use it.',
        },
    },
    create(context) {
        const sourceCode = context.getSourceCode();
        return {
            'ExpressionStatement > NewExpression': (node) => {
                if (isTestCode(context) || isTryable(node, context)) {
                    return;
                }
                const callee = node.callee;
                if (callee.type === 'Identifier' || callee.type === 'MemberExpression') {
                    const calleeText = sourceCode.getText(callee);
                    const reportLocation = {
                        start: node.loc.start,
                        end: callee.loc.end,
                    };
                    reportIssue$1(reportLocation, `${calleeText}`, 'removeInstantiationOf', context);
                }
                else {
                    const newToken = sourceCode.getFirstToken(node);
                    reportIssue$1(newToken.loc, '', 'removeInstantiation', context);
                }
            },
        };
    },
};
function isTryable(node, context) {
    const ancestors = context.getAncestors();
    let parent = undefined;
    let child = node;
    while ((parent = ancestors.pop()) !== undefined) {
        if (parent.type === 'TryStatement' && parent.block === child) {
            return true;
        }
        child = parent;
    }
    return false;
}
function reportIssue$1(loc, objectText, messageId, context) {
    context.report({
        messageId,
        data: {
            constructor: objectText,
        },
        loc,
    });
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const FORMIDABLE_MODULE$1 = 'formidable';
const KEEP_EXTENSIONS = 'keepExtensions';
const UPLOAD_DIR = 'uploadDir';
const MULTER_MODULE$1 = 'multer';
const STORAGE_OPTION = 'storage';
const DESTINATION_OPTION = 'destination';
const formidableObjects$1 = new Map();
const rule$2F = {
    meta: {
        schema: [
            {
                // internal parameter for rules having secondary locations
                enum: ['sonar-runtime'],
            },
        ],
    },
    create(context) {
        return {
            NewExpression(node) {
                checkCallExpression$4(context, node);
            },
            CallExpression(node) {
                checkCallExpression$4(context, node);
            },
            AssignmentExpression(node) {
                visitAssignment$1(context, node);
            },
            Program() {
                formidableObjects$1.clear();
            },
            'Program:exit'() {
                formidableObjects$1.forEach(value => report$2(context, value.uploadDirSet, value.keepExtensions, value.callExpression));
            },
        };
    },
};
function checkCallExpression$4(context, callExpression) {
    const { callee } = callExpression;
    if (callee.type !== 'Identifier') {
        return;
    }
    const moduleName = getModuleNameOfImportedIdentifier(context, callee) ||
        getModuleNameOfIdentifier(context, callee);
    if ((moduleName === null || moduleName === void 0 ? void 0 : moduleName.value) === FORMIDABLE_MODULE$1) {
        checkFormidable$1(context, callExpression);
    }
    if ((moduleName === null || moduleName === void 0 ? void 0 : moduleName.value) === MULTER_MODULE$1) {
        checkMulter$1(context, callExpression);
    }
}
function checkFormidable$1(context, callExpression) {
    var _a;
    if (callExpression.arguments.length === 0) {
        const formVariable = getLhsVariable(context);
        if (formVariable) {
            formidableObjects$1.set(formVariable, {
                uploadDirSet: false,
                keepExtensions: false,
                callExpression,
            });
        }
        return;
    }
    const options = getValueOfExpression(context, callExpression.arguments[0], 'ObjectExpression');
    if (options) {
        report$2(context, !!getObjectExpressionProperty(options, UPLOAD_DIR), keepExtensionsValue((_a = getObjectExpressionProperty(options, KEEP_EXTENSIONS)) === null || _a === void 0 ? void 0 : _a.value), callExpression);
    }
}
function checkMulter$1(context, callExpression) {
    var _a;
    if (callExpression.arguments.length === 0) {
        return;
    }
    const multerOptions = getValueOfExpression(context, callExpression.arguments[0], 'ObjectExpression');
    if (!multerOptions) {
        return;
    }
    const storagePropertyValue = (_a = getObjectExpressionProperty(multerOptions, STORAGE_OPTION)) === null || _a === void 0 ? void 0 : _a.value;
    if (storagePropertyValue) {
        const storageValue = getValueOfExpression(context, storagePropertyValue, 'CallExpression');
        if (storageValue) {
            const diskStorageCallee = getDiskStorageCalleeIfUnsafeStorage(context, storageValue);
            if (diskStorageCallee) {
                report$2(context, false, false, callExpression, {
                    node: diskStorageCallee,
                    message: 'no destination specified',
                });
            }
        }
    }
}
function getDiskStorageCalleeIfUnsafeStorage(context, storageCreation) {
    const { arguments: args, callee } = storageCreation;
    if (args.length > 0 && isMemberWithProperty(callee, 'diskStorage')) {
        const storageOptions = getValueOfExpression(context, args[0], 'ObjectExpression');
        if (storageOptions && !getObjectExpressionProperty(storageOptions, DESTINATION_OPTION)) {
            return callee;
        }
    }
    return false;
}
function isMemberWithProperty(expr, property) {
    return (expr.type === 'MemberExpression' &&
        expr.property.type === 'Identifier' &&
        expr.property.name === property);
}
function keepExtensionsValue(extensionValue) {
    if (extensionValue &&
        extensionValue.type === 'Literal' &&
        typeof extensionValue.value === 'boolean') {
        return extensionValue.value;
    }
    return false;
}
function visitAssignment$1(context, assignment) {
    const variableProperty = getVariablePropertyFromAssignment(context, assignment);
    if (!variableProperty) {
        return;
    }
    const { objectVariable, property } = variableProperty;
    if (formidableObjects$1.has(objectVariable)) {
        const formOptions = formidableObjects$1.get(objectVariable);
        if (property === UPLOAD_DIR) {
            formOptions.uploadDirSet = true;
        }
        if (property === KEEP_EXTENSIONS) {
            formOptions.keepExtensions = keepExtensionsValue(assignment.right);
        }
    }
}
/**
 * for `x.foo = 42` returns 'x' variable and 'foo' property string
 */
function getVariablePropertyFromAssignment(context, assignment) {
    if (assignment.left.type !== 'MemberExpression') {
        return undefined;
    }
    const memberExpr = assignment.left;
    if (memberExpr.object.type === 'Identifier' && memberExpr.property.type === 'Identifier') {
        const objectVariable = getVariableFromName(context, memberExpr.object.name);
        if (objectVariable) {
            return { objectVariable, property: memberExpr.property.name };
        }
    }
    return undefined;
}
function report$2(context, uploadDirSet, keepExtensions, callExpression, secondaryLocation) {
    let message;
    if (keepExtensions && uploadDirSet) {
        message = 'Restrict the extension of uploaded files.';
    }
    else if (!keepExtensions && !uploadDirSet) {
        message = 'Restrict folder destination of uploaded files.';
    }
    else if (keepExtensions && !uploadDirSet) {
        message = 'Restrict the extension and folder destination of uploaded files.';
    }
    if (message) {
        if (secondaryLocation) {
            message = toEncodedMessage$1(message, [secondaryLocation.node], [secondaryLocation.message]);
        }
        else {
            message = toEncodedMessage$1(message, []);
        }
        context.report({
            message,
            node: callExpression.callee,
        });
    }
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const FORMIDABLE_MODULE = 'formidable';
const MAX_FILE_SIZE = 'maxFileSize';
const FORMIDABLE_DEFAULT_SIZE = 200 * 1024 * 1024;
const MULTER_MODULE = 'multer';
const LIMITS_OPTION = 'limits';
const FILE_SIZE_OPTION = 'fileSize';
const BODY_PARSER_MODULE = 'body-parser';
const BODY_PARSER_DEFAULT_SIZE = bytes.parse('100kb');
const formidableObjects = new Map();
const rule$2E = {
    meta: {
        messages: {
            safeLimit: 'Make sure the content length limit is safe here.',
        },
    },
    create(context) {
        return {
            NewExpression(node) {
                checkCallExpression$3(context, node);
            },
            CallExpression(node) {
                checkCallExpression$3(context, node);
            },
            AssignmentExpression(node) {
                visitAssignment(context, node);
            },
            Program() {
                formidableObjects.clear();
            },
            'Program:exit'() {
                formidableObjects.forEach(value => report$1(context, value.nodeToReport, value.maxFileSize));
            },
        };
    },
};
function checkCallExpression$3(context, callExpression) {
    const { callee } = callExpression;
    let identifierFromModule;
    if (callee.type === 'MemberExpression' && callee.object.type === 'Identifier') {
        identifierFromModule = callee.object;
    }
    else if (callee.type === 'Identifier') {
        identifierFromModule = callee;
    }
    else {
        return;
    }
    const moduleName = getModuleNameOfImportedIdentifier(context, identifierFromModule) ||
        getModuleNameOfIdentifier(context, identifierFromModule);
    if (!moduleName) {
        return;
    }
    if (moduleName.value === FORMIDABLE_MODULE) {
        checkFormidable(context, callExpression);
    }
    if (moduleName.value === MULTER_MODULE) {
        checkMulter(context, callExpression);
    }
    if (moduleName.value === BODY_PARSER_MODULE) {
        checkBodyParser(context, callExpression);
    }
}
function checkFormidable(context, callExpression) {
    if (callExpression.arguments.length === 0) {
        // options will be set later through member assignment
        const formVariable = getLhsVariable(context);
        if (formVariable) {
            formidableObjects.set(formVariable, {
                maxFileSize: FORMIDABLE_DEFAULT_SIZE,
                nodeToReport: callExpression,
            });
        }
        return;
    }
    const options = getValueOfExpression(context, callExpression.arguments[0], 'ObjectExpression');
    if (options) {
        const property = getObjectExpressionProperty(options, MAX_FILE_SIZE);
        checkSize(context, callExpression, property, FORMIDABLE_DEFAULT_SIZE);
    }
}
function checkMulter(context, callExpression) {
    var _a;
    if (callExpression.arguments.length === 0) {
        report$1(context, callExpression.callee);
        return;
    }
    const multerOptions = getValueOfExpression(context, callExpression.arguments[0], 'ObjectExpression');
    if (!multerOptions) {
        return;
    }
    const limitsPropertyValue = (_a = getObjectExpressionProperty(multerOptions, LIMITS_OPTION)) === null || _a === void 0 ? void 0 : _a.value;
    if (limitsPropertyValue && limitsPropertyValue.type === 'ObjectExpression') {
        const fileSizeProperty = getObjectExpressionProperty(limitsPropertyValue, FILE_SIZE_OPTION);
        checkSize(context, callExpression, fileSizeProperty);
    }
    if (!limitsPropertyValue) {
        report$1(context, callExpression.callee);
    }
}
function checkBodyParser(context, callExpression) {
    if (callExpression.arguments.length === 0) {
        checkSize(context, callExpression, undefined, BODY_PARSER_DEFAULT_SIZE, true);
        return;
    }
    const options = getValueOfExpression(context, callExpression.arguments[0], 'ObjectExpression');
    if (!options) {
        return;
    }
    const limitsProperty = getObjectExpressionProperty(options, LIMITS_OPTION);
    checkSize(context, callExpression, limitsProperty, BODY_PARSER_DEFAULT_SIZE, true);
}
function checkSize(context, callExpr, property, defaultLimit, useStandardSizeLimit = false) {
    if (property) {
        const maxFileSizeValue = getSizeValue(context, property.value);
        if (maxFileSizeValue) {
            report$1(context, property, maxFileSizeValue, useStandardSizeLimit);
        }
    }
    else {
        report$1(context, callExpr, defaultLimit, useStandardSizeLimit);
    }
}
function visitAssignment(context, assignment) {
    const variableProperty = getVariablePropertyFromAssignment(context, assignment);
    if (!variableProperty) {
        return;
    }
    const { objectVariable, property } = variableProperty;
    if (formidableObjects.has(objectVariable) && property === MAX_FILE_SIZE) {
        const formOptions = formidableObjects.get(objectVariable);
        const rhsValue = getSizeValue(context, assignment.right);
        if (rhsValue !== undefined) {
            formOptions.maxFileSize = rhsValue;
            formOptions.nodeToReport = assignment;
        }
        else {
            formidableObjects.delete(objectVariable);
        }
    }
}
function getSizeValue(context, node) {
    const literal = getValueOfExpression(context, node, 'Literal');
    if (literal) {
        if (typeof literal.value === 'number') {
            return literal.value;
        }
        else if (typeof literal.value === 'string') {
            return bytes.parse(literal.value);
        }
    }
    return undefined;
}
function report$1(context, nodeToReport, size, useStandardSizeLimit = false) {
    const [fileUploadSizeLimit, standardSizeLimit] = context.options;
    const limitToCompare = useStandardSizeLimit ? standardSizeLimit : fileUploadSizeLimit;
    if (!size || size > limitToCompare) {
        context.report({
            messageId: 'safeLimit',
            node: nodeToReport,
        });
    }
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const HELMET$6 = 'helmet';
const CONTENT_SECURITY_POLICY$2 = 'contentSecurityPolicy';
const rule$2D = Express.SensitiveMiddlewarePropertyRule(findFalseContentSecurityPolicyPropertyFromHelmet, `Make sure not enabling content security policy fetch directives is safe here.`);
/**
 * Looks for property `contentSecurityPolicy: false` in node looking
 * somewhat similar to `helmet(<options>?)`, and returns it.
 */
function findFalseContentSecurityPolicyPropertyFromHelmet(context, node) {
    var _a;
    let sensitive;
    const { callee, arguments: args } = node;
    if (callee.type === 'Identifier' &&
        ((_a = getModuleNameOfNode(context, callee)) === null || _a === void 0 ? void 0 : _a.value) === HELMET$6 &&
        args.length === 1 &&
        args[0].type === 'ObjectExpression') {
        sensitive = getPropertyWithValue(context, args[0], CONTENT_SECURITY_POLICY$2, false);
    }
    return sensitive ? [sensitive] : [];
}

class CookieFlagCheck {
    constructor(context, flag) {
        this.context = context;
        this.flag = flag;
        this.issueMessage = `Make sure creating this cookie without the "${flag}" flag is safe.`;
    }
    checkCookieSession(callExpression) {
        // Sensitive argument for cookie session is first one
        this.checkSensitiveCookieArgument(callExpression, 0);
    }
    checkCookiesMethodCall(callExpression) {
        if (!isIdentifier(callExpression.callee.property, 'set')) {
            return;
        }
        // Sensitive argument is third argument for "cookies.set" calls
        this.checkSensitiveCookieArgument(callExpression, 2);
    }
    checkCsurf(callExpression) {
        // Sensitive argument is first for csurf
        const cookieProperty = this.checkSensitiveObjectArgument(callExpression, 0);
        if (cookieProperty) {
            // csurf cookie property can be passed as a boolean literal,
            // in which case neither "secure" nor "httponly" are enabled by default
            const cookiePropertyLiteral = getValueOfExpression(this.context, cookieProperty.value, 'Literal');
            if ((cookiePropertyLiteral === null || cookiePropertyLiteral === void 0 ? void 0 : cookiePropertyLiteral.value) === true) {
                this.context.report({
                    node: callExpression.callee,
                    message: toEncodedMessage$1(this.issueMessage, [cookiePropertyLiteral]),
                });
            }
        }
    }
    checkExpressSession(callExpression) {
        // Sensitive argument is first for express-session
        this.checkSensitiveObjectArgument(callExpression, 0);
    }
    checkSensitiveCookieArgument(callExpression, sensitiveArgumentIndex) {
        if (callExpression.arguments.length < sensitiveArgumentIndex + 1) {
            return;
        }
        const sensitiveArgument = callExpression.arguments[sensitiveArgumentIndex];
        const cookieObjectExpression = getValueOfExpression(this.context, sensitiveArgument, 'ObjectExpression');
        if (!cookieObjectExpression) {
            return;
        }
        this.checkFlagOnCookieExpression(cookieObjectExpression, sensitiveArgument, cookieObjectExpression, callExpression);
    }
    checkSensitiveObjectArgument(callExpression, argumentIndex) {
        if (callExpression.arguments.length < argumentIndex + 1) {
            return;
        }
        const firstArgument = callExpression.arguments[argumentIndex];
        const objectExpression = getValueOfExpression(this.context, firstArgument, 'ObjectExpression');
        if (!objectExpression) {
            return;
        }
        const cookieProperty = getObjectExpressionProperty(objectExpression, 'cookie');
        if (!cookieProperty) {
            return;
        }
        const cookiePropertyValue = getValueOfExpression(this.context, cookieProperty.value, 'ObjectExpression');
        if (cookiePropertyValue) {
            this.checkFlagOnCookieExpression(cookiePropertyValue, firstArgument, objectExpression, callExpression);
            return;
        }
        return cookieProperty;
    }
    checkFlagOnCookieExpression(cookiePropertyValue, firstArgument, objectExpression, callExpression) {
        const flagProperty = getObjectExpressionProperty(cookiePropertyValue, this.flag);
        if (flagProperty) {
            const flagPropertyValue = getValueOfExpression(this.context, flagProperty.value, 'Literal');
            if ((flagPropertyValue === null || flagPropertyValue === void 0 ? void 0 : flagPropertyValue.value) === false) {
                const secondaryLocations = [flagPropertyValue];
                if (firstArgument !== objectExpression) {
                    secondaryLocations.push(objectExpression);
                }
                this.context.report({
                    node: callExpression.callee,
                    message: toEncodedMessage$1(this.issueMessage, secondaryLocations),
                });
            }
        }
    }
    checkCookiesFromCallExpression(node) {
        const callExpression = node;
        const { callee } = callExpression;
        const moduleName = getModuleNameOfNode(this.context, callee);
        if ((moduleName === null || moduleName === void 0 ? void 0 : moduleName.value) === 'cookie-session') {
            this.checkCookieSession(callExpression);
            return;
        }
        if ((moduleName === null || moduleName === void 0 ? void 0 : moduleName.value) === 'csurf') {
            this.checkCsurf(callExpression);
            return;
        }
        if ((moduleName === null || moduleName === void 0 ? void 0 : moduleName.value) === 'express-session') {
            this.checkExpressSession(callExpression);
            return;
        }
        if (callee.type === 'MemberExpression') {
            const objectValue = getValueOfExpression(this.context, callee.object, 'NewExpression');
            if (objectValue) {
                const module = getModuleNameOfNode(this.context, objectValue.callee);
                if ((module === null || module === void 0 ? void 0 : module.value) === 'cookies') {
                    this.checkCookiesMethodCall(callExpression);
                }
            }
        }
    }
}

const rule$2C = {
    meta: {
        schema: [
            {
                // internal parameter for rules having secondary locations
                enum: ['sonar-runtime'],
            },
        ],
    },
    create(context) {
        return {
            CallExpression: (node) => new CookieFlagCheck(context, 'httpOnly').checkCookiesFromCallExpression(node),
        };
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$2B = {
    meta: {
        messages: {
            safeCookie: 'Make sure that cookie is written safely here.',
        },
    },
    create(context) {
        let usingExpressFramework = false;
        return {
            Program() {
                // init flag for each file
                usingExpressFramework = false;
            },
            Literal(node) {
                if (node.value === 'express') {
                    usingExpressFramework = true;
                }
            },
            AssignmentExpression(node) {
                const { left } = node;
                if (left.type === 'MemberExpression') {
                    const { object, property } = left;
                    if (isIdentifier(object, 'document') && isIdentifier(property, 'cookie')) {
                        context.report({
                            messageId: 'safeCookie',
                            node: left,
                        });
                    }
                }
            },
            CallExpression(node) {
                const { callee, arguments: args } = node;
                if (callee.type === 'MemberExpression' &&
                    usingExpressFramework &&
                    isIdentifier(callee.property, 'cookie', 'cookies')) {
                    context.report({
                        messageId: 'safeCookie',
                        node,
                    });
                }
                if (callee.type === 'MemberExpression' &&
                    isIdentifier(callee.property, 'setHeader') &&
                    isLiteral(args[0], 'Set-Cookie')) {
                    context.report({
                        messageId: 'safeCookie',
                        node: callee,
                    });
                }
            },
        };
    },
};
function isLiteral(node, value) {
    return node && node.type === 'Literal' && node.value === value;
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const MESSAGE$5 = `Make sure that enabling CORS is safe here.`;
const CORS_HEADER = 'Access-Control-Allow-Origin';
const rule$2A = {
    meta: {
        schema: [
            {
                // internal parameter for rules having secondary locations
                enum: ['sonar-runtime'],
            },
        ],
    },
    create(context) {
        function report(node, ...secondaryLocations) {
            const message = toEncodedMessage$1(MESSAGE$5, secondaryLocations);
            context.report({ message, node });
        }
        function isCorsCall(callee) {
            var _a;
            return ((_a = getModuleNameOfNode(context, callee)) === null || _a === void 0 ? void 0 : _a.value) === 'cors';
        }
        return {
            CallExpression(node) {
                const call = node;
                const { callee } = call;
                if (isCorsCall(callee)) {
                    if (call.arguments.length === 0) {
                        report(call);
                        return;
                    }
                    const [arg] = call.arguments;
                    let sensitiveCorsProperty = getSensitiveCorsProperty(arg);
                    if (sensitiveCorsProperty) {
                        report(sensitiveCorsProperty);
                    }
                    if ((arg === null || arg === void 0 ? void 0 : arg.type) === 'Identifier') {
                        const usage = getUniqueWriteUsage(context, arg.name);
                        sensitiveCorsProperty = getSensitiveCorsProperty(usage);
                        if (sensitiveCorsProperty) {
                            report(sensitiveCorsProperty, arg);
                        }
                    }
                }
                if (isSettingCorsHeader(call)) {
                    report(call);
                }
            },
            ObjectExpression(node) {
                const objProperty = getObjectExpressionProperty(node, CORS_HEADER);
                if (objProperty && isAnyDomain(objProperty.value)) {
                    report(objProperty);
                }
            },
        };
    },
};
function isCorsHeader(node) {
    const header = node;
    return nodes.isLiteral(header) && header.value === CORS_HEADER;
}
function isAnyDomain(node) {
    const domain = node;
    return nodes.isLiteral(domain) && domain.value === '*';
}
function getSensitiveCorsProperty(node) {
    const originProperty = getObjectExpressionProperty(node, 'origin');
    if (originProperty && isAnyDomain(originProperty.value)) {
        return originProperty;
    }
    return undefined;
}
function isSettingCorsHeader(call) {
    return isCorsHeader(call.arguments[0]) && isAnyDomain(call.arguments[1]);
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const CSURF_MODULE = 'csurf';
const SAFE_METHODS = ['GET', 'HEAD', 'OPTIONS'];
const rule$2z = {
    meta: {
        schema: [
            {
                // internal parameter for rules having secondary locations
                enum: ['sonar-runtime'],
            },
        ],
    },
    create(context) {
        let globalCsrfProtection = false;
        let importedCsrfMiddleware = false;
        function checkIgnoredMethods(node) {
            if (node.value.type === 'ArrayExpression') {
                const arrayExpr = node.value;
                const unsafeMethods = arrayExpr.elements
                    .filter(isLiteral$2)
                    .filter(e => typeof e.value === 'string' && !SAFE_METHODS.includes(e.value));
                if (unsafeMethods.length > 0) {
                    const [first, ...rest] = unsafeMethods;
                    context.report({
                        message: toEncodedMessage$1('Make sure disabling CSRF protection is safe here.', rest),
                        node: first,
                    });
                }
            }
        }
        function isCsurfMiddleware(node) {
            if ((node === null || node === void 0 ? void 0 : node.type) === 'Identifier') {
                node = getUniqueWriteUsage(context, node.name);
            }
            if (node && node.type === 'CallExpression' && node.callee.type === 'Identifier') {
                const module = getModuleNameOfIdentifier(context, node.callee);
                return (module === null || module === void 0 ? void 0 : module.value) === CSURF_MODULE;
            }
            return false;
        }
        function checkCallExpression(callExpression) {
            const { callee } = callExpression;
            // require('csurf')
            const requiredModule = getModuleNameFromRequire(callExpression);
            if ((requiredModule === null || requiredModule === void 0 ? void 0 : requiredModule.value) === CSURF_MODULE) {
                importedCsrfMiddleware = true;
            }
            // csurf(...)
            if (callee.type === 'Identifier') {
                const moduleName = getModuleNameOfIdentifier(context, callee);
                if ((moduleName === null || moduleName === void 0 ? void 0 : moduleName.value) === CSURF_MODULE) {
                    const [args] = callExpression.arguments;
                    const ignoredMethods = getObjectExpressionProperty(args, 'ignoreMethods');
                    if (ignoredMethods) {
                        checkIgnoredMethods(ignoredMethods);
                    }
                }
            }
            // app.use(csurf(...))
            if (callee.type === 'MemberExpression') {
                if (isIdentifier(callee.property, 'use') &&
                    flattenArgs(context, callExpression.arguments).find(isCsurfMiddleware)) {
                    globalCsrfProtection = true;
                }
                if (isIdentifier(callee.property, 'post', 'put', 'delete', 'patch') &&
                    !globalCsrfProtection &&
                    importedCsrfMiddleware &&
                    !callExpression.arguments.some(arg => isCsurfMiddleware(arg))) {
                    context.report({
                        message: toEncodedMessage$1('Make sure not using CSRF protection is safe here.', []),
                        node: callee,
                    });
                }
            }
        }
        return {
            Program() {
                globalCsrfProtection = false;
            },
            CallExpression(node) {
                checkCallExpression(node);
            },
            ImportDeclaration(node) {
                if (node.source.value === CSURF_MODULE) {
                    importedCsrfMiddleware = true;
                }
            },
        };
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$2y = {
    meta: {
        schema: [
            { type: 'integer' },
            {
                // internal parameter for rules having secondary locations
                enum: ['sonar-runtime'],
            },
        ],
    },
    create(context) {
        const [threshold] = context.options;
        let functionsWithParent;
        let functionsDefiningModule;
        let functionsImmediatelyInvoked;
        return {
            Program: () => {
                functionsWithParent = new Map();
                functionsDefiningModule = [];
                functionsImmediatelyInvoked = [];
            },
            'Program:exit': () => {
                functionsWithParent.forEach((parent, func) => {
                    if (!functionsDefiningModule.includes(func) &&
                        !functionsImmediatelyInvoked.includes(func)) {
                        raiseOnUnauthorizedComplexity(func, parent, threshold, context);
                    }
                });
            },
            'FunctionDeclaration, FunctionExpression, ArrowFunctionExpression': (node) => functionsWithParent.set(node, getParent(context)),
            "CallExpression[callee.type='Identifier'][callee.name='define'] FunctionExpression": (node) => functionsDefiningModule.push(node),
            "NewExpression[callee.type='FunctionExpression'], CallExpression[callee.type='FunctionExpression']": (node) => functionsImmediatelyInvoked.push(node.callee),
        };
    },
};
function raiseOnUnauthorizedComplexity(node, parent, threshold, context) {
    const tokens = computeCyclomaticComplexity(node, parent, context);
    const complexity = tokens.length;
    if (complexity > threshold) {
        context.report({
            message: toEncodedMessage(complexity, threshold, tokens),
            loc: locations.getMainFunctionTokenLocation(node, parent, context),
        });
    }
}
function toEncodedMessage(complexity, threshold, tokens) {
    const encodedMessage = {
        message: `Function has a complexity of ${complexity} which is greater than ${threshold} authorized.`,
        cost: complexity - threshold,
        secondaryLocations: tokens.map(toSecondaryLocation),
    };
    return JSON.stringify(encodedMessage);
}
function toSecondaryLocation(token) {
    return {
        line: token.loc.start.line,
        column: token.loc.start.column,
        endLine: token.loc.end.line,
        endColumn: token.loc.end.column,
        message: '+1',
    };
}
function computeCyclomaticComplexity(node, parent, context) {
    const visitor = new FunctionComplexityVisitor(node, parent, context);
    visitor.visit();
    return visitor.getComplexityTokens();
}
class FunctionComplexityVisitor {
    constructor(root, parent, context) {
        this.root = root;
        this.parent = parent;
        this.context = context;
        this.tokens = [];
    }
    visit() {
        const visitNode = (node) => {
            let token;
            if (isFunctionNode(node)) {
                if (node !== this.root) {
                    return;
                }
                else {
                    token = {
                        loc: locations.getMainFunctionTokenLocation(node, this.parent, this.context),
                    };
                }
            }
            else {
                switch (node.type) {
                    case 'ConditionalExpression':
                        token = this.context
                            .getSourceCode()
                            .getFirstTokenBetween(node.test, node.consequent, token => token.value === '?');
                        break;
                    case 'SwitchCase':
                        // ignore default case
                        if (!node.test) {
                            break;
                        }
                    case 'IfStatement':
                    case 'ForStatement':
                    case 'ForInStatement':
                    case 'ForOfStatement':
                    case 'WhileStatement':
                    case 'DoWhileStatement':
                        token = this.context.getSourceCode().getFirstToken(node);
                        break;
                    case 'LogicalExpression':
                        token = this.context
                            .getSourceCode()
                            .getTokenAfter(node.left, token => ['||', '&&'].includes(token.value) && token.type === 'Punctuator');
                        break;
                }
            }
            if (token) {
                this.tokens.push(token);
            }
            childrenOf$1(node, this.context.getSourceCode().visitorKeys).forEach(visitNode);
        };
        visitNode(this.root);
    }
    getComplexityTokens() {
        return this.tokens;
    }
}

const rule$2x = {
    meta: {
        messages: {
            defineLocally: 'Define this declaration in a local scope or bind explicitly the property to the global object.',
        },
    },
    create(context) {
        return {
            Program() {
                const scope = context.getScope();
                // As we parse every file with "module" source type, we find user defined global variables in the module scope
                const moduleScope = findModuleScope(context);
                moduleScope === null || moduleScope === void 0 ? void 0 : moduleScope.variables.forEach(variable => {
                    var _a;
                    if (scope.variables.find(global => global.name === variable.name)) {
                        // Avoid reporting on redefinitions of actual global variables
                        return;
                    }
                    for (const def of variable.defs) {
                        const defNode = def.node;
                        if (def.type === 'FunctionName' ||
                            (def.type === 'Variable' && ((_a = def.parent) === null || _a === void 0 ? void 0 : _a.kind) === 'var' && !isRequire(def.node.init))) {
                            context.report({
                                node: defNode,
                                messageId: 'defineLocally',
                            });
                            return;
                        }
                    }
                });
            },
        };
    },
};
function findModuleScope(context) {
    return context.getSourceCode().scopeManager.scopes.find(s => s.type === 'module');
}
function isRequire(node) {
    return ((node === null || node === void 0 ? void 0 : node.type) === 'CallExpression' &&
        node.arguments.length === 1 &&
        isIdentifier(node.callee, 'require'));
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$2w = {
    meta: {
        messages: {
            deprecation: "'{{symbol}}' is deprecated. {{reason}}",
        },
    },
    create(context) {
        const services = context.parserServices;
        if (!parserServices.isRequiredParserServices(services)) {
            return {};
        }
        return {
            Identifier: (node) => {
                const parent = getParent(context);
                if (isShortHandProperty(parent) && parent.key === node) {
                    // to not report twice
                    return;
                }
                if (isObjectExpressionProperty(node, context)) {
                    return;
                }
                const id = node;
                const insideImportExport = context.getAncestors().some(anc => anc.type.includes('Import'));
                if (insideImportExport || isDeclaration(id, context)) {
                    return;
                }
                const deprecation = getDeprecation(id, services, context);
                if (deprecation) {
                    context.report({
                        node,
                        messageId: 'deprecation',
                        data: {
                            symbol: id.name,
                            reason: deprecation.reason,
                        },
                    });
                }
            },
        };
    },
};
function isDeclaration(id, context) {
    const parent = getParent(context);
    if (isShortHandProperty(parent) && parent.value === id) {
        return false;
    }
    const variable = context.getScope().variables.find(v => v.name === id.name);
    if (variable) {
        return variable.defs.some(def => def.name === id);
    }
    const declarationTypes = [
        'PropertyDefinition',
        'TSPropertySignature',
        'TSDeclareFunction',
        'FunctionDeclaration',
        'MethodDefinition',
        'TSMethodSignature',
    ];
    return parent && declarationTypes.includes(parent.type);
}
function getDeprecation(id, services, context) {
    const tc = services.program.getTypeChecker();
    const callExpression = getCallExpression(context, id);
    if (callExpression) {
        const tsCallExpression = services.esTreeNodeToTSNodeMap.get(callExpression);
        const signature = tc.getResolvedSignature(tsCallExpression);
        if (signature) {
            const deprecation = getJsDocDeprecation(signature.getJsDocTags());
            if (deprecation) {
                return deprecation;
            }
        }
    }
    const symbol = getSymbol(id, services, context, tc);
    if (!symbol) {
        return undefined;
    }
    if (callExpression && isFunction$1(symbol)) {
        return undefined;
    }
    return getJsDocDeprecation(symbol.getJsDocTags());
}
function getSymbol(id, services, context, tc) {
    let symbol;
    const tsId = services.esTreeNodeToTSNodeMap.get(id);
    const parent = services.esTreeNodeToTSNodeMap.get(getParent(context));
    if (parent.kind === ts__namespace.SyntaxKind.BindingElement) {
        symbol = tc.getTypeAtLocation(parent.parent).getProperty(tsId.text);
    }
    else if ((isPropertyAssignment(parent) && parent.name === tsId) ||
        (isShorthandPropertyAssignment(parent) && parent.name === tsId)) {
        try {
            symbol = tc.getPropertySymbolOfDestructuringAssignment(tsId);
        }
        catch (e) {
            // do nothing, we are in object literal, not destructuring
            // no obvious easy way to check that in advance
        }
    }
    else {
        symbol = tc.getSymbolAtLocation(tsId);
    }
    if (symbol && (symbol.flags & ts__namespace.SymbolFlags.Alias) !== 0) {
        return tc.getAliasedSymbol(symbol);
    }
    return symbol;
}
function getCallExpression(context, id) {
    const ancestors = context.getAncestors();
    let callee = id;
    let parent = ancestors.length > 0 ? ancestors[ancestors.length - 1] : undefined;
    if (parent && parent.type === 'MemberExpression' && parent.property === id) {
        callee = parent;
        parent = ancestors.length > 1 ? ancestors[ancestors.length - 2] : undefined;
    }
    if (isCallExpression(parent, callee)) {
        return parent;
    }
}
function isCallExpression(node, callee) {
    if (node) {
        if (node.type === 'NewExpression' || node.type === 'CallExpression') {
            return node.callee === callee;
        }
        else if (node.type === 'TaggedTemplateExpression') {
            return node.tag === callee;
        }
    }
    return false;
}
function getJsDocDeprecation(tags) {
    for (const tag of tags) {
        if (tag.name === 'deprecated') {
            return tag.text ? { reason: tag.text.map(e => e.text).join(' ') } : new Deprecation();
        }
    }
    return undefined;
}
function isFunction$1(symbol) {
    const { declarations } = symbol;
    if (declarations === undefined || declarations.length === 0) {
        return false;
    }
    switch (declarations[0].kind) {
        case ts__namespace.SyntaxKind.MethodDeclaration:
        case ts__namespace.SyntaxKind.FunctionDeclaration:
        case ts__namespace.SyntaxKind.FunctionExpression:
        case ts__namespace.SyntaxKind.MethodSignature:
            return true;
        default:
            return false;
    }
}
function isPropertyAssignment(node) {
    return node.kind === ts__namespace.SyntaxKind.PropertyAssignment;
}
function isShorthandPropertyAssignment(node) {
    return node.kind === ts__namespace.SyntaxKind.ShorthandPropertyAssignment;
}
function isShortHandProperty(parent) {
    return !!parent && parent.type === 'Property' && parent.shorthand;
}
function isObjectExpressionProperty(node, context) {
    const ancestors = context.getAncestors();
    const parent = ancestors.pop();
    const grandparent = ancestors.pop();
    return ((parent === null || parent === void 0 ? void 0 : parent.type) === 'Property' &&
        !parent.computed &&
        !parent.shorthand &&
        parent.key === node &&
        (grandparent === null || grandparent === void 0 ? void 0 : grandparent.type) === 'ObjectExpression');
}
class Deprecation {
    constructor() {
        this.reason = '';
    }
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const MAX_INDEX = 4;
const isAllowedIndex = (idx) => idx >= 0 && idx <= MAX_INDEX;
const rule$2v = {
    meta: {
        schema: [
            {
                // internal parameter for rules having secondary locations
                enum: ['sonar-runtime'],
            },
        ],
    },
    create(context) {
        function visitStatements(statements) {
            const declarationsByObject = new Map();
            for (const statement of statements) {
                if (statement.type === 'VariableDeclaration') {
                    visitDeclarations(declarationsByObject, statement.declarations);
                }
                else {
                    checkDeclarationsBlock(declarationsByObject);
                    declarationsByObject.clear();
                }
            }
            checkDeclarationsBlock(declarationsByObject);
        }
        function visitDeclarations(declarationsByObject, declarations) {
            for (const declaration of declarations) {
                const id = declaration.id;
                if (declaration.init && id.type === 'Identifier') {
                    const varName = id.name;
                    const expression = declaration.init;
                    if (expression.type !== 'MemberExpression') {
                        continue;
                    }
                    const property = expression.property;
                    if (property.type === 'Identifier' && property.name === varName) {
                        addDeclaration(declarationsByObject, expression.object, declaration);
                    }
                    else if (property.type === 'Literal' &&
                        typeof property.value === 'number' &&
                        isAllowedIndex(property.value)) {
                        addDeclaration(declarationsByObject, expression.object, declaration);
                    }
                }
            }
        }
        function addDeclaration(declarationsByObject, object, declaration) {
            const key = context.getSourceCode().getText(object);
            const value = declarationsByObject.get(key);
            if (value) {
                value.push(declaration);
            }
            else {
                declarationsByObject.set(key, [declaration]);
            }
        }
        function checkDeclarationsBlock(declarationsByObject) {
            declarationsByObject.forEach((declarations, key) => {
                if (declarations.length > 1) {
                    const firstKind = getKind(declarations[0]);
                    const tail = declarations.slice(1);
                    if (tail.every(decl => getKind(decl) === firstKind)) {
                        context.report({
                            node: declarations[0],
                            message: toEncodedMessage$1(`Use destructuring syntax for these assignments from "${key}".`, tail, Array(tail.length).fill('Replace this assignment.')),
                        });
                    }
                }
            });
        }
        return {
            BlockStatement: (node) => {
                visitStatements(node.body);
            },
            SwitchCase: (node) => {
                visitStatements(node.consequent);
            },
            Program: (node) => {
                visitStatements(node.body);
            },
        };
    },
};
function getKind(declarator) {
    const declaration = findFirstMatchingAncestor(declarator, n => n.type === 'VariableDeclaration');
    return declaration && declaration.kind;
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$2u = {
    meta: {
        hasSuggestions: true,
        schema: [
            {
                // internal parameter for rules having secondary locations
                enum: ['sonar-runtime'],
            },
        ],
    },
    create(context) {
        const services = context.parserServices;
        if (!parserServices.isRequiredParserServices(services)) {
            return {};
        }
        function isSameSymbol(s, t) {
            return s.symbol && t.symbol && s.symbol.name === t.symbol.name;
        }
        function isSubType(s, t) {
            return ((s.flags & t.flags) !== 0 ||
                (t.isUnionOrIntersection() && t.types.some(tp => isSubType(s, tp))));
        }
        function isAny(type) {
            return type.flags === ts__namespace.TypeFlags.Any;
        }
        function isUndefinedOrNull(type) {
            return type.flags === ts__namespace.TypeFlags.Null || type.flags === ts__namespace.TypeFlags.Undefined;
        }
        function isThis(node) {
            return node.type === 'ThisExpression';
        }
        function haveDissimilarTypes(lhs, rhs) {
            const { getBaseTypeOfLiteralType } = services.program.getTypeChecker();
            const lhsType = getBaseTypeOfLiteralType(getTypeFromTreeNode$1(lhs, services));
            const rhsType = getBaseTypeOfLiteralType(getTypeFromTreeNode$1(rhs, services));
            return (!isSameSymbol(lhsType, rhsType) &&
                !isSubType(lhsType, rhsType) &&
                !isSubType(rhsType, lhsType) &&
                !isAny(lhsType) &&
                !isAny(rhsType) &&
                !isUndefinedOrNull(lhsType) &&
                !isUndefinedOrNull(rhsType) &&
                !isThis(lhs) &&
                !isThis(rhs));
        }
        return {
            BinaryExpression: (node) => {
                const { left, operator, right } = node;
                if (['===', '!=='].includes(operator) && haveDissimilarTypes(left, right)) {
                    const [actual, expected, outcome] = operator === '===' ? ['===', '==', 'false'] : ['!==', '!=', 'true'];
                    const operatorToken = context
                        .getSourceCode()
                        .getTokensBetween(left, right)
                        .find(token => token.type === 'Punctuator' && token.value === operator);
                    context.report({
                        message: toEncodedMessage$1(`Remove this "${actual}" check; it will always be ${outcome}. Did you mean to use "${expected}"?`, [left, right]),
                        loc: operatorToken.loc,
                        suggest: [
                            {
                                desc: `Replace "${actual}" with "${expected}"`,
                                fix: fixer => fixer.replaceText(operatorToken, expected),
                            },
                        ],
                    });
                }
            },
        };
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const MESSAGE$4 = 'Make sure disabling auto-escaping feature is safe here.';
const rule$2t = {
    meta: {
        schema: [
            {
                // internal parameter for rules having secondary locations
                enum: ['sonar-runtime'],
            },
        ],
    },
    create(context) {
        const services = context.parserServices;
        function isEmptySanitizerFunction(sanitizerFunction) {
            if (sanitizerFunction.params.length !== 1) {
                return false;
            }
            const firstParam = sanitizerFunction.params[0];
            if (firstParam.type !== 'Identifier') {
                return false;
            }
            const firstParamName = firstParam.name;
            if (sanitizerFunction.body.type !== 'BlockStatement') {
                return (sanitizerFunction.body.type === 'Identifier' &&
                    sanitizerFunction.body.name === firstParamName);
            }
            const { body } = sanitizerFunction.body;
            if (body.length !== 1) {
                return false;
            }
            const onlyStatement = body[0];
            if (onlyStatement.type === 'ReturnStatement' &&
                onlyStatement.argument &&
                isIdentifier(onlyStatement.argument, firstParamName)) {
                return true;
            }
            return false;
        }
        function isInvalidSanitizerFunction(node) {
            var _a;
            let assignedFunction = (_a = getValueOfExpression(context, node, 'FunctionExpression')) !== null && _a !== void 0 ? _a : getValueOfExpression(context, node, 'ArrowFunctionExpression');
            if (!assignedFunction && node.type === 'Identifier' && parserServices.isRequiredParserServices(services)) {
                assignedFunction = resolveFromFunctionReference(context, node);
            }
            if (!!assignedFunction) {
                return isEmptySanitizerFunction(assignedFunction);
            }
            return false;
        }
        return {
            CallExpression: (node) => {
                const callExpression = node;
                if (isCallToFQN(context, callExpression, 'handlebars', 'compile')) {
                    checkSensitiveCall(context, callExpression, 1, 'noEscape', true, MESSAGE$4);
                }
                if (isCallToFQN(context, callExpression, 'marked', 'setOptions')) {
                    checkSensitiveCall(context, callExpression, 0, 'sanitize', false, MESSAGE$4);
                }
                const calleeModule = getModuleNameOfNode(context, callExpression.callee);
                if ((calleeModule === null || calleeModule === void 0 ? void 0 : calleeModule.value) === 'markdown-it') {
                    checkSensitiveCall(context, callExpression, 0, 'html', true, MESSAGE$4);
                }
            },
            NewExpression: (node) => {
                const newExpression = node;
                const { callee } = newExpression;
                if (callee.type !== 'MemberExpression') {
                    return;
                }
                const module = getModuleNameOfNode(context, callee.object);
                if ((module === null || module === void 0 ? void 0 : module.value) === 'kramed' && isIdentifier(callee.property, 'Renderer')) {
                    checkSensitiveCall(context, newExpression, 0, 'sanitize', false, MESSAGE$4);
                }
            },
            AssignmentExpression: (node) => {
                const assignmentExpression = node;
                const { left, right } = assignmentExpression;
                if (left.type !== 'MemberExpression') {
                    return;
                }
                const module = getModuleNameOfNode(context, left.object);
                if ((module === null || module === void 0 ? void 0 : module.value) !== 'mustache' || !isIdentifier(left.property, 'escape')) {
                    return;
                }
                if (isInvalidSanitizerFunction(right)) {
                    context.report({ node: left, message: MESSAGE$4 });
                }
            },
        };
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$2s = {
    meta: {
        messages: {
            safeResource: 'Make sure not using resource integrity feature is safe here.',
        },
    },
    create(context) {
        const services = context.parserServices;
        if (!parserServices.isRequiredParserServices(services)) {
            return {};
        }
        function shouldReport(assignedVariable) {
            let nbSrcAssignment = 0;
            let hasUnsafeSrcAssignment = false;
            let hasIntegrityAssignment = false;
            assignedVariable.references.forEach(ref => {
                const parentNode = ref.identifier.parent;
                if (!parentNode) {
                    return;
                }
                nbSrcAssignment += isSrcAssignment(parentNode) ? 1 : 0;
                hasUnsafeSrcAssignment = hasUnsafeSrcAssignment || isUnsafeSrcAssignment(parentNode);
                hasIntegrityAssignment = hasIntegrityAssignment || isIntegrityAssignment(parentNode);
            });
            return nbSrcAssignment === 1 && hasUnsafeSrcAssignment && !hasIntegrityAssignment;
        }
        function isIntegrityAssignment(memberExpression) {
            if (memberExpression.type !== 'MemberExpression') {
                return false;
            }
            return (memberExpression.property.type === 'Identifier' &&
                memberExpression.property.name === 'integrity');
        }
        function isSrcAssignment(memberExpression) {
            if (memberExpression.type !== 'MemberExpression') {
                return false;
            }
            if (memberExpression.property.type !== 'Identifier' ||
                memberExpression.property.name !== 'src') {
                return false;
            }
            const assignmentExpression = memberExpression.parent;
            if ((assignmentExpression === null || assignmentExpression === void 0 ? void 0 : assignmentExpression.type) !== 'AssignmentExpression') {
                return false;
            }
            return true;
        }
        function isUnsafeSrcAssignment(memberExpression) {
            if (!isSrcAssignment(memberExpression)) {
                return false;
            }
            const right = memberExpression.parent.right;
            if (right.type !== 'Literal') {
                return false;
            }
            return !!right.raw && (!!right.raw.match('^"http') || !!right.raw.match('^"//'));
        }
        return {
            'VariableDeclarator[init.type="CallExpression"]': (node) => {
                const variableDeclarator = node;
                const callExpression = variableDeclarator.init;
                const left = variableDeclarator.id;
                const { callee } = callExpression;
                if (left.type !== 'Identifier') {
                    return;
                }
                if (callee.type !== 'MemberExpression') {
                    return;
                }
                const typeName = getTypeAsString(left, services);
                if (!isIdentifier(callee.object, 'document') ||
                    !isIdentifier(callee.property, 'createElement') ||
                    typeName !== 'HTMLScriptElement') {
                    return;
                }
                const scope = context.getScope();
                const assignedVariable = scope.variables.find(v => v.name === left.name);
                if (!assignedVariable) {
                    return;
                }
                if (shouldReport(assignedVariable)) {
                    context.report({
                        node: variableDeclarator,
                        messageId: 'safeResource',
                    });
                }
            },
        };
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const MESSAGE$3 = 'Set this timeout to 0 if you want to disable it, otherwise use a value lower than 2147483648.';
const MAX_DELAY_VALUE = 2147483647;
const rule$2r = {
    create(context) {
        if (!Chai.isImported(context)) {
            return {};
        }
        const constructs = [];
        return {
            CallExpression: (node) => {
                if (Mocha.isTestConstruct(node)) {
                    constructs.push(node);
                    return;
                }
                if (constructs.length > 0) {
                    checkTimeoutDisabling(node, context);
                }
            },
            'CallExpression:exit': (node) => {
                if (Mocha.isTestConstruct(node)) {
                    constructs.pop();
                }
            },
        };
    },
};
function checkTimeoutDisabling(node, context) {
    if (isMethodCall(node) && node.arguments.length > 0) {
        const { callee: { object, property }, arguments: [value], } = node;
        if (isThisExpression(object) &&
            isIdentifier(property, 'timeout') &&
            isDisablingTimeout(value, context)) {
            context.report({
                message: MESSAGE$3,
                node: value,
            });
        }
    }
}
function isDisablingTimeout(timeout, context) {
    const usage = getUniqueWriteUsageOrNode(context, timeout);
    return isNumberLiteral(usage) && usage.value > MAX_DELAY_VALUE;
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const MESSAGE$2 = 'Make sure allowing browsers to perform DNS prefetching is safe here.';
const rule$2q = {
    meta: {
        schema: [
            {
                // internal parameter for rules having secondary locations
                enum: ['sonar-runtime'],
            },
        ],
    },
    create(context) {
        return {
            CallExpression: (node) => {
                const callExpression = node;
                const { callee } = callExpression;
                if (isCallToFQN(context, callExpression, 'helmet', 'dnsPrefetchControl')) {
                    checkSensitiveCall(context, callExpression, 0, 'allow', true, MESSAGE$2);
                }
                const calledModule = getModuleNameOfNode(context, callee);
                if ((calledModule === null || calledModule === void 0 ? void 0 : calledModule.value) === 'helmet') {
                    checkSensitiveCall(context, callExpression, 0, 'dnsPrefetchControl', false, MESSAGE$2);
                }
                if ((calledModule === null || calledModule === void 0 ? void 0 : calledModule.value) === 'dns-prefetch-control') {
                    checkSensitiveCall(context, callExpression, 0, 'allow', true, MESSAGE$2);
                }
            },
        };
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$2p = createRegExpRule(context => {
    let flags;
    return {
        onRegExpLiteralEnter: (node) => {
            flags = node.flags;
        },
        onCharacterClassEnter: (node) => {
            const duplicates = new Set();
            const characterClass = new SimplifiedRegexCharacterClass(flags);
            node.elements.forEach(element => {
                const intersections = new SimplifiedRegexCharacterClass(flags, element).findIntersections(characterClass);
                if (intersections.length > 0) {
                    intersections.forEach(intersection => duplicates.add(intersection));
                    duplicates.add(element);
                }
                characterClass.add(element);
            });
            if (duplicates.size > 0) {
                const [primary, ...secondaries] = duplicates;
                context.reportRegExpNode({
                    message: toEncodedMessage$1('Remove duplicates in this character class.', secondaries.map(snd => ({ loc: getRegexpLocation(context.node, snd, context) })), secondaries.map(_ => 'Additional duplicate')),
                    node: context.node,
                    regexpNode: primary,
                });
            }
        },
    };
}, {
    meta: {
        schema: [
            {
                // internal parameter for rules having secondary locations
                enum: ['sonar-runtime'],
            },
        ],
    },
});

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$2o = createRegExpRule(context => {
    return {
        onQuantifierEnter: (node) => {
            const { element } = node;
            if (matchEmptyString(element)) {
                context.reportRegExpNode({
                    message: `Rework this part of the regex to not match the empty string.`,
                    node: context.node,
                    regexpNode: element,
                });
            }
        },
    };
});
function matchEmptyString(node) {
    switch (node.type) {
        case 'Alternative':
            return node.elements.every(matchEmptyString);
        case 'Assertion':
            return true;
        case 'CapturingGroup':
        case 'Group':
        case 'Pattern':
            return node.alternatives.some(matchEmptyString);
        case 'Quantifier':
            return node.min === 0;
        default:
            return false;
    }
}

const aliases = [
    'AES128',
    'AES192',
    'AES256',
    'BF',
    'blowfish',
    'CAMELLIA128',
    'CAMELLIA192',
    'CAMELLIA256',
    'CAST',
    'DES',
    'DES-EDE',
    'DES-EDE3',
    'DES3',
    'DESX',
    'RC2',
    'RC2-40',
    'RC2-64',
    'RC2-128',
    'SEED',
];
const rule$2n = {
    meta: {
        messages: {
            useSecureMode: 'Use a secure mode and padding scheme.',
        },
    },
    create(context) {
        const patterns = [new RegExp('CBC', 'i'), new RegExp('ECB', 'i')];
        aliases.forEach(alias => patterns.push(new RegExp(`^${alias}$`, 'i')));
        return {
            CallExpression: (node) => {
                const callExpression = node;
                if (!isCallToFQN(context, callExpression, 'crypto', 'createCipheriv')) {
                    return;
                }
                const sensitiveArgument = callExpression.arguments[0];
                const sensitiveArgumentValue = getValueOfExpression(context, sensitiveArgument, 'Literal');
                if (!sensitiveArgumentValue) {
                    return;
                }
                const { value } = sensitiveArgumentValue;
                if (typeof value !== 'string') {
                    return;
                }
                if (patterns.some(pattern => pattern.test(value))) {
                    context.report({
                        messageId: 'useSecureMode',
                        node: sensitiveArgument,
                    });
                }
            },
        };
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const getEncryptionRuleModule = (clientSideMethods, serverSideMethods) => ({
    meta: {
        messages: {
            safeEncryption: 'Make sure that encrypting data is safe here.',
        },
    },
    create(context) {
        // for client side
        let usingCryptoInFile = false;
        return {
            Program() {
                // init flag for each file
                usingCryptoInFile = false;
            },
            MemberExpression(node) {
                // detect 'SubtleCrypto' object
                // which can be retrieved by 'crypto.subtle' or 'window.crypto.subtle'
                const { object, property } = node;
                if (isIdentifier(property, 'subtle') &&
                    (isIdentifier(object, 'crypto') || isMemberWithProperty$1(object, 'crypto'))) {
                    usingCryptoInFile = true;
                }
            },
            'CallExpression:exit'(node) {
                const { callee } = node;
                if (usingCryptoInFile) {
                    // e.g.: crypto.subtle.encrypt()
                    checkForClientSide(callee, context, clientSideMethods);
                }
                // e.g.
                // const crypto = require("crypto");
                // const cipher = crypto.createCipher(alg, key);
                checkForServerSide(callee, context, serverSideMethods);
            },
        };
    },
});
function checkForServerSide(callee, context, serverSideMethods) {
    let moduleName;
    if (callee.type === 'MemberExpression' &&
        isMemberWithProperty$1(callee, ...serverSideMethods) &&
        callee.object.type === 'Identifier') {
        moduleName = getModuleNameOfIdentifier(context, callee.object);
    }
    else if (isIdentifier(callee, ...serverSideMethods)) {
        moduleName = getModuleNameOfImportedIdentifier(context, callee);
    }
    if (moduleName && moduleName.value === 'crypto') {
        context.report({
            messageId: 'safeEncryption',
            node: callee,
        });
    }
}
function checkForClientSide(callee, context, clientSideMethods) {
    if (isIdentifier(callee, ...clientSideMethods) ||
        isMemberWithProperty$1(callee, ...clientSideMethods)) {
        context.report({
            messageId: 'safeEncryption',
            node: callee,
        });
    }
}
const clientSideEncryptMethods = ['encrypt', 'decrypt'];
const serverSideEncryptMethods = [
    'createCipher',
    'createCipheriv',
    'createDecipher',
    'createDecipheriv',
    'publicEncrypt',
    'publicDecrypt',
    'privateEncrypt',
    'privateDecrypt',
];
const rule$2m = getEncryptionRuleModule(clientSideEncryptMethods, serverSideEncryptMethods);

function isStringReplaceCall(call, services) {
    return (call.callee.type === 'MemberExpression' &&
        call.callee.property.type === 'Identifier' &&
        !call.callee.computed &&
        ['replace', 'replaceAll'].includes(call.callee.property.name) &&
        call.arguments.length > 1 &&
        isString$1(call.callee.object, services));
}
function extractReferences(node) {
    const references = [];
    if (isStringLiteral(node)) {
        const str = node.value;
        const reg = /\$(\d+)|\$\<([a-zA-Z][a-zA-Z0-9_]*)\>/g;
        let match;
        while ((match = reg.exec(str)) !== null) {
            const [raw, index, name] = match;
            const value = index || name;
            references.push({ raw, value });
        }
    }
    return references;
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$2l = {
    meta: {
        messages: {
            nonExistingGroup: 'Referencing non-existing group{{groups}}.',
        },
    },
    create(context) {
        const services = context.parserServices;
        if (!parserServices.isRequiredParserServices(services)) {
            return {};
        }
        return {
            CallExpression: (call) => {
                if (isStringReplaceCall(call, services)) {
                    const [pattern, substr] = call.arguments;
                    const regex = getParsedRegex(pattern, context);
                    if (regex !== null) {
                        const groups = extractGroups(regex);
                        const references = extractReferences(substr);
                        const invalidReferences = references.filter(ref => !isReferencingExistingGroup(ref, groups));
                        if (invalidReferences.length > 0) {
                            const groups = `${invalidReferences.length > 1 ? 's' : ''}: ${invalidReferences
                                .map(ref => ref.raw)
                                .join(', ')}`;
                            context.report({
                                node: substr,
                                messageId: 'nonExistingGroup',
                                data: {
                                    groups,
                                },
                            });
                        }
                    }
                }
            },
        };
    },
};
class CapturingGroups {
    constructor() {
        this.names = new Set();
        this.groups = 0;
    }
    add(name) {
        if (name !== null) {
            this.names.add(name);
        }
        this.groups++;
    }
    has(name) {
        return this.names.has(name);
    }
    count() {
        return this.groups;
    }
}
function extractGroups(regex) {
    const groups = new CapturingGroups();
    regexpp__namespace.visitRegExpAST(regex, {
        onCapturingGroupEnter: group => groups.add(group.name),
    });
    return groups;
}
function isReferencingExistingGroup(reference, groups) {
    if (!isNaN(Number(reference.value))) {
        const index = Number(reference.value);
        return index >= 1 && index <= groups.count();
    }
    else {
        const name = reference.value;
        return groups.has(name);
    }
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$2k = {
    meta: {
        schema: [
            { type: 'integer' },
            {
                // internal parameter for rules having secondary locations
                enum: ['sonar-runtime'],
            },
        ],
    },
    create(context) {
        const [max] = context.options;
        const statementLevel = [new ExpressionComplexity()];
        return {
            '*': (node) => {
                const tree = node;
                if (isConditionalLike(tree)) {
                    const expr = statementLevel[statementLevel.length - 1];
                    expr.incrementNestedExprLevel();
                    expr.addOperator(getOperatorToken(tree, context));
                }
                else if (isScopeLike(tree)) {
                    statementLevel.push(new ExpressionComplexity());
                }
            },
            '*:exit': (node) => {
                const tree = node;
                if (isConditionalLike(tree)) {
                    const expr = statementLevel[statementLevel.length - 1];
                    expr.decrementNestedExprLevel();
                    if (expr.isOnFirstExprLevel()) {
                        const operators = expr.getComplexityOperators();
                        if (operators.length > max) {
                            reportIssue(tree, operators, max, context);
                        }
                        expr.resetExpressionComplexityOperators();
                    }
                }
                else if (isScopeLike(tree)) {
                    statementLevel.pop();
                }
            },
        };
    },
};
class ExpressionComplexity {
    constructor() {
        this.nestedLevel = 0;
        this.operators = [];
    }
    addOperator(operator) {
        this.operators.push(operator);
    }
    incrementNestedExprLevel() {
        this.nestedLevel++;
    }
    decrementNestedExprLevel() {
        this.nestedLevel--;
    }
    isOnFirstExprLevel() {
        return this.nestedLevel === 0;
    }
    getComplexityOperators() {
        return this.operators;
    }
    resetExpressionComplexityOperators() {
        this.operators = [];
    }
}
function isScopeLike(node) {
    return (node.type === 'FunctionExpression' ||
        (node.type === 'FunctionDeclaration' && node.generator) ||
        node.type === 'ObjectExpression' ||
        node.type === 'CallExpression' ||
        node.type === 'JSXElement');
}
function isConditionalLike(node) {
    return node.type === 'ConditionalExpression' || node.type === 'LogicalExpression';
}
function getOperatorToken(node, context) {
    const sourceCode = context.getSourceCode();
    if (node.type === 'ConditionalExpression') {
        return sourceCode.getTokenAfter(node.test, token => token.type === 'Punctuator' && token.value === '?');
    }
    else {
        const expr = node;
        return sourceCode.getTokenAfter(expr.left, token => token.type === 'Punctuator' && token.value === expr.operator);
    }
}
function reportIssue(node, operators, max, context) {
    const complexity = operators.length;
    const message = `Reduce the number of conditional operators (${complexity}) used in the expression (maximum allowed ${max}).`;
    const secondaryLocationsHolder = operators;
    const secondaryMessages = Array(complexity).fill('+1');
    const cost = complexity - max;
    context.report({
        node: node,
        message: toEncodedMessage$1(message, secondaryLocationsHolder, secondaryMessages, cost),
    });
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
// https://jira.sonarsource.com/browse/RSPEC-1451
let cached;
const rule$2j = {
    meta: {
        messages: {
            fixHeader: 'Add or update the header of this file.',
        },
    },
    create(context) {
        updateCache(context.options);
        if (cached.failedToCompile) {
            // don't visit anything
            return {};
        }
        return {
            'Program:exit': function () {
                if (cached.isRegularExpression) {
                    checkRegularExpression(cached.searchPattern, context);
                }
                else {
                    checkPlainText(cached.expectedLines, context);
                }
            },
        };
    },
};
function checkPlainText(expectedLines, context) {
    let matches = false;
    const lines = context.getSourceCode().lines;
    if (expectedLines.length <= lines.length) {
        matches = true;
        let i = 0;
        for (const expectedLine of expectedLines) {
            const line = lines[i];
            i++;
            if (line !== expectedLine) {
                matches = false;
                break;
            }
        }
    }
    if (!matches) {
        addFileIssue(context);
    }
}
function checkRegularExpression(searchPattern, context) {
    const fileContent = context.getSourceCode().getText();
    const match = searchPattern.exec(fileContent);
    if (!match || match.index !== 0) {
        addFileIssue(context);
    }
}
function addFileIssue(context) {
    context.report({
        messageId: 'fixHeader',
        loc: { line: 0, column: 0 },
    });
}
function updateCache(options) {
    const [{ headerFormat, isRegularExpression }] = options;
    if (!cached ||
        cached.headerFormat !== headerFormat ||
        cached.isRegularExpression !== isRegularExpression) {
        cached = {
            headerFormat,
            isRegularExpression,
        };
        if (isRegularExpression) {
            try {
                cached.searchPattern = new RegExp(headerFormat, 's');
                cached.failedToCompile = false;
            }
            catch (e) {
                console.error(`Failed to compile regular expression for rule S1451 (${e.message})`);
                cached.failedToCompile = true;
            }
        }
        else {
            cached.expectedLines = headerFormat.split(/(?:\r)?\n|\r/);
        }
    }
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$2i = {
    meta: {
        messages: {
            renameFile: 'Rename this file to "{{exported}}"',
        },
    },
    create(context) {
        let isOnlyExport = true;
        let nameOfExported = undefined;
        return {
            ExportDefaultDeclaration: (node) => {
                const declaration = node.declaration;
                if (declaration.type === 'Identifier') {
                    const variable = getVariableFromName(context, declaration.name);
                    if (variable && variable.defs.length === 1) {
                        const def = variable.defs[0];
                        if (def.type === 'ClassName' || def.type === 'FunctionName' || isConst(def)) {
                            nameOfExported = declaration.name;
                        }
                    }
                }
                else if (declaration.type === 'ClassDeclaration' ||
                    declaration.type === 'FunctionDeclaration') {
                    if (declaration.id) {
                        nameOfExported = declaration.id.name;
                    }
                }
            },
            'ExportAllDeclaration, ExportNamedDeclaration': () => {
                isOnlyExport = false;
            },
            'Program:exit': () => {
                if (isOnlyExport && nameOfExported) {
                    const fileName = path__default["default"].parse(context.getFilename()).name;
                    if ('index' !== fileName &&
                        !sameName(nameOfExported, fileName) &&
                        !sameName(nameOfExported, sliceOffPostfix(fileName))) {
                        context.report({
                            messageId: 'renameFile',
                            data: {
                                exported: nameOfExported,
                            },
                            loc: { line: 0, column: 0 },
                        });
                    }
                }
            },
        };
    },
};
function sameName(nameOfExported, fileName) {
    const normalizedFileName = fileName.replace(/_/g, '').replace(/-/g, '').replace(/\./g, '');
    const normalizedNameOfExported = nameOfExported.replace(/_/g, '').replace(/-/g, '');
    return normalizedNameOfExported.toLowerCase() === normalizedFileName.toLowerCase();
}
function isConst(def) {
    return def.type === 'Variable' && def.parent && def.parent.kind === 'const';
}
function sliceOffPostfix(fileName) {
    return fileName.slice(0, fileName.lastIndexOf('.'));
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const chmodLikeFunction = ['chmod', 'chmodSync', 'fchmod', 'fchmodSync', 'lchmod', 'lchmodSync'];
const rule$2h = {
    meta: {
        messages: {
            safePermission: 'Make sure this permission is safe.',
        },
    },
    create(context) {
        function isChmodLikeFunction(node) {
            const { callee } = node;
            if (callee.type !== 'MemberExpression') {
                return false;
            }
            // to support fs promises we are only checking the name of the function
            return isIdentifier(callee.property, ...chmodLikeFunction);
        }
        function modeFromLiteral(modeExpr) {
            const modeValue = modeExpr.value;
            let mode = null;
            if (typeof modeValue === 'string') {
                mode = Number.parseInt(modeValue, 8);
            }
            else if (typeof modeValue === 'number') {
                const raw = modeExpr.raw;
                // ts parser interprets number starting with 0 as decimal, we need to parse it as octal value
                if (raw && raw.startsWith('0') && !raw.startsWith('0o')) {
                    mode = Number.parseInt(raw, 8);
                }
                else {
                    mode = modeValue;
                }
            }
            return mode;
        }
        // fs.constants have these value only when running on linux, we need to hardcode them to be able to test on win
        const FS_CONST = {
            S_IRWXU: 0o700,
            S_IRUSR: 0o400,
            S_IWUSR: 0o200,
            S_IXUSR: 0o100,
            S_IRWXG: 0o70,
            S_IRGRP: 0o40,
            S_IWGRP: 0o20,
            S_IXGRP: 0o10,
            S_IRWXO: 0o7,
            S_IROTH: 0o4,
            S_IWOTH: 0o2,
            S_IXOTH: 0o1,
        };
        function modeFromMemberExpression(modeExpr) {
            const { object, property } = modeExpr;
            if (isMemberExpression(object, 'fs', 'constants') && property.type === 'Identifier') {
                return FS_CONST[property.name];
            }
            return null;
        }
        function modeFromExpression(expr, visited) {
            if (!expr) {
                return null;
            }
            if (expr.type === 'MemberExpression') {
                return modeFromMemberExpression(expr);
            }
            else if (expr.type === 'Literal') {
                return modeFromLiteral(expr);
            }
            else if (expr.type === 'Identifier') {
                const usage = getUniqueWriteUsage(context, expr.name);
                if (usage && !visited.has(usage)) {
                    visited.add(usage);
                    return modeFromExpression(usage, visited);
                }
            }
            else if (expr.type === 'BinaryExpression') {
                const { left, operator, right } = expr;
                if (operator === '|') {
                    const leftValue = modeFromExpression(left, visited);
                    const rightValue = modeFromExpression(right, visited);
                    if (leftValue && rightValue) {
                        return leftValue | rightValue;
                    }
                }
            }
            return null;
        }
        function checkModeArgument(node, moduloTest) {
            const visited = new Set();
            const mode = modeFromExpression(node, visited);
            if (mode !== null && !isNaN(mode) && mode % 8 !== moduloTest) {
                context.report({
                    node,
                    messageId: 'safePermission',
                });
            }
        }
        return {
            CallExpression: (node) => {
                const callExpression = node;
                if (isChmodLikeFunction(callExpression)) {
                    checkModeArgument(callExpression.arguments[0], 0);
                    checkModeArgument(callExpression.arguments[1], 0);
                }
                else if (isCallToFQN(context, callExpression, 'process', 'umask')) {
                    checkModeArgument(callExpression.arguments[0], 7);
                }
            },
        };
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
// https://jira.sonarsource.com/browse/RSPEC-1135
const todoPattern = 'todo';
const letterPattern = /[\p{Letter}]/u;
const rule$2g = {
    meta: {
        messages: {
            completeTODO: 'Complete the task associated to this "TODO" comment.',
        },
    },
    create(context) {
        return {
            'Program:exit': () => {
                reportPatternInComment(context, todoPattern, 'completeTODO');
            },
        };
    },
};
function reportPatternInComment(context, pattern, messageId) {
    const sourceCode = context.getSourceCode();
    sourceCode.getAllComments().forEach(comment => {
        const rawText = comment.value.toLowerCase();
        if (rawText.includes(pattern)) {
            const lines = rawText.split(/\r\n?|\n/);
            for (let i = 0; i < lines.length; i++) {
                const index = lines[i].indexOf(pattern);
                if (index >= 0 && !isLetterAround(lines[i], index, pattern)) {
                    context.report({
                        messageId,
                        loc: getPatternPosition(i, index, comment, pattern),
                    });
                }
            }
        }
    });
}
function isLetterAround(line, start, pattern) {
    const end = start + pattern.length;
    const pre = start > 0 && letterPattern.test(line.charAt(start - 1));
    const post = end < line.length - 1 && letterPattern.test(line.charAt(end));
    return pre || post;
}
function getPatternPosition(lineIdx, index, comment, pattern) {
    const line = comment.loc.start.line + lineIdx;
    const columnStart = lineIdx === 0 ? comment.loc.start.column + 2 : 0;
    const patternStart = columnStart + index;
    return {
        start: { line, column: patternStart },
        end: { line, column: patternStart + pattern.length },
    };
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const fixmePattern = 'fixme';
const rule$2f = {
    meta: {
        messages: {
            fixme: 'Take the required action to fix the issue indicated by this comment.',
        },
    },
    create(context) {
        return {
            'Program:exit': () => {
                reportPatternInComment(context, fixmePattern, 'fixme');
            },
        };
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
// https://jira.sonarsource.com/browse/RSPEC-1535
const rule$2e = {
    meta: {
        messages: {
            restrictLoop: 'Restrict what this loop acts on by testing each property.',
        },
    },
    create(context) {
        function isAttrCopy(statement) {
            if (statement.type !== 'ExpressionStatement') {
                return false;
            }
            const expression = statement.expression;
            return (expression.type === 'AssignmentExpression' &&
                expression.left.type === 'MemberExpression' &&
                expression.left.computed);
        }
        return {
            ForInStatement(node) {
                const forInStatement = node;
                const body = forInStatement.body;
                if (body.type === 'BlockStatement') {
                    if (body.body.length === 0) {
                        return;
                    }
                    const firstStatement = body.body[0];
                    if (firstStatement.type === 'IfStatement' || isAttrCopy(firstStatement)) {
                        return;
                    }
                }
                if (body.type === 'EmptyStatement' || body.type === 'IfStatement' || isAttrCopy(body)) {
                    return;
                }
                context.report({
                    node: forInStatement,
                    messageId: 'restrictLoop',
                });
            },
        };
    },
};

const rule$2d = {
    meta: {
        schema: [
            {
                // internal parameter for rules having secondary locations
                enum: ['sonar-runtime'],
            },
        ],
    },
    create(context) {
        return {
            ForStatement: (node) => {
                const forStatement = node;
                const test = forStatement.test;
                const loopIncrement = ForLoopIncrement.findInLoopUpdate(forStatement);
                if (test == null || loopIncrement == null || forStatement.update == null) {
                    return;
                }
                const wrongDirection = getWrongDirection(test, loopIncrement);
                if (wrongDirection !== 0 && wrongDirection === loopIncrement.direction) {
                    const movement = wrongDirection > 0 ? 'incremented' : 'decremented';
                    const message = toEncodedMessage$1(`"${loopIncrement.identifier.name}" is ${movement} and will never reach its stop condition.`, [test]);
                    context.report({
                        message,
                        node: forStatement.update,
                    });
                }
            },
        };
    },
};
class ForLoopIncrement {
    constructor(increment, identifier, direction) {
        this.increment = increment;
        this.identifier = identifier;
        this.direction = direction;
    }
    static findInLoopUpdate(forStatement) {
        let result = null;
        const expression = forStatement.update;
        if (!expression) {
            return null;
        }
        if (expression.type === 'UpdateExpression') {
            const updateExpression = expression;
            const direction = updateExpression.operator === '++' ? 1 : -1;
            result = ForLoopIncrement.increment(updateExpression, updateExpression.argument, direction);
        }
        if (expression.type === 'AssignmentExpression') {
            const assignmentExpression = expression;
            if (assignmentExpression.operator === '+=' &&
                assignmentExpression.left.type === 'Identifier') {
                result = ForLoopIncrement.increment(expression, assignmentExpression.left, directionFromValue(assignmentExpression.right));
            }
            if (assignmentExpression.operator === '-=' &&
                assignmentExpression.left.type === 'Identifier') {
                result = ForLoopIncrement.increment(expression, assignmentExpression.left, -directionFromValue(assignmentExpression.right));
            }
            if (assignmentExpression.operator === '=') {
                result = ForLoopIncrement.assignmentIncrement(assignmentExpression);
            }
        }
        return result;
    }
    static increment(increment, expression, direction) {
        if (expression.type === 'Identifier') {
            return new ForLoopIncrement(increment, expression, direction);
        }
        return null;
    }
    static assignmentIncrement(assignmentExpression) {
        const lhs = assignmentExpression.left;
        const rhs = assignmentExpression.right;
        if (lhs.type === 'Identifier' &&
            rhs.type === 'BinaryExpression' &&
            (rhs.operator === '+' || rhs.operator === '-')) {
            let incrementDirection = directionFromValue(rhs.right);
            if (incrementDirection !== null && isSameIdentifier(rhs.left, lhs)) {
                incrementDirection = rhs.operator === '-' ? -incrementDirection : incrementDirection;
                return ForLoopIncrement.increment(assignmentExpression, lhs, incrementDirection);
            }
        }
        return null;
    }
}
function directionFromValue(expression) {
    if (expression.type === 'Literal') {
        const value = Number(expression.raw);
        if (isNaN(value) || value === 0) {
            return 0;
        }
        return value > 0 ? 1 : -1;
    }
    if (expression.type === 'UnaryExpression') {
        const unaryExpression = expression;
        if (unaryExpression.operator === '+') {
            return directionFromValue(unaryExpression.argument);
        }
        if (unaryExpression.operator === '-') {
            return -directionFromValue(unaryExpression.argument);
        }
    }
    return 0;
}
function getWrongDirection(condition, forLoopIncrement) {
    if (condition.type !== 'BinaryExpression') {
        return 0;
    }
    if (isSameIdentifier(condition.left, forLoopIncrement.identifier)) {
        if (condition.operator === '<' || condition.operator === '<=') {
            return -1;
        }
        if (condition.operator === '>' || condition.operator === '>=') {
            return +1;
        }
    }
    else if (isSameIdentifier(condition.right, forLoopIncrement.identifier)) {
        if (condition.operator === '<' || condition.operator === '<=') {
            return +1;
        }
        if (condition.operator === '>' || condition.operator === '>=') {
            return -1;
        }
    }
    return 0;
}
function isSameIdentifier(expression, identifier) {
    return expression.type === 'Identifier' && expression.name === identifier.name;
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const HELMET$5 = 'helmet';
const HELMET_CSP$1 = 'helmet-csp';
const DIRECTIVES$1 = 'directives';
const NONE = "'none'";
const CONTENT_SECURITY_POLICY$1 = 'contentSecurityPolicy';
const FRAME_ANCESTORS_CAMEL = 'frameAncestors';
const FRAME_ANCESTORS_HYPHEN = 'frame-ancestors';
const rule$2c = Express.SensitiveMiddlewarePropertyRule(findDirectivesWithSensitiveFrameAncestorsPropertyFromHelmet, `Make sure disabling content security policy frame-ancestors directive is safe here.`);
function findDirectivesWithSensitiveFrameAncestorsPropertyFromHelmet(context, node) {
    const { arguments: args } = node;
    if (isValidHelmetModuleCall$1(context, node) && args.length === 1) {
        const [options] = args;
        const maybeDirectives = getObjectExpressionProperty(options, DIRECTIVES$1);
        if (maybeDirectives) {
            const maybeFrameAncestors = getFrameAncestorsProperty(maybeDirectives);
            if (!maybeFrameAncestors) {
                return [maybeDirectives];
            }
            if (isSetNoneFrameAncestorsProperty(maybeFrameAncestors)) {
                return [maybeFrameAncestors];
            }
        }
    }
    return [];
}
function isValidHelmetModuleCall$1(context, callExpr) {
    var _a, _b;
    const { callee } = callExpr;
    /* csp(options) */
    if (callee.type === 'Identifier' && ((_a = getModuleNameOfNode(context, callee)) === null || _a === void 0 ? void 0 : _a.value) === HELMET_CSP$1) {
        return true;
    }
    /* helmet.contentSecurityPolicy(options) */
    if (callee.type === 'MemberExpression' &&
        ((_b = getModuleNameOfNode(context, callee.object)) === null || _b === void 0 ? void 0 : _b.value) === HELMET$5 &&
        callee.property.type === 'Identifier' &&
        callee.property.name === CONTENT_SECURITY_POLICY$1) {
        return true;
    }
    return false;
}
function isSetNoneFrameAncestorsProperty(frameAncestors) {
    const { value } = frameAncestors;
    return (value.type === 'ArrayExpression' &&
        Boolean(value.elements.find(v => (v === null || v === void 0 ? void 0 : v.type) === 'Literal' && typeof v.value === 'string' && v.value === NONE)));
}
function getFrameAncestorsProperty(directives) {
    const propertyKeys = [FRAME_ANCESTORS_CAMEL, FRAME_ANCESTORS_HYPHEN];
    for (const propertyKey of propertyKeys) {
        const maybeProperty = getObjectExpressionProperty(directives.value, propertyKey);
        if (maybeProperty) {
            return maybeProperty;
        }
    }
    return undefined;
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const message$4 = 'Make sure this function is not called after the loop completes.';
const loopLike = 'WhileStatement,DoWhileStatement,ForStatement,ForOfStatement,ForInStatement';
const functionLike = 'FunctionDeclaration,FunctionExpression,ArrowFunctionExpression';
const allowedCallbacks = [
    'replace',
    'forEach',
    'filter',
    'map',
    'find',
    'findIndex',
    'every',
    'some',
    'reduce',
    'reduceRight',
    'sort',
    'each',
];
const rule$2b = {
    meta: {
        schema: [
            {
                // internal parameter for rules having secondary locations
                enum: ['sonar-runtime'],
            },
        ],
    },
    create(context) {
        function getLocalEnclosingLoop(node) {
            return findFirstMatchingAncestor(node, n => loopLike.includes(n.type));
        }
        return {
            [functionLike]: (node) => {
                const loopNode = getLocalEnclosingLoop(node);
                if (loopNode) {
                    if (!isIIEF(node, context) &&
                        !isAllowedCallbacks(context) &&
                        context.getScope().through.some(ref => !isSafe(ref, loopNode))) {
                        context.report({
                            message: toEncodedMessage$1(message$4, [getMainLoopToken(loopNode, context)]),
                            loc: locations.getMainFunctionTokenLocation(node, getParent(context), context),
                        });
                    }
                }
            },
        };
    },
};
function isIIEF(node, context) {
    const parent = getParent(context);
    return (parent &&
        ((parent.type === 'CallExpression' && parent.callee === node) ||
            (parent.type === 'MemberExpression' && parent.object === node)));
}
function isAllowedCallbacks(context) {
    const parent = getParent(context);
    if (parent && parent.type === 'CallExpression') {
        const callee = parent.callee;
        if (callee.type === 'MemberExpression') {
            return (callee.property.type === 'Identifier' && allowedCallbacks.includes(callee.property.name));
        }
    }
    return false;
}
function isSafe(ref, loopNode) {
    const variable = ref.resolved;
    if (variable) {
        const definition = variable.defs[0];
        const declaration = definition && definition.parent;
        const kind = declaration && declaration.type === 'VariableDeclaration' ? declaration.kind : '';
        if (kind !== 'let' && kind !== 'const') {
            return hasConstValue(variable, loopNode);
        }
    }
    return true;
}
function hasConstValue(variable, loopNode) {
    for (const ref of variable.references) {
        if (ref.isWrite()) {
            //Check if write is in the scope of the loop
            if (ref.from.type === 'block' && ref.from.block === loopNode.body) {
                return false;
            }
            const refRange = ref.identifier.range;
            const range = getLoopTestRange(loopNode);
            //Check if value change in the header of the loop
            if (refRange && range && refRange[0] >= range[0] && refRange[1] <= range[1]) {
                return false;
            }
        }
    }
    return true;
}
function getLoopTestRange(loopNode) {
    const bodyRange = loopNode.body.range;
    if (bodyRange) {
        switch (loopNode.type) {
            case 'ForStatement':
                if (loopNode.test && loopNode.test.range) {
                    return [loopNode.test.range[0], bodyRange[0]];
                }
                break;
            case 'WhileStatement':
            case 'DoWhileStatement':
                return loopNode.test.range;
            case 'ForOfStatement':
            case 'ForInStatement':
                const leftRange = loopNode.range;
                if (leftRange) {
                    return [leftRange[0], bodyRange[0]];
                }
        }
    }
}
function getMainLoopToken(loop, context) {
    const sourceCode = context.getSourceCode();
    let token;
    switch (loop.type) {
        case 'WhileStatement':
        case 'DoWhileStatement':
            token = sourceCode.getTokenBefore(loop.test, t => t.type === 'Keyword' && t.value === 'while');
            break;
        case 'ForStatement':
        case 'ForOfStatement':
        default:
            token = sourceCode.getFirstToken(loop, t => t.type === 'Keyword' && t.value === 'for');
    }
    return token;
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
// https://jira.sonarsource.com/browse/RSPEC-100
const rule$2a = {
    meta: {
        messages: {
            renameFunction: "Rename this '{{function}}' function to match the regular expression '{{format}}'.",
        },
    },
    create(context) {
        return {
            Property: (node) => {
                const prop = node;
                if (isFunctionExpression(prop.value)) {
                    checkName(prop.key);
                }
            },
            VariableDeclarator: (node) => {
                const variable = node;
                if (isFunctionExpression(variable.init)) {
                    checkName(variable.id);
                }
            },
            FunctionDeclaration: (node) => checkName(node.id),
            MethodDefinition: (node) => {
                const key = node.key;
                checkName(key);
            },
        };
        function checkName(id) {
            const [{ format }] = context.options;
            if (id && id.type === 'Identifier' && !id.name.match(format)) {
                context.report({
                    messageId: 'renameFunction',
                    data: {
                        function: id.name,
                        format,
                    },
                    node: id,
                });
            }
        }
    },
};
function isFunctionExpression(node) {
    return node && (node.type === 'FunctionExpression' || node.type === 'ArrowFunctionExpression');
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
class FunctionScope {
    constructor() {
        this.returnStatements = [];
    }
    getReturnStatements() {
        return this.returnStatements.slice();
    }
    addReturnStatement(node) {
        this.returnStatements.push(node);
    }
}
const rule$29 = {
    meta: {
        schema: [
            {
                // internal parameter for rules having secondary locations
                enum: ['sonar-runtime'],
            },
        ],
    },
    create(context) {
        let scopes = [];
        const services = context.parserServices;
        if (!parserServices.isRequiredParserServices(services)) {
            return {};
        }
        const checker = services.program.getTypeChecker();
        function onFunctionExit(node) {
            const returnStatements = scopes.pop().getReturnStatements();
            if (returnStatements.every(retStmt => { var _a; return ((_a = retStmt.argument) === null || _a === void 0 ? void 0 : _a.type) === 'ThisExpression'; })) {
                return;
            }
            const signature = checker.getSignatureFromDeclaration(services.esTreeNodeToTSNodeMap.get(node));
            if (signature && hasMultipleReturnTypes(signature, checker)) {
                const stmts = returnStatements.filter(retStmt => !isNullLike$1(getTypeFromTreeNode$1(retStmt.argument, services)));
                const stmtsTypes = stmts.map(retStmt => getTypeFromTreeNode$1(retStmt.argument, services));
                if (stmtsTypes.every(isAny$2)) {
                    return;
                }
                context.report({
                    message: toEncodedMessage$1('Refactor this function to always return the same type.', stmts, stmtsTypes.map(stmtType => `Returns ${prettyPrint(stmtType, checker)}`)),
                    loc: locations.getMainFunctionTokenLocation(node, getParent(context), context),
                });
            }
        }
        return {
            ReturnStatement: (node) => {
                const retStmt = node;
                if (scopes.length > 0 && retStmt.argument) {
                    scopes[scopes.length - 1].addReturnStatement(retStmt);
                }
            },
            ':function': () => {
                scopes.push(new FunctionScope());
            },
            ':function:exit': onFunctionExit,
            'Program:exit': () => {
                scopes = [];
            },
        };
    },
};
function hasMultipleReturnTypes(signature, checker) {
    const returnType = checker.getBaseTypeOfLiteralType(checker.getReturnTypeOfSignature(signature));
    return isUnion$1(returnType, checker) && !hasReturnTypeJSDoc(signature);
}
function isUnion$1(type, checker) {
    const distinct = (value, index, self) => self.indexOf(value) === index;
    const stringify = (tp) => prettyPrint(tp, checker);
    const isNotNullLike = (tp) => !isNullLike$1(tp);
    return (type.isUnion() && type.types.filter(isNotNullLike).map(stringify).filter(distinct).length > 1);
}
function hasReturnTypeJSDoc(signature) {
    return signature.getJsDocTags().some(tag => ['return', 'returns'].includes(tag.name));
}
function prettyPrint(type, checker) {
    const distinct = (value, index, self) => self.indexOf(value) === index;
    if (type.symbol && (type.symbol.flags & ts__namespace.SymbolFlags.ObjectLiteral) !== 0) {
        return 'object';
    }
    if (type.isUnionOrIntersection()) {
        const delimiter = type.isUnion() ? ' | ' : ' & ';
        return type.types
            .map(tp => prettyPrint(tp, checker))
            .filter(distinct)
            .join(delimiter);
    }
    const typeNode = checker.typeToTypeNode(type, undefined, undefined);
    if (typeNode !== undefined) {
        if (ts__namespace.isFunctionTypeNode(typeNode)) {
            return 'function';
        }
        if (ts__namespace.isArrayTypeNode(typeNode)) {
            return arrayTypeToString(typeNode, checker);
        }
    }
    return checker.typeToString(checker.getBaseTypeOfLiteralType(type));
}
function arrayTypeToString(type, checker) {
    let elementType = prettyPrint(checker.getTypeFromTypeNode(type.elementType), checker);
    // TypeScript seems to fail resolving the element type of arrays. When this happens, we
    // manually resolve it for straightforward cases.
    if (elementType === 'any' && type.elementType.kind !== ts__namespace.SyntaxKind.AnyKeyword) {
        switch (type.elementType.kind) {
            case ts__namespace.SyntaxKind.NumberKeyword:
                elementType = 'number';
                break;
            case ts__namespace.SyntaxKind.StringKeyword:
                elementType = 'string';
                break;
            case ts__namespace.SyntaxKind.BooleanKeyword:
                elementType = 'boolean';
                break;
            case ts__namespace.SyntaxKind.TypeLiteral:
                elementType = 'object';
                break;
        }
    }
    return `${elementType}[]`;
}
function isNullLike$1(type) {
    return ((type.flags & ts__namespace.TypeFlags.Null) !== 0 ||
        (type.flags & ts__namespace.TypeFlags.Void) !== 0 ||
        (type.flags & ts__namespace.TypeFlags.Undefined) !== 0);
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
// https://jira.sonarsource.com/browse/RSPEC-1527
const futureReservedWords = [
    'implements',
    'interface',
    'package',
    'private',
    'protected',
    'public',
    'enum',
    'class',
    'const',
    'export',
    'extends',
    'import',
    'super',
    'let',
    'static',
    'yield',
    'await',
];
const rule$28 = {
    meta: {
        messages: {
            renameReserved: 'Rename "{{reserved}}" identifier to prevent potential conflicts with future evolutions of the JavaScript language.',
        },
    },
    create(context) {
        function checkVariable(variable) {
            if (variable.defs.length > 0) {
                const def = variable.defs[0].name;
                context.report({
                    node: def,
                    messageId: 'renameReserved',
                    data: {
                        reserved: variable.name,
                    },
                });
            }
        }
        function checkVariablesByScope(scope) {
            scope.variables.filter(v => futureReservedWords.includes(v.name)).forEach(checkVariable);
            scope.childScopes.forEach(childScope => {
                checkVariablesByScope(childScope);
            });
        }
        return {
            'Program:exit': () => {
                checkVariablesByScope(context.getScope());
            },
        };
    },
};

const rule$27 = {
    meta: {
        messages: {
            addYield: 'Add a "yield" statement to this generator.',
        },
    },
    create(context) {
        const yieldStack = [];
        function enterFunction() {
            yieldStack.push(0);
        }
        function exitFunction(node) {
            const functionNode = node;
            const countYield = yieldStack.pop();
            if (countYield === 0 && functionNode.body.body.length > 0) {
                context.report({
                    messageId: 'addYield',
                    loc: locations.getMainFunctionTokenLocation(functionNode, getParent(context), context),
                });
            }
        }
        return {
            ':function[generator=true]': enterFunction,
            ':function[generator=true]:exit': exitFunction,
            YieldExpression() {
                if (yieldStack.length > 0) {
                    yieldStack[yieldStack.length - 1] += 1;
                }
            },
        };
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const message$3 = 'Make sure this weak hash algorithm is not used in a sensitive context here.';
const CRYPTO_UNSECURE_HASH_ALGORITHMS = new Set([
    'md2',
    'md4',
    'md5',
    'md6',
    'haval128',
    'hmacmd5',
    'dsa',
    'ripemd',
    'ripemd128',
    'ripemd160',
    'hmacripemd160',
    'sha1',
]);
const SUBTLE_UNSECURE_HASH_ALGORITHMS = new Set(['sha-1']);
const rule$26 = {
    create(context) {
        function checkNodejsCrypto(node) {
            // crypto#createHash
            const { callee, arguments: args } = node;
            const { module, method } = getModuleAndCalledMethod(callee, context);
            if ((module === null || module === void 0 ? void 0 : module.value) === 'crypto' && isIdentifier(method, 'createHash')) {
                checkUnsecureAlgorithm(method, args[0], CRYPTO_UNSECURE_HASH_ALGORITHMS);
            }
        }
        function checkSubtleCrypto(node) {
            // crypto.subtle#digest
            const { callee, arguments: args } = node;
            if (callee.type === 'MemberExpression' && isIdentifier(callee.property, 'digest')) {
                const { object, property: method } = callee;
                if (object.type === 'MemberExpression' &&
                    isIdentifier(object.object, 'crypto') &&
                    isIdentifier(object.property, 'subtle')) {
                    checkUnsecureAlgorithm(method, args[0], SUBTLE_UNSECURE_HASH_ALGORITHMS);
                }
            }
        }
        function checkUnsecureAlgorithm(method, hash, unsecureAlgorithms) {
            const hashAlgorithm = getUniqueWriteUsageOrNode(context, hash);
            if (isStringLiteral(hashAlgorithm) &&
                unsecureAlgorithms.has(hashAlgorithm.value.toLocaleLowerCase())) {
                context.report({
                    message: message$3,
                    node: method,
                });
            }
        }
        return {
            'CallExpression[arguments.length > 0]': (node) => {
                const callExpr = node;
                checkNodejsCrypto(callExpr);
                checkSubtleCrypto(callExpr);
            },
        };
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const SERVE_STATIC = 'serve-static';
const rule$25 = {
    meta: {
        messages: {
            safeHiddenFile: 'Make sure serving hidden files is safe here.',
        },
    },
    create(context) {
        return {
            CallExpression(node) {
                const { callee, arguments: args } = node;
                if (callee.type !== 'Identifier') {
                    return;
                }
                // serveStatic(...)
                const module = getModuleNameOfIdentifier(context, callee);
                if ((module === null || module === void 0 ? void 0 : module.value) === SERVE_STATIC && args.length > 1) {
                    let options = args[1];
                    if (options.type === 'Identifier') {
                        options = getUniqueWriteUsage(context, options.name);
                    }
                    const dotfilesProperty = getObjectExpressionProperty(options, 'dotfiles');
                    if ((dotfilesProperty === null || dotfilesProperty === void 0 ? void 0 : dotfilesProperty.value.type) === 'Literal' &&
                        dotfilesProperty.value.value === 'allow') {
                        context.report({ node: dotfilesProperty, messageId: 'safeHiddenFile' });
                    }
                }
            },
        };
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$24 = {
    meta: {
        schema: [
            {
                // internal parameter for rules having secondary locations
                enum: ['sonar-runtime'],
            },
        ],
    },
    create(context) {
        const services = context.parserServices;
        if (!parserServices.isRequiredParserServices(services)) {
            return {};
        }
        function isPrimitive(node) {
            const type = getTypeFromTreeNode$1(node, services);
            return ((type.flags & ts__namespace.TypeFlags.StringLike) !== 0 ||
                (type.flags & ts__namespace.TypeFlags.NumberLike) !== 0 ||
                (type.flags & ts__namespace.TypeFlags.BooleanLike) !== 0 ||
                (type.flags & ts__namespace.TypeFlags.Null) !== 0 ||
                (type.flags & ts__namespace.TypeFlags.Undefined) !== 0);
        }
        return {
            'BinaryExpression[operator="in"]': (node) => {
                const { left, right, operator } = node;
                if (isPrimitive(right)) {
                    const opToken = context
                        .getSourceCode()
                        .getTokensBetween(left, right)
                        .find(token => token.type === 'Keyword' && token.value === operator);
                    context.report({
                        message: toEncodedMessage$1('TypeError can be thrown as this operand might have primitive type.', [opToken]),
                        node: right,
                    });
                }
            },
        };
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$23 = {
    meta: {
        schema: [
            {
                // internal parameter for rules having secondary locations
                enum: ['sonar-runtime'],
            },
        ],
    },
    create(context) {
        const usedInNew = new Map();
        const usedInCall = new Map();
        const hasIssue = [];
        return {
            NewExpression: (node) => {
                checkExpression(node, usedInNew, usedInCall, hasIssue, 'out', context);
            },
            CallExpression: (node) => {
                checkExpression(node, usedInCall, usedInNew, hasIssue, '', context);
            },
        };
    },
};
function checkExpression(callExpression, thisTypeUsageMap, otherTypeUsageMap, hasIssue, tail, context) {
    const variable = getVariable(callExpression, context);
    if (variable && variable.defs.length !== 0) {
        const otherTypeUsage = otherTypeUsageMap.get(variable);
        if (otherTypeUsage && otherTypeUsage.loc && !hasIssue.includes(variable)) {
            const message = `Correct the use of this function; ` +
                `on line ${otherTypeUsage.loc.start.line} it was called with${tail} "new".`;
            context.report({
                node: callExpression.callee,
                message: toEncodedMessage$1(message, [otherTypeUsage.callee]),
            });
            hasIssue.push(variable);
        }
        else {
            thisTypeUsageMap.set(variable, callExpression);
        }
    }
}
function getVariable(node, context) {
    if (node.callee.type === 'Identifier') {
        return getVariableFromName(context, node.callee.name);
    }
    return undefined;
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$22 = {
    meta: {
        messages: {
            considerIncludes: "This check ignores index 0; consider using 'includes' method to make this check safe and explicit.",
        },
    },
    create(context) {
        const services = context.parserServices;
        if (!parserServices.isRequiredParserServices(services)) {
            return {};
        }
        return {
            BinaryExpression(node) {
                const expression = node;
                if (expression.operator === '>' &&
                    isZero(expression.right) &&
                    isArrayIndexOfCall(expression.left, services)) {
                    context.report({ node, messageId: 'considerIncludes' });
                }
            },
        };
    },
};
function isZero(node) {
    return node.type === 'Literal' && node.value === 0;
}
function isArrayIndexOfCall(node, services) {
    return (node.type === 'CallExpression' &&
        node.arguments.length === 1 &&
        node.callee.type === 'MemberExpression' &&
        node.callee.property.type === 'Identifier' &&
        node.callee.property.name === 'indexOf' &&
        isArray(node.callee.object, services));
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$21 = {
    meta: {
        schema: [
            {
                // internal parameter for rules having secondary locations
                enum: ['sonar-runtime'],
            },
        ],
    },
    create(context) {
        return {
            CallExpression: (node) => new CookieFlagCheck(context, 'secure').checkCookiesFromCallExpression(node),
        };
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$20 = {
    meta: {
        schema: [
            {
                // internal parameter for rules having secondary locations
                enum: ['sonar-runtime'],
            },
        ],
    },
    create(context) {
        const SIGN_MESSAGE = 'Use only strong cipher algorithms when signing this JWT.';
        const VERIFY_MESSAGE = 'Use only strong cipher algorithms when verifying the signature of this JWT.';
        const SECONDARY_MESSAGE = `The "algorithms" option should be defined and should not contain 'none'.`;
        function checkCallToSign(callExpression, thirdArgumentValue, secondaryLocations) {
            const unsafeAlgorithmProperty = getPropertyWithValue(context, thirdArgumentValue, 'algorithm', 'none');
            if (unsafeAlgorithmProperty) {
                const unsafeAlgorithmValue = getValueOfExpression(context, unsafeAlgorithmProperty.value, 'Literal');
                if (unsafeAlgorithmValue && unsafeAlgorithmValue !== unsafeAlgorithmProperty.value) {
                    secondaryLocations.push(unsafeAlgorithmValue);
                }
                raiseIssueOn(callExpression.callee, SIGN_MESSAGE, secondaryLocations);
            }
        }
        function checkCallToVerify(callExpression, publicKey, thirdArgumentValue, secondaryLocations) {
            const algorithmsProperty = getObjectExpressionProperty(thirdArgumentValue, 'algorithms');
            if (!algorithmsProperty) {
                if (isNullLiteral(publicKey)) {
                    raiseIssueOn(callExpression.callee, VERIFY_MESSAGE, secondaryLocations);
                }
                return;
            }
            const algorithmsValue = getValueOfExpression(context, algorithmsProperty.value, 'ArrayExpression');
            if (!algorithmsValue) {
                return;
            }
            const algorithmsContainNone = algorithmsValue.elements.some(e => {
                const value = getValueOfExpression(context, e, 'Literal');
                return (value === null || value === void 0 ? void 0 : value.value) === 'none';
            });
            if (algorithmsContainNone) {
                if (algorithmsProperty.value !== algorithmsValue) {
                    secondaryLocations.push(algorithmsValue);
                }
                raiseIssueOn(callExpression.callee, VERIFY_MESSAGE, secondaryLocations);
            }
        }
        function raiseIssueOn(node, message, secondaryLocations) {
            context.report({
                node,
                message: toEncodedMessage$1(message, secondaryLocations, Array(secondaryLocations.length).fill(SECONDARY_MESSAGE)),
            });
        }
        return {
            CallExpression: (node) => {
                const callExpression = node;
                const isCallToSign = isCallToFQN(context, callExpression, 'jsonwebtoken', 'sign');
                const isCallToVerify = isCallToFQN(context, callExpression, 'jsonwebtoken', 'verify');
                if (!isCallToSign && !isCallToVerify) {
                    return;
                }
                if (callExpression.arguments.length < 3) {
                    // algorithm(s) property is contained in third argument of "sign" and "verify" calls
                    return;
                }
                const thirdArgument = callExpression.arguments[2];
                const thirdArgumentValue = getValueOfExpression(context, thirdArgument, 'ObjectExpression');
                if (!thirdArgumentValue) {
                    return;
                }
                const secondaryLocations = [thirdArgumentValue];
                if (thirdArgumentValue !== thirdArgument) {
                    secondaryLocations.push(thirdArgument);
                }
                if (isCallToSign) {
                    checkCallToSign(callExpression, thirdArgumentValue, secondaryLocations);
                }
                const secondArgument = callExpression.arguments[1];
                if (isCallToVerify) {
                    checkCallToVerify(callExpression, secondArgument, thirdArgumentValue, secondaryLocations);
                }
            },
        };
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const ASSERT_FUNCTIONS = [
    'equal',
    'notEqual',
    'strictEqual',
    'notStrictEqual',
    'deepEqual',
    'notDeepEqual',
    'closeTo',
    'approximately',
];
const rule$1$ = {
    meta: {
        hasSuggestions: true,
        schema: [
            {
                // internal parameter for rules having secondary locations
                enum: ['sonar-runtime'],
            },
        ],
    },
    create(context) {
        const testCases = [];
        return {
            CallExpression(node) {
                if (Mocha.isTestCase(node)) {
                    testCases.push(node);
                    return;
                }
                if (testCases.length > 0) {
                    checkInvertedArguments(node, context);
                }
            },
            'CallExpression:exit': (node) => {
                if (Mocha.isTestCase(node)) {
                    testCases.pop();
                }
            },
        };
    },
};
function checkInvertedArguments(node, context) {
    const args = extractAssertionsArguments(node);
    if (args) {
        const [actual, expected] = args;
        if (isLiteral$2(actual) && !isLiteral$2(expected)) {
            const message = toEncodedMessage$1('Swap these 2 arguments so they are in the correct order: actual value, expected value.', [actual], ['Other argument to swap.']);
            context.report({
                node: expected,
                message,
                suggest: [
                    {
                        desc: 'Swap arguments',
                        fix: fixer => [
                            fixer.replaceText(actual, context.getSourceCode().getText(expected)),
                            fixer.replaceText(expected, context.getSourceCode().getText(actual)),
                        ],
                    },
                ],
            });
        }
    }
}
function extractAssertionsArguments(node) {
    var _a, _b;
    return (_b = (_a = extractAssertArguments(node)) !== null && _a !== void 0 ? _a : extractExpectArguments(node)) !== null && _b !== void 0 ? _b : extractFailArguments(node);
}
function extractAssertArguments(node) {
    if (isMethodCall(node) && node.arguments.length > 1) {
        const { callee: { object, property }, arguments: [actual, expected], } = node;
        if (isIdentifier(object, 'assert') && isIdentifier(property, ...ASSERT_FUNCTIONS)) {
            return [actual, expected];
        }
    }
    return null;
}
function extractExpectArguments(node) {
    if (node.callee.type !== 'MemberExpression') {
        return null;
    }
    let { object, property } = node.callee;
    if (!isIdentifier(property, 'equal', 'eql', 'closeTo')) {
        return null;
    }
    while (object.type === 'MemberExpression') {
        object = object.object;
    }
    if (object.type === 'CallExpression' && isIdentifier(object.callee, 'expect')) {
        return [object.arguments[0], node.arguments[0]];
    }
    return null;
}
function extractFailArguments(node) {
    if (isMethodCall(node) && node.arguments.length > 1) {
        const { callee: { object, property }, arguments: [actual, expected], } = node;
        if (isIdentifier(object, 'assert', 'expect', 'should') && isIdentifier(property, 'fail')) {
            return [actual, expected];
        }
    }
    return null;
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
// https://jira.sonarsource.com/browse/RSPEC-1439
const rule$1_ = {
    meta: {
        messages: {
            removeLabel: 'Remove this "{{label}}" label.',
        },
    },
    create(context) {
        return {
            LabeledStatement: (node) => checkLabeledStatement(node, context),
        };
    },
};
function checkLabeledStatement(node, context) {
    if (!isLoopStatement(node.body) && !isSwitchStatement(node.body)) {
        context.report({
            messageId: 'removeLabel',
            data: {
                label: node.label.name,
            },
            node: node.label,
        });
    }
}
function isLoopStatement(node) {
    return (node.type === 'WhileStatement' ||
        node.type === 'DoWhileStatement' ||
        node.type === 'ForStatement' ||
        node.type === 'ForOfStatement' ||
        node.type === 'ForInStatement');
}
function isSwitchStatement(node) {
    return node.type === 'SwitchStatement';
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
// https://jira.sonarsource.com/browse/RSPEC-4622
const rule$1Z = {
    meta: {
        messages: {
            refactorUnion: 'Refactor this union type to have less than {{threshold}} elements.',
        },
    },
    create(context) {
        return {
            TSUnionType: (node) => {
                const union = node;
                const [threshold] = context.options;
                if (union.types.length > threshold && !isFromTypeStatement(union)) {
                    context.report({
                        messageId: 'refactorUnion',
                        data: {
                            threshold,
                        },
                        node,
                    });
                }
            },
        };
    },
};
function isFromTypeStatement(node) {
    return node.parent !== undefined && node.parent.type === 'TSTypeAliasDeclaration';
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
class ForInfo {
    constructor(forLoop) {
        this.forLoop = forLoop;
        this.updatedExpressions = [];
        this.testedExpressions = [];
    }
}
const rule$1Y = {
    meta: {
        messages: {
            misplacedCounter: `This loop's stop condition tests "{{test}}" but the incrementer updates "{{update}}".`,
        },
    },
    create(context) {
        const forLoopStack = [];
        function join(expressions) {
            return expressions.map(expr => context.getSourceCode().getText(expr)).join(', ');
        }
        function isInsideUpdate(node) {
            return isInside(node, f => f.update);
        }
        function isInsideTest(node) {
            return isInside(node, f => f.test);
        }
        function isInside(node, getChild) {
            if (forLoopStack.length > 0) {
                const currentLoop = peekFor();
                const parentChain = context.getAncestors();
                parentChain.push(node);
                const forLoopChild = getChild(currentLoop.forLoop);
                if (forLoopChild) {
                    return parentChain.some(parentChainNode => forLoopChild === parentChainNode);
                }
            }
            return false;
        }
        function peekFor() {
            return forLoopStack[forLoopStack.length - 1];
        }
        return {
            ForStatement: (node) => {
                forLoopStack.push(new ForInfo(node));
            },
            'ForStatement:exit': () => {
                const forInfo = forLoopStack.pop();
                if (forInfo.updatedExpressions.length === 0 || !forInfo.forLoop.test) {
                    return;
                }
                const hasIntersection = forInfo.testedExpressions.some(testedExpr => forInfo.updatedExpressions.some(updatedExpr => equivalence.areEquivalent(updatedExpr, testedExpr, context.getSourceCode())));
                if (!hasIntersection) {
                    context.report({
                        loc: context.getSourceCode().getFirstToken(forInfo.forLoop).loc,
                        messageId: 'misplacedCounter',
                        data: {
                            test: join(forInfo.testedExpressions),
                            update: join(forInfo.updatedExpressions),
                        },
                    });
                }
            },
            'ForStatement AssignmentExpression': (node) => {
                if (isInsideUpdate(node)) {
                    const left = node.left;
                    const assignedExpressions = [];
                    computeAssignedExpressions(left, assignedExpressions);
                    const { updatedExpressions } = peekFor();
                    assignedExpressions.forEach(ass => updatedExpressions.push(ass));
                }
            },
            'ForStatement UpdateExpression': (node) => {
                if (isInsideUpdate(node)) {
                    peekFor().updatedExpressions.push(node.argument);
                }
            },
            'ForStatement CallExpression': (node) => {
                if (!isInsideUpdate(node)) {
                    return;
                }
                const callee = getCalleeObject(node);
                if (callee) {
                    peekFor().updatedExpressions.push(callee);
                }
            },
            'ForStatement Identifier': (node) => {
                if (isInsideTest(node)) {
                    const parent = getParent(context);
                    if (parent.type !== 'MemberExpression' || parent.computed || parent.object === node) {
                        peekFor().testedExpressions.push(node);
                    }
                }
            },
            'ForStatement MemberExpression': (node) => {
                if (isInsideTest(node) &&
                    getParent(context).type !== 'MemberExpression' &&
                    getParent(context).type !== 'CallExpression') {
                    peekFor().testedExpressions.push(node);
                }
            },
        };
    },
};
function getCalleeObject(node) {
    let callee = node.callee;
    while (callee.type === 'MemberExpression') {
        callee = callee.object;
    }
    if (callee.type === 'Identifier' && callee !== node.callee) {
        return callee;
    }
    return null;
}
function computeAssignedExpressions(node, assigned) {
    switch (node === null || node === void 0 ? void 0 : node.type) {
        case 'ArrayPattern':
            node.elements.forEach(element => computeAssignedExpressions(element, assigned));
            break;
        case 'ObjectPattern':
            node.properties.forEach(property => computeAssignedExpressions(property, assigned));
            break;
        case 'Property':
            computeAssignedExpressions(node.value, assigned);
            break;
        case 'AssignmentPattern':
            computeAssignedExpressions(node.left, assigned);
            break;
        default:
            assigned.push(node);
    }
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$1X = {
    meta: {
        schema: [
            { type: 'integer' },
            {
                // internal parameter for rules having secondary locations
                enum: ['sonar-runtime'],
            },
        ],
    },
    create(context) {
        const sourceCode = context.getSourceCode();
        const [threshold] = context.options;
        const nodeStack = [];
        function push(n) {
            nodeStack.push(n);
        }
        function pop() {
            return nodeStack.pop();
        }
        function check(node) {
            if (nodeStack.length === threshold) {
                context.report({
                    message: toEncodedMessage$1(`Refactor this code to not nest more than ${threshold} if/for/while/switch/try statements.`, nodeStack, nodeStack.map(_n => '+1')),
                    loc: sourceCode.getFirstToken(node).loc,
                });
            }
        }
        function isElseIf(node) {
            const parent = last(context.getAncestors());
            return (node.type === 'IfStatement' && parent.type === 'IfStatement' && node === parent.alternate);
        }
        const controlFlowNodes = [
            'ForStatement',
            'ForInStatement',
            'ForOfStatement',
            'WhileStatement',
            'DoWhileStatement',
            'IfStatement',
            'TryStatement',
            'SwitchStatement',
        ].join(',');
        return {
            [controlFlowNodes]: (node) => {
                if (isElseIf(node)) {
                    pop();
                    push(sourceCode.getFirstToken(node));
                }
                else {
                    check(node);
                    push(sourceCode.getFirstToken(node));
                }
            },
            [`${controlFlowNodes}:exit`]: (node) => {
                if (!isElseIf(node)) {
                    pop();
                }
            },
        };
    },
};
function last(arr) {
    return arr[arr.length - 1];
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$1W = {
    meta: {
        schema: [
            { type: 'object' },
            {
                // internal parameter for rules having secondary locations
                enum: ['sonar-runtime'],
            },
        ],
    },
    create(context) {
        const { considerJSDoc } = context.options[0];
        const services = context.parserServices;
        if (!parserServices.isRequiredParserServices(services)) {
            return {};
        }
        return {
            'NewExpression[callee.type!="ThisExpression"]': (node) => {
                const { callee } = node;
                const type = getTypeFromTreeNode$1(callee, services);
                const signature = getSignatureFromCallee(node, services);
                if (!isInstantiable(type, signature, considerJSDoc) && !isAny$1(type)) {
                    const functionToken = context
                        .getSourceCode()
                        .getFirstToken(node, token => token.type === 'Keyword' && token.value === 'function');
                    const newToken = context
                        .getSourceCode()
                        .getFirstToken(node, token => token.type === 'Keyword' && token.value === 'new');
                    const text = isFunction(type) ? 'this function' : context.getSourceCode().getText(callee);
                    const loc = callee.type === 'FunctionExpression' ? functionToken.loc : callee.loc;
                    context.report({
                        message: toEncodedMessage$1(`Replace ${text} with a constructor function.`, [newToken]),
                        loc,
                    });
                }
            },
        };
    },
};
function isInstantiable(type, signature, considerJSDoc) {
    return (isClass(type) ||
        isModule(type) ||
        isConstructor(type, signature, considerJSDoc) ||
        (type.isUnionOrIntersection() &&
            type.types.some(tp => isInstantiable(tp, signature, considerJSDoc))));
}
function isClass(type) {
    return (type.symbol &&
        ((type.symbol.flags & ts__namespace.SymbolFlags.Class) !== 0 ||
            (type.symbol.flags & ts__namespace.SymbolFlags.Type) !== 0));
}
function isModule(type) {
    return type.symbol && (type.symbol.flags & ts__namespace.SymbolFlags.Module) !== 0;
}
function isFunction(type) {
    return type.symbol && (type.symbol.flags & ts__namespace.SymbolFlags.Function) !== 0;
}
function isConstructor(type, signature, considerJSDoc) {
    return isFunction(type) && (!considerJSDoc || hasJSDocAnnotation(signature));
}
function hasJSDocAnnotation(signature) {
    return (signature !== undefined &&
        signature.getJsDocTags().some(tag => ['constructor', 'class'].includes(tag.name)));
}
function isAny$1(type) {
    return type.flags === ts__namespace.TypeFlags.Any;
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$1V = {
    meta: {
        schema: [
            {
                // internal parameter for rules having secondary locations
                enum: ['sonar-runtime'],
            },
        ],
    },
    create(context) {
        const currentFieldsStack = [new Map()];
        function checkAccessor(accessor) {
            const accessorIsPublic = accessor.type !== 'MethodDefinition' || accessor.accessibility === 'public';
            const accessorInfo = getAccessorInfo(accessor);
            const statements = getFunctionBody(accessor.value);
            if (!accessorInfo || !accessorIsPublic || !statements || statements.length > 1) {
                return;
            }
            const matchingFields = findMatchingFields(currentFieldsStack[currentFieldsStack.length - 1], accessorInfo.name);
            if (matchingFields.length > 0 &&
                (statements.length === 0 ||
                    !isUsingAccessorFieldInBody(statements[0], accessorInfo, matchingFields))) {
                const fieldToRefer = matchingFields[0];
                const primaryMessage = `Refactor this ${accessorInfo.type} ` +
                    `so that it actually refers to the property '${fieldToRefer.name}'.`;
                const secondaryLocations = [fieldToRefer.node];
                const secondaryMessages = ['Property which should be referred.'];
                context.report({
                    message: toEncodedMessage$1(primaryMessage, secondaryLocations, secondaryMessages),
                    loc: accessor.key.loc,
                });
            }
        }
        return {
            Property: (node) => checkAccessor(node),
            MethodDefinition: (node) => checkAccessor(node),
            ClassBody: (node) => {
                const classBody = node;
                const fields = getFieldMap(classBody.body, classElement => (classElement.type === 'PropertyDefinition' ||
                    classElement.type === 'TSAbstractPropertyDefinition') &&
                    !classElement.static
                    ? classElement.key
                    : null);
                const fieldsFromConstructor = fieldsDeclaredInConstructorParameters(classBody);
                const allFields = new Map([...fields, ...fieldsFromConstructor]);
                currentFieldsStack.push(allFields);
            },
            ObjectExpression: (node) => {
                const currentFields = getFieldMap(node.properties, prop => isValidObjectField(prop) ? prop.key : null);
                currentFieldsStack.push(currentFields);
            },
            ':matches(ClassBody, ObjectExpression):exit': () => {
                currentFieldsStack.pop();
            },
        };
    },
};
function getAccessorInfo(accessor) {
    let name = getName(accessor.key);
    if (!name) {
        return null;
    }
    name = name.toLowerCase();
    if (accessor.kind === 'get') {
        return { type: 'getter', name };
    }
    else if (accessor.kind === 'set') {
        return { type: 'setter', name };
    }
    else {
        return setterOrGetter(name, accessor.value);
    }
}
function getName(key) {
    if (key.type === 'Literal') {
        return String(key.value);
    }
    else if (key.type === 'Identifier') {
        return key.name;
    }
    return null;
}
function setterOrGetter(name, functionExpression) {
    if (functionExpression.type !== 'FunctionExpression') {
        return null;
    }
    if (name.startsWith('set') && functionExpression.params.length === 1) {
        return { type: 'setter', name: name.substring(3) };
    }
    if (name.startsWith('get') && functionExpression.params.length === 0) {
        return { type: 'getter', name: name.substring(3) };
    }
    return null;
}
function getFieldMap(elements, getPropertyName) {
    const fields = new Map();
    for (const element of elements) {
        const propertyNameNode = getPropertyName(element);
        if (propertyNameNode) {
            const name = getName(propertyNameNode);
            if (name) {
                fields.set(name.toLowerCase(), {
                    name,
                    node: element,
                });
            }
        }
    }
    return fields;
}
function isValidObjectField(prop) {
    return prop.type === 'Property' && !prop.method && prop.kind === 'init';
}
function fieldsDeclaredInConstructorParameters(containingClass) {
    const constr = getConstructorOf(containingClass);
    if (constr) {
        const fieldsFromConstructor = new Map();
        for (const parameter of constr.params) {
            if (parameter.type === 'TSParameterProperty' &&
                (parameter.accessibility || parameter.readonly)) {
                const parameterName = getName(parameter.parameter);
                if (parameterName) {
                    fieldsFromConstructor.set(parameterName, {
                        name: parameterName,
                        node: parameter,
                    });
                }
            }
        }
        return fieldsFromConstructor;
    }
    else {
        return new Map();
    }
}
function getConstructorOf(containingClass) {
    for (const classElement of containingClass.body) {
        if (classElement.type === 'MethodDefinition' && getName(classElement.key) === 'constructor') {
            return classElement.value;
        }
    }
}
function findMatchingFields(currentFields, name) {
    const underscoredTargetName1 = `_${name}`;
    const underscoredTargetName2 = `${name}_`;
    const exactFieldName = currentFields.get(name);
    const underscoreFieldName1 = currentFields.get(underscoredTargetName1);
    const underscoreFieldName2 = currentFields.get(underscoredTargetName2);
    return [exactFieldName, underscoreFieldName1, underscoreFieldName2].filter(field => field);
}
function getFunctionBody(node) {
    if (node.type !== 'FunctionExpression' || !node.body) {
        return null;
    }
    return node.body.body;
}
function getPropertyName(expression) {
    if (expression &&
        expression.type === 'MemberExpression' &&
        expression.object.type === 'ThisExpression') {
        return getName(expression.property);
    }
    return null;
}
function getFieldUsedInsideSimpleBody(statement, accessorInfo) {
    if (accessorInfo.type === 'setter') {
        if (statement.type === 'ExpressionStatement' &&
            statement.expression.type === 'AssignmentExpression') {
            return getPropertyName(statement.expression.left);
        }
    }
    else if (statement.type === 'ReturnStatement') {
        return getPropertyName(statement.argument);
    }
    return null;
}
function isUsingAccessorFieldInBody(statement, accessorInfo, matchingFields) {
    const usedField = getFieldUsedInsideSimpleBody(statement, accessorInfo);
    return !usedField || matchingFields.some(matchingField => usedField === matchingField.name);
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const compareFunctionPlaceholder = '(a, b) => (a - b)';
const rule$1U = {
    meta: {
        hasSuggestions: true,
        messages: {
            provideCompareFunction: 'Provide a compare function to avoid sorting elements alphabetically.',
            suggestCompareFunction: 'Add a comparator function to sort in ascending order',
        },
    },
    create(context) {
        const services = context.parserServices;
        if (!parserServices.isRequiredParserServices(services)) {
            return {};
        }
        return {
            CallExpression: (node) => {
                const call = node;
                const callee = call.callee;
                if (call.arguments.length === 0 && callee.type === 'MemberExpression') {
                    const { object, property } = callee;
                    const text = context.getSourceCode().getText(property);
                    if (sortLike.includes(text)) {
                        const arrayElementType = arrayElementTypeOf(object, services);
                        if (arrayElementType && arrayElementType.kind === ts__namespace.SyntaxKind.NumberKeyword) {
                            const closingParenthesis = context
                                .getSourceCode()
                                .getLastToken(node, token => token.value === ')');
                            context.report({
                                messageId: 'provideCompareFunction',
                                node: property,
                                suggest: [
                                    {
                                        messageId: 'suggestCompareFunction',
                                        fix: fixer => fixer.insertTextBefore(closingParenthesis, compareFunctionPlaceholder),
                                    },
                                ],
                            });
                        }
                    }
                }
            },
        };
    },
};
function arrayElementTypeOf(node, services) {
    const { typeToTypeNode, getTypeAtLocation } = services.program.getTypeChecker();
    const typeNode = typeToTypeNode(getTypeAtLocation(services.esTreeNodeToTSNodeMap.get(node)), undefined, undefined);
    if (typeNode && ts__namespace.isArrayTypeNode(typeNode)) {
        return typeNode.elementType;
    }
    return undefined;
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const bypassMethods = [
    'bypassSecurityTrustHtml',
    'bypassSecurityTrustStyle',
    'bypassSecurityTrustScript',
    'bypassSecurityTrustUrl',
    'bypassSecurityTrustResourceUrl',
];
const rule$1T = {
    meta: {
        messages: {
            checkAngularBypass: 'Make sure disabling Angular built-in sanitization is safe here.',
        },
    },
    create(context) {
        return {
            CallExpression: (node) => {
                const { callee, arguments: args } = node;
                if (isMemberWithProperty$1(callee, ...bypassMethods) &&
                    args.length === 1 &&
                    !isHardcodedLiteral$1(args[0])) {
                    context.report({
                        messageId: 'checkAngularBypass',
                        node: callee.property,
                    });
                }
            },
        };
    },
};
function isHardcodedLiteral$1(node) {
    if (node.type === 'TemplateLiteral') {
        return node.expressions.length === 0;
    }
    else {
        return isLiteral$2(node);
    }
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const ArrayDeleteExpression = "UnaryExpression[operator='delete'] > MemberExpression[computed=true]";
const rule$1S = {
    meta: {
        messages: {
            removeDelete: 'Remove this use of "delete".',
        },
    },
    create(context) {
        const services = context.parserServices;
        if (parserServices.isRequiredParserServices(services)) {
            return {
                [ArrayDeleteExpression]: (node) => {
                    const member = node;
                    const object = member.object;
                    if (isArray(object, services)) {
                        raiseIssue$1(context);
                    }
                },
            };
        }
        return {};
    },
};
function raiseIssue$1(context) {
    const deleteKeyword = context.getSourceCode().getFirstToken(getParent(context));
    context.report({
        messageId: 'removeDelete',
        loc: deleteKeyword.loc,
    });
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$1R = {
    meta: {
        messages: {
            noAssociativeArray: 'Make it an object if it must have named properties; otherwise, use a numeric index here.',
        },
    },
    create(context) {
        const services = context.parserServices;
        if (!parserServices.isRequiredParserServices(services)) {
            return {};
        }
        return {
            'AssignmentExpression[left.type="MemberExpression"]'(node) {
                const { property, object } = node
                    .left;
                if (isString$1(property, services) && isArray(object, services)) {
                    context.report({
                        messageId: 'noAssociativeArray',
                        node,
                    });
                }
            },
        };
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$1Q = {
    meta: {
        messages: {
            removeOverride: 'Remove this override of "{{overridden}}".',
        },
    },
    create(context) {
        const overriden = new Set();
        function isBuiltIn(variable) {
            return globalsByLibraries.builtin.includes(variable.name);
        }
        function checkVariable(variable) {
            if (isBuiltIn(variable)) {
                variable.defs.forEach(def => overriden.add(def.name));
                variable.references
                    .filter(ref => ref.isWrite())
                    .forEach(ref => overriden.add(ref.identifier));
            }
        }
        function checkScope(scope) {
            scope.variables.forEach(checkVariable);
            scope.childScopes.forEach(checkScope);
        }
        function isTSEnumMemberId(node) {
            var _a;
            const id = node;
            return ((_a = id.parent) === null || _a === void 0 ? void 0 : _a.type) === 'TSEnumMember';
        }
        return {
            Program: () => {
                checkScope(context.getScope());
            },
            'Program:exit': () => {
                overriden.forEach(node => {
                    if (!isTSEnumMemberId(node)) {
                        context.report({
                            messageId: 'removeOverride',
                            data: {
                                overridden: node.name,
                            },
                            node,
                        });
                    }
                });
                overriden.clear();
            },
        };
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
// https://jira.sonarsource.com/browse/RSPEC-1219
const rule$1P = {
    meta: {
        messages: {
            removeLabel: 'Remove this misleading "{{label}}" label.',
        },
    },
    create(context) {
        const stack = [0];
        function enterCase() {
            stack.push(stack.pop() + 1);
        }
        function leaveCase() {
            stack.push(stack.pop() - 1);
        }
        function inCase() {
            return stack[stack.length - 1] > 0;
        }
        return {
            SwitchCase: () => {
                enterCase();
            },
            LabeledStatement: (node) => {
                if (inCase()) {
                    const label = node.label;
                    context.report({
                        messageId: 'removeLabel',
                        data: {
                            label: label.name,
                        },
                        node: label,
                    });
                }
            },
            'FunctionExpression, FunctionDeclaration': () => {
                stack.push(0);
            },
            'SwitchCase:exit': () => {
                leaveCase();
            },
            'FunctionExpression, FunctionDeclaration :exit': () => {
                stack.pop();
            },
        };
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const INSECURE_PROTOCOLS = ['http://', 'ftp://', 'telnet://'];
const LOOPBACK_PATTERN = /localhost|127(?:\.[0-9]+){0,2}\.[0-9]+$|\/\/(?:0*\:)*?:?0*1$/;
const EXCEPTION_FULL_HOSTS = [
    'www.w3.org',
    'xml.apache.org',
    'schemas.xmlsoap.org',
    'schemas.openxmlformats.org',
    'rdfs.org',
    'purl.org',
    'xmlns.com',
    'schemas.google.com',
    'a9.com',
    'ns.adobe.com',
    'ltsc.ieee.org',
    'docbook.org',
    'graphml.graphdrawing.org',
    'json-schema.org',
];
const EXCEPTION_TOP_HOSTS = [/(.*\.)?example\.com$/, /(.*\.)?example\.org$/, /(.*\.)?test\.com$/];
const rule$1O = {
    meta: {
        messages: {
            insecureProtocol: 'Using {{protocol}} protocol is insecure. Use {{alternative}} instead.',
        },
    },
    create(context) {
        function checkNodemailer(callExpression) {
            const firstArg = callExpression.arguments.length > 0 ? callExpression.arguments[0] : null;
            if (!firstArg) {
                return;
            }
            const firstArgValue = getValueOfExpression(context, firstArg, 'ObjectExpression');
            const secure = getObjectExpressionProperty(firstArgValue, 'secure');
            const requireTls = getObjectExpressionProperty(firstArgValue, 'requireTLS');
            const port = getObjectExpressionProperty(firstArgValue, 'port');
            if (secure && (secure.value.type !== 'Literal' || secure.value.raw !== 'false')) {
                return;
            }
            if (requireTls && (requireTls.value.type !== 'Literal' || requireTls.value.raw !== 'false')) {
                return;
            }
            if (port && (port.value.type !== 'Literal' || port.value.raw === '465')) {
                return;
            }
            context.report(Object.assign({ node: callExpression.callee }, getMessageAndData$1('http')));
        }
        function checkCallToFtp(callExpression) {
            var _a;
            if (callExpression.callee.type === 'MemberExpression' &&
                callExpression.callee.property.type === 'Identifier' &&
                callExpression.callee.property.name === 'connect') {
                const newExpression = getValueOfExpression(context, callExpression.callee.object, 'NewExpression');
                if (!!newExpression &&
                    ((_a = getModuleNameOfNode(context, newExpression.callee)) === null || _a === void 0 ? void 0 : _a.value) === 'ftp') {
                    const firstArg = callExpression.arguments.length > 0 ? callExpression.arguments[0] : null;
                    if (!firstArg) {
                        return;
                    }
                    const firstArgValue = getValueOfExpression(context, firstArg, 'ObjectExpression');
                    const secure = getObjectExpressionProperty(firstArgValue, 'secure');
                    if (secure && secure.value.type === 'Literal' && secure.value.raw === 'false') {
                        context.report(Object.assign({ node: callExpression.callee }, getMessageAndData$1('ftp')));
                    }
                }
            }
        }
        function checkCallToRequire(callExpression) {
            if (callExpression.callee.type === 'Identifier' && callExpression.callee.name === 'require') {
                const firstArg = callExpression.arguments.length > 0 ? callExpression.arguments[0] : null;
                if (firstArg &&
                    firstArg.type === 'Literal' &&
                    typeof firstArg.value === 'string' &&
                    firstArg.value === 'telnet-client') {
                    context.report(Object.assign({ node: firstArg }, getMessageAndData$1('telnet')));
                }
            }
        }
        function isExceptionUrl(value) {
            if (INSECURE_PROTOCOLS.includes(value)) {
                const parent = getParent(context);
                return !((parent === null || parent === void 0 ? void 0 : parent.type) === 'BinaryExpression' && parent.operator === '+');
            }
            return hasExceptionHost(value);
        }
        function hasExceptionHost(value) {
            let url$1;
            try {
                url$1 = new url.URL(value);
            }
            catch (err) {
                return false;
            }
            const host = url$1.hostname;
            return (host.length === 0 ||
                LOOPBACK_PATTERN.test(host) ||
                EXCEPTION_FULL_HOSTS.some(exception => exception === host) ||
                EXCEPTION_TOP_HOSTS.some(exception => exception.test(host)));
        }
        return {
            Literal: (node) => {
                const literal = node;
                if (typeof literal.value === 'string') {
                    const value = literal.value.trim().toLocaleLowerCase();
                    const insecure = INSECURE_PROTOCOLS.find(protocol => value.startsWith(protocol));
                    if (insecure && !isExceptionUrl(value)) {
                        const protocol = insecure.substring(0, insecure.indexOf(':'));
                        context.report(Object.assign(Object.assign({}, getMessageAndData$1(protocol)), { node }));
                    }
                }
            },
            CallExpression: (node) => {
                const callExpression = node;
                if (isCallToFQN(context, callExpression, 'nodemailer', 'createTransport')) {
                    checkNodemailer(callExpression);
                }
                checkCallToFtp(callExpression);
                checkCallToRequire(callExpression);
            },
            ImportDeclaration: (node) => {
                const importDeclaration = node;
                if (typeof importDeclaration.source.value === 'string' &&
                    importDeclaration.source.value === 'telnet-client') {
                    context.report(Object.assign({ node: importDeclaration.source }, getMessageAndData$1('telnet')));
                }
            },
        };
    },
};
function getMessageAndData$1(protocol) {
    let alternative;
    switch (protocol) {
        case 'http':
            alternative = 'https';
            break;
        case 'ftp':
            alternative = 'sftp, scp or ftps';
            break;
        default:
            alternative = 'ssh';
    }
    return { messageId: 'insecureProtocol', data: { protocol, alternative } };
}

class AssignedValues extends Set {
    constructor() {
        super(...arguments);
        this.type = 'AssignedValues';
    }
}
const assignedValues = (val) => new AssignedValues([val]);
const unknownValue = {
    type: 'UnknownValue',
};
function reachingDefinitions(reachingDefinitionsMap) {
    const worklist = Array.from(reachingDefinitionsMap.values(), defs => defs.segment);
    while (worklist.length > 0) {
        const current = worklist.pop();
        const reachingDefs = reachingDefinitionsMap.get(current.id);
        const outHasChanged = reachingDefs.propagate(reachingDefinitionsMap);
        if (outHasChanged) {
            current.nextSegments.forEach(next => worklist.push(next));
        }
    }
}
class ReachingDefinitions {
    constructor(segment) {
        this.in = new Map();
        this.out = new Map();
        /**
         * collects references in order they are evaluated, set in JS maintains insertion order
         */
        this.references = new Set();
        this.segment = segment;
    }
    add(ref) {
        const variable = ref.resolved;
        if (variable) {
            this.references.add(ref);
        }
    }
    propagate(reachingDefinitionsMap) {
        this.in.clear();
        this.segment.prevSegments.forEach(prev => {
            this.join(reachingDefinitionsMap.get(prev.id).out);
        });
        const newOut = new Map(this.in);
        this.references.forEach(ref => this.updateProgramState(ref, newOut));
        if (!equals$1(this.out, newOut)) {
            this.out = newOut;
            return true;
        }
        else {
            return false;
        }
    }
    updateProgramState(ref, programState) {
        const variable = ref.resolved;
        if (!variable || !ref.isWrite()) {
            return;
        }
        if (!ref.writeExpr) {
            programState.set(variable, unknownValue);
            return;
        }
        const rhsValues = resolveAssignedValues(variable, ref.writeExpr, programState, ref.from);
        programState.set(variable, rhsValues);
    }
    join(previousOut) {
        for (const [key, values] of previousOut.entries()) {
            const inValues = this.in.get(key) || new AssignedValues();
            if (inValues.type === 'AssignedValues' && values.type === 'AssignedValues') {
                values.forEach(val => inValues.add(val));
                this.in.set(key, inValues);
            }
            else {
                this.in.set(key, unknownValue);
            }
        }
    }
}
function resolveAssignedValues(lhsVariable, writeExpr, assignedValuesMap, scope) {
    if (!writeExpr) {
        return unknownValue;
    }
    switch (writeExpr.type) {
        case 'Literal':
            return writeExpr.raw ? assignedValues(writeExpr.raw) : unknownValue;
        case 'Identifier':
            const resolvedVar = getVariableFromIdentifier(writeExpr, scope);
            if (resolvedVar && resolvedVar !== lhsVariable) {
                const resolvedAssignedValues = assignedValuesMap.get(resolvedVar);
                return resolvedAssignedValues || unknownValue;
            }
            return unknownValue;
        default:
            return unknownValue;
    }
}
function equals$1(ps1, ps2) {
    if (ps1.size !== ps2.size) {
        return false;
    }
    for (const [variable, values1] of ps1) {
        const values2 = ps2.get(variable);
        if (!values2 || !valuesEquals(values2, values1)) {
            return false;
        }
    }
    return true;
}
function valuesEquals(a, b) {
    if (a.type === 'AssignedValues' && b.type === 'AssignedValues') {
        return setEquals(a, b);
    }
    return a === b;
}
function setEquals(a, b) {
    return a.size === b.size && [...a].every(e => b.has(e));
}
function getVariableFromIdentifier(identifier, scope) {
    let variable = scope.variables.find(value => value.name === identifier.name);
    if (!variable && scope.upper) {
        variable = scope.upper.variables.find(value => value.name === identifier.name);
    }
    return variable;
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$1N = {
    meta: {
        schema: [
            {
                // internal parameter for rules having secondary locations
                enum: ['sonar-runtime'],
            },
        ],
    },
    create(context) {
        let currentDoneVariable;
        let doneCall;
        let doneSegment;
        let currentSegment;
        let currentCase;
        const segmentFirstStatement = new Map();
        function checkForTestCase(node) {
            const testCase = Mocha.extractTestCase(node);
            if (!testCase) {
                return;
            }
            currentCase = testCase;
            currentDoneVariable = undefined;
            if (testCase.callback.params.length === 0) {
                return;
            }
            const [done] = testCase.callback.params;
            if (done.type !== 'Identifier') {
                return;
            }
            const callbackScope = context
                .getScope()
                .childScopes.find(scope => scope.block === testCase.callback);
            if (!callbackScope) {
                return;
            }
            currentDoneVariable = getVariableFromIdentifier(done, callbackScope);
        }
        function checkForDoneCall(node) {
            const { callee } = node;
            if (currentDoneVariable &&
                currentDoneVariable.references.some(ref => ref.identifier === callee)) {
                doneCall = node;
                doneSegment = currentSegment;
            }
        }
        function report(statementAfterDone) {
            context.report({
                node: statementAfterDone,
                message: toEncodedMessage$1(`Move this code before the call to "done".`, [
                    doneCall,
                ]),
            });
            doneSegment = undefined;
            doneCall = undefined;
            currentDoneVariable = undefined;
        }
        return {
            CallExpression: (node) => {
                checkForTestCase(node);
                checkForDoneCall(node);
            },
            ExpressionStatement: (node) => {
                if (currentSegment && currentSegment === doneSegment) {
                    report(node);
                }
                if (currentSegment && !segmentFirstStatement.has(currentSegment)) {
                    segmentFirstStatement.set(currentSegment, node);
                }
            },
            onCodePathSegmentStart(segment) {
                currentSegment = segment;
            },
            onCodePathEnd(_codePath, node) {
                currentSegment = undefined;
                if ((currentCase === null || currentCase === void 0 ? void 0 : currentCase.callback) === node && doneSegment) {
                    // we report an issue if one of 'doneSegment.nextSegments' is not empty
                    const statementAfterDone = doneSegment.nextSegments
                        .map(segment => segmentFirstStatement.get(segment))
                        .find(stmt => !!stmt);
                    if (statementAfterDone) {
                        report(statementAfterDone);
                    }
                }
            },
        };
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const programs = new Map();
({
    useCaseSensitiveFileNames: true,
    readDirectory: ts__default["default"].sys.readDirectory,
    fileExists: ts__default["default"].sys.fileExists,
    readFile: ts__default["default"].sys.readFile,
});
function getProgramById(programId) {
    const program = programs.get(programId);
    if (!program) {
        throw Error(`Failed to find program ${programId}`);
    }
    return program;
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
function buildParsingOptions(input, usingBabel = false, parserOption, sourceType = 'module') {
    const project = 'tsConfigs' in input ? input.tsConfigs : undefined;
    const programs = 'programId' in input ? [getProgramById(input.programId)] : undefined;
    const options = {
        tokens: true,
        comment: true,
        loc: true,
        range: true,
        ecmaVersion: 2018,
        sourceType,
        codeFrame: false,
        ecmaFeatures: {
            jsx: true,
            globalReturn: false,
            legacyDecorators: true,
        },
        // for Vue parser
        extraFileExtensions: ['.vue'],
        parser: parserOption,
        // for TS parser
        filePath: input.filePath,
        project,
        programs,
        // enable logs for @typescripteslint
        // debugLevel: true,
    };
    if (usingBabel) {
        return babelConfig(options);
    }
    return options;
}
var ParseExceptionCode;
(function (ParseExceptionCode) {
    ParseExceptionCode["Parsing"] = "PARSING";
    ParseExceptionCode["MissingTypeScript"] = "MISSING_TYPESCRIPT";
    ParseExceptionCode["UnsupportedTypeScript"] = "UNSUPPORTED_TYPESCRIPT";
    ParseExceptionCode["FailingTypeScript"] = "FAILING_TYPESCRIPT";
    ParseExceptionCode["GeneralError"] = "GENERAL_ERROR";
})(ParseExceptionCode || (ParseExceptionCode = {}));
function babelConfig(config) {
    const pluginPath = `${__dirname}/../node_modules`;
    const babelOptions = {
        presets: [
            `${pluginPath}/@babel/preset-react`,
            `${pluginPath}/@babel/preset-flow`,
            `${pluginPath}/@babel/preset-env`,
        ],
        babelrc: false,
        configFile: false,
    };
    return Object.assign(Object.assign({}, config), { requireConfigFile: false, babelOptions });
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const EXCLUDED_STATEMENTS = ['BreakStatement', 'LabeledStatement', 'ContinueStatement'];
const rule$1M = {
    meta: {
        messages: {
            commentedCode: 'Remove this commented out code.',
            commentedCodeFix: 'Remove this commented out code',
        },
        hasSuggestions: true,
    },
    create(context) {
        function getGroupedComments(comments) {
            const groupedComments = [];
            let currentGroup = [];
            for (const comment of comments) {
                if (comment.type === 'Block') {
                    groupedComments.push({ value: comment.value, nodes: [comment] });
                }
                else if (currentGroup.length === 0 ||
                    areAdjacentLineComments(currentGroup[currentGroup.length - 1], comment)) {
                    currentGroup.push(comment);
                }
                else {
                    groupedComments.push({
                        value: currentGroup.map(lineComment => lineComment.value).join('\n'),
                        nodes: currentGroup,
                    });
                    currentGroup = [comment];
                }
            }
            if (currentGroup.length > 0) {
                groupedComments.push({
                    value: currentGroup.map(lineComment => lineComment.value).join('\n'),
                    nodes: currentGroup,
                });
            }
            return groupedComments;
        }
        function areAdjacentLineComments(previous, next) {
            const nextCommentLine = next.loc.start.line;
            if (previous.loc.start.line + 1 === nextCommentLine) {
                const nextCodeToken = context.getSourceCode().getTokenAfter(previous);
                return !nextCodeToken || nextCodeToken.loc.start.line > nextCommentLine;
            }
            return false;
        }
        return {
            'Program:exit': () => {
                const groupedComments = getGroupedComments(context.getSourceCode().getAllComments());
                groupedComments.forEach(groupComment => {
                    const rawTextTrimmed = groupComment.value.trim();
                    if (rawTextTrimmed !== '}' && containsCode(injectMissingBraces(rawTextTrimmed))) {
                        context.report({
                            messageId: 'commentedCode',
                            loc: getCommentLocation(groupComment.nodes),
                            suggest: [
                                {
                                    messageId: 'commentedCodeFix',
                                    fix(fixer) {
                                        const start = groupComment.nodes[0].range[0];
                                        const end = groupComment.nodes[groupComment.nodes.length - 1].range[1];
                                        return fixer.removeRange([start, end]);
                                    },
                                },
                            ],
                        });
                    }
                });
            },
        };
    },
};
function isExpressionExclusion(statement, code) {
    if (statement.type === 'ExpressionStatement') {
        const expression = statement.expression;
        if (expression.type === 'Identifier' ||
            expression.type === 'SequenceExpression' ||
            isUnaryPlusOrMinus(expression) ||
            isExcludedLiteral(expression) ||
            !code.getLastToken(statement, token => token.value === ';')) {
            return true;
        }
    }
    return false;
}
function isExclusion(parsedBody, code) {
    if (parsedBody.length === 1) {
        const singleStatement = parsedBody[0];
        return (EXCLUDED_STATEMENTS.includes(singleStatement.type) ||
            isReturnThrowExclusion(singleStatement) ||
            isExpressionExclusion(singleStatement, code));
    }
    return false;
}
function containsCode(value) {
    try {
        const options = buildParsingOptions({ filePath: 'some/filePath', tsConfigs: [], fileContent: '', fileType: 'MAIN' }, true);
        const result = babel__namespace.parse(value, options);
        const parseResult = new eslint.SourceCode(value, result);
        return parseResult.ast.body.length > 0 && !isExclusion(parseResult.ast.body, parseResult);
    }
    catch (exception) {
        return false;
    }
}
function injectMissingBraces(value) {
    const openCurlyBraceNum = (value.match(/{/g) || []).length;
    const closeCurlyBraceNum = (value.match(/}/g) || []).length;
    const missingBraces = openCurlyBraceNum - closeCurlyBraceNum;
    if (missingBraces > 0) {
        return value + Array(missingBraces).fill('}').join('');
    }
    else if (missingBraces < 0) {
        return Array(-missingBraces).fill('{').join('') + value;
    }
    else {
        return value;
    }
}
function getCommentLocation(nodes) {
    return {
        start: nodes[0].loc.start,
        end: nodes[nodes.length - 1].loc.end,
    };
}
function isReturnThrowExclusion(statement) {
    if (statement.type === 'ReturnStatement' || statement.type === 'ThrowStatement') {
        return statement.argument == null || statement.argument.type === 'Identifier';
    }
    return false;
}
function isUnaryPlusOrMinus(expression) {
    return (expression.type === 'UnaryExpression' &&
        (expression.operator === '+' || expression.operator === '-'));
}
function isExcludedLiteral(expression) {
    if (expression.type === 'Literal') {
        return typeof expression.value === 'string' || typeof expression.value === 'number';
    }
    return false;
}

function lva(liveVariablesMap) {
    const worklist = Array.from(liveVariablesMap.values(), lva => lva.segment);
    while (worklist.length > 0) {
        const current = worklist.pop();
        const liveVariables = liveVariablesMap.get(current.id);
        const liveInHasChanged = liveVariables.propagate(liveVariablesMap);
        if (liveInHasChanged) {
            current.prevSegments.forEach(prev => worklist.push(prev));
        }
    }
}
class LiveVariables {
    constructor(segment) {
        /**
         * variables that are being read in the block
         */
        this.gen = new Set();
        /**
         * variables that are being written in the block
         */
        this.kill = new Set();
        /**
         * variables needed by this or a successor block and are not killed in this block
         */
        this.in = new Set();
        /**
         * variables needed by successors
         */
        this.out = new Set();
        /**
         * collects references in order they are evaluated, set in JS maintains insertion order
         */
        this.references = new Set();
        this.segment = segment;
    }
    add(ref) {
        const variable = ref.resolved;
        if (variable) {
            if (ref.isRead()) {
                this.gen.add(variable);
            }
            if (ref.isWrite()) {
                this.kill.add(variable);
            }
            this.references.add(ref);
        }
    }
    propagate(liveVariablesMap) {
        this.out.clear();
        this.segment.nextSegments.forEach(next => {
            liveVariablesMap.get(next.id).in.forEach(v => this.out.add(v));
        });
        const newIn = union(this.gen, difference(this.out, this.kill));
        if (!equals(this.in, newIn)) {
            this.in = newIn;
            return true;
        }
        else {
            return false;
        }
    }
}
function difference(a, b) {
    return new Set([...a].filter(e => !b.has(e)));
}
function union(a, b) {
    return new Set([...a, ...b]);
}
function equals(a, b) {
    return a.size === b.size && [...a].every(e => b.has(e));
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$1L = {
    meta: {
        messages: {
            removeAssignment: 'Remove this useless assignment to variable "{{variable}}".',
        },
    },
    create(context) {
        const codePathStack = [];
        const liveVariablesMap = new Map();
        const readVariables = new Set();
        // map from Variable to CodePath ids where variable is used
        const variableUsages = new Map();
        const referencesUsedInDestructuring = new Set();
        const destructuringStack = [];
        return {
            ':matches(AssignmentExpression, VariableDeclarator[init])': (node) => {
                pushAssignmentContext(node);
            },
            ':matches(AssignmentExpression, VariableDeclarator[init]):exit': () => {
                popAssignmentContext();
            },
            Identifier: (node) => {
                if (isEnumConstant()) {
                    return;
                }
                checkIdentifierUsage(node);
            },
            JSXIdentifier: (node) => {
                checkIdentifierUsage(node);
            },
            ObjectPattern: () => {
                destructuringStack.push(new DestructuringContext());
            },
            'ObjectPattern > Property > Identifier': (node) => {
                const destructuring = peek$1(destructuringStack);
                const { ref } = resolveReference(node);
                if (ref) {
                    destructuring.references.push(ref);
                }
            },
            'ObjectPattern > :matches(RestElement, ExperimentalRestProperty)': () => {
                peek$1(destructuringStack).hasRest = true;
            },
            'ObjectPattern:exit': () => {
                const destructuring = destructuringStack.pop();
                if (destructuring && destructuring.hasRest) {
                    destructuring.references.forEach(ref => referencesUsedInDestructuring.add(ref));
                }
            },
            'Program:exit': () => {
                lva(liveVariablesMap);
                liveVariablesMap.forEach(lva => {
                    checkSegment(lva);
                    reportNeverReadVariables(lva);
                });
            },
            // CodePath events
            onCodePathSegmentStart: (segment) => {
                liveVariablesMap.set(segment.id, new LiveVariables(segment));
            },
            onCodePathStart: codePath => {
                pushContext(new CodePathContext$1(codePath));
            },
            onCodePathEnd: () => {
                popContext();
            },
        };
        function pushAssignmentContext(node) {
            peek$1(codePathStack).assignmentStack.push(new AssignmentContext$1(node));
        }
        function popAssignmentContext() {
            const assignment = peek$1(codePathStack).assignmentStack.pop();
            assignment.rhs.forEach(r => processReference(r));
            assignment.lhs.forEach(r => processReference(r));
        }
        function checkSegment(liveVariables) {
            const willBeRead = new Set(liveVariables.out);
            const references = [...liveVariables.references].reverse();
            references.forEach(ref => {
                const variable = ref.resolved;
                if (!variable) {
                    return;
                }
                if (ref.isWrite()) {
                    if (!willBeRead.has(variable) && shouldReport(ref)) {
                        report(ref);
                    }
                    willBeRead.delete(variable);
                }
                if (ref.isRead()) {
                    willBeRead.add(variable);
                }
            });
        }
        function reportNeverReadVariables(lva) {
            lva.references.forEach(ref => {
                if (shouldReportReference(ref) && !readVariables.has(ref.resolved)) {
                    report(ref);
                }
            });
        }
        function shouldReport(ref) {
            const variable = ref.resolved;
            return (variable &&
                shouldReportReference(ref) &&
                !variableUsedOutsideOfCodePath(variable) &&
                readVariables.has(variable));
        }
        function shouldReportReference(ref) {
            const variable = ref.resolved;
            return (variable &&
                isLocalVar(variable) &&
                !isReferenceWithBasicValue(ref) &&
                !isDefaultParameter(ref) &&
                !referencesUsedInDestructuring.has(ref) &&
                !variable.name.startsWith('_'));
        }
        function isEnumConstant() {
            return context.getAncestors().some(n => n.type === 'TSEnumDeclaration');
        }
        function isDefaultParameter(ref) {
            if (ref.identifier.type !== 'Identifier') {
                return false;
            }
            const parent = ref.identifier.parent;
            return parent && parent.type === 'AssignmentPattern';
        }
        function isLocalVar(variable) {
            // @ts-ignore
            const scope = variable.scope;
            const node = scope.block;
            return node.type !== 'Program' && node.type !== 'TSModuleDeclaration';
        }
        function variableUsedOutsideOfCodePath(variable) {
            return variableUsages.get(variable).size > 1;
        }
        function isReferenceWithBasicValue(ref) {
            return ref.init && ref.writeExpr && isBasicValue(ref.writeExpr);
        }
        function isBasicValue(node) {
            const node1 = node;
            if (nodes.isLiteral(node1)) {
                return node1.value === '' || [0, 1, null, true, false].includes(node1.value);
            }
            if (nodes.isIdentifier(node1)) {
                return node1.name === 'undefined';
            }
            if (isUnaryExpression(node)) {
                return isBasicValue(node.argument);
            }
            if (nodes.isObjectExpression(node1)) {
                return node1.properties.length === 0;
            }
            if (isArrayExpression(node)) {
                return node.elements.length === 0;
            }
            return false;
        }
        function report(ref) {
            context.report({
                messageId: 'removeAssignment',
                data: {
                    variable: ref.identifier.name,
                },
                loc: ref.identifier.loc,
            });
        }
        function checkIdentifierUsage(node) {
            const { ref, variable } = node.type === 'Identifier' ? resolveReference(node) : resolveJSXReference(node);
            if (ref) {
                processReference(ref);
                if (variable) {
                    updateReadVariables(ref);
                }
            }
            if (variable) {
                updateVariableUsages(variable);
            }
        }
        function resolveJSXReference(node) {
            if (isJSXAttributeName(node)) {
                return {};
            }
            const jsxReference = new JSXReference(node, context.getScope());
            return { ref: jsxReference, variable: jsxReference.resolved };
        }
        function isJSXAttributeName(node) {
            const parent = node.parent;
            return parent && parent.type === 'JSXAttribute' && parent.name === node;
        }
        function processReference(ref) {
            const assignmentStack = peek$1(codePathStack).assignmentStack;
            if (assignmentStack.length > 0) {
                const assignment = peek$1(assignmentStack);
                assignment.add(ref);
            }
            else {
                peek$1(codePathStack).codePath.currentSegments.forEach(segment => {
                    lvaForSegment(segment).add(ref);
                });
            }
        }
        function lvaForSegment(segment) {
            let lva;
            if (liveVariablesMap.has(segment.id)) {
                lva = liveVariablesMap.get(segment.id);
            }
            else {
                lva = new LiveVariables(segment);
                liveVariablesMap.set(segment.id, lva);
            }
            return lva;
        }
        function updateReadVariables(reference) {
            const variable = reference.resolved;
            if (reference.isRead()) {
                readVariables.add(variable);
            }
        }
        function updateVariableUsages(variable) {
            const codePathId = peek$1(codePathStack).codePath.id;
            if (variableUsages.has(variable)) {
                variableUsages.get(variable).add(codePathId);
            }
            else {
                variableUsages.set(variable, new Set([codePathId]));
            }
        }
        function popContext() {
            codePathStack.pop();
        }
        function pushContext(codePathContext) {
            codePathStack.push(codePathContext);
        }
        function resolveReference(node) {
            return resolveReferenceRecursively(node, context.getScope());
        }
        function resolveReferenceRecursively(node, scope) {
            if (scope === null) {
                return { ref: null, variable: null };
            }
            const ref = scope.references.find(r => r.identifier === node);
            if (ref) {
                return { ref, variable: ref.resolved };
            }
            else {
                // if it's not a reference, it can be just declaration without initializer
                const variable = scope.variables.find(v => v.defs.find(def => def.name === node));
                if (variable) {
                    return { ref: null, variable };
                }
                // in theory we only need 1-level recursion, only for switch expression, which is likely a bug in eslint
                // generic recursion is used for safety & readability
                return resolveReferenceRecursively(node, scope.upper);
            }
        }
    },
};
class CodePathContext$1 {
    constructor(codePath) {
        this.liveVariablesMap = new Map();
        this.liveVariablesStack = [];
        this.segments = new Map();
        this.assignmentStack = [];
        this.codePath = codePath;
    }
}
class DestructuringContext {
    constructor() {
        this.hasRest = false;
        this.references = [];
    }
}
class AssignmentContext$1 {
    constructor(node) {
        this.lhs = new Set();
        this.rhs = new Set();
        this.node = node;
    }
    isRhs(node) {
        return nodes.isAssignmentExpression(this.node) ? this.node.right === node : this.node.init === node;
    }
    isLhs(node) {
        return nodes.isAssignmentExpression(this.node) ? this.node.left === node : this.node.id === node;
    }
    add(ref) {
        let parent = ref.identifier;
        while (parent) {
            if (this.isLhs(parent)) {
                this.lhs.add(ref);
                break;
            }
            if (this.isRhs(parent)) {
                this.rhs.add(ref);
                break;
            }
            parent = parent.parent;
        }
        if (parent === null) {
            throw new Error('failed to find assignment lhs/rhs');
        }
    }
}
class JSXReference {
    constructor(node, scope) {
        this.init = false;
        this.writeExpr = null;
        this.from = scope;
        this.identifier = node;
        this.resolved = findJSXVariableInScope(node, scope);
    }
    isRead() {
        return true;
    }
    isReadOnly() {
        return true;
    }
    isReadWrite() {
        return false;
    }
    isWrite() {
        return false;
    }
    isWriteOnly() {
        return false;
    }
}
function findJSXVariableInScope(node, scope) {
    return (scope &&
        (scope.variables.find(v => v.name === node.name) || findJSXVariableInScope(node, scope.upper)));
}
function peek$1(arr) {
    return arr[arr.length - 1];
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
// https://jira.sonarsource.com/browse/RSPEC-3001
const rule$1K = {
    meta: {
        messages: {
            removeDelete: 'Remove this "delete" operator or pass an object property to it.',
        },
    },
    create(context) {
        return {
            "UnaryExpression[operator='delete'][argument.type!='MemberExpression']": (node) => {
                const { argument } = node;
                if (!isGlobalProperty(argument, context.getScope().references)) {
                    context.report({
                        messageId: 'removeDelete',
                        node,
                    });
                }
            },
        };
    },
};
function isGlobalProperty(expr, references) {
    return (expr.type === 'Identifier' &&
        references.filter(ref => ref.identifier.name === expr.name && ref.resolved).length === 0);
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$1J = {
    meta: {
        hasSuggestions: true,
        schema: [
            {
                // internal parameter for rules having secondary locations
                enum: ['sonar-runtime'],
            },
        ],
    },
    create(context) {
        return {
            'TSUnionType, TSIntersectionType'(node) {
                const sourceCode = context.getSourceCode();
                const compositeType = node;
                const groupedTypes = new Map();
                compositeType.types.forEach(typescriptType => {
                    const nodeValue = sourceCode.getText(typescriptType);
                    const nodesWithGivenType = groupedTypes.get(nodeValue);
                    const nodeType = typescriptType;
                    if (!nodesWithGivenType) {
                        groupedTypes.set(nodeValue, [nodeType]);
                    }
                    else {
                        nodesWithGivenType.push(nodeType);
                    }
                });
                groupedTypes.forEach(duplicates => {
                    if (duplicates.length > 1) {
                        const suggest = getSuggestions$1(compositeType, duplicates, context);
                        const primaryNode = duplicates.splice(1, 1)[0];
                        const secondaryMessages = Array(duplicates.length);
                        secondaryMessages[0] = `Original`;
                        secondaryMessages.fill(`Another duplicate`, 1, duplicates.length);
                        context.report({
                            message: toEncodedMessage$1(`Remove this duplicated type or replace with another one.`, duplicates, secondaryMessages),
                            loc: primaryNode.loc,
                            suggest,
                        });
                    }
                });
            },
        };
    },
};
function getSuggestions$1(composite, duplicates, context) {
    const ranges = duplicates.slice(1).map(duplicate => {
        const idx = composite.types.indexOf(duplicate);
        return [
            getEnd(context, composite.types[idx - 1], composite),
            getEnd(context, duplicate, composite),
        ];
    });
    return [
        {
            desc: 'Remove duplicate types',
            fix: fixer => ranges.map(r => fixer.removeRange(r)),
        },
    ];
}
function getEnd(context, node, composite) {
    let end = node;
    while (true) {
        const nextToken = context.getSourceCode().getTokenAfter(end);
        if (nextToken && nextToken.value === ')' && nextToken.range[1] <= composite.range[1]) {
            end = nextToken;
        }
        else {
            break;
        }
    }
    return end.range[1];
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$1I = createRegExpRule(context => {
    return {
        onRegExpLiteralEnter: (node) => {
            node.pattern.alternatives.forEach(({ elements }) => checkElements(elements, context));
        },
    };
});
function report(quantifier, context) {
    const ending = quantifier.min === 1 ? '' : 's';
    const message = `Fix this reluctant quantifier that will only ever match ${quantifier.min} repetition${ending}.`;
    context.reportRegExpNode({
        message,
        regexpNode: quantifier,
        node: context.node,
    });
}
function checkElements(elements, context) {
    if (elements.length === 0) {
        return;
    }
    const lastElement = elements[elements.length - 1];
    if (lastElement.type === 'Quantifier' && !lastElement.greedy) {
        report(lastElement, context);
        return;
    }
    if (elements.length === 1) {
        return;
    }
    const lastButOneElement = elements[elements.length - 2];
    if (lastButOneElement.type === 'Quantifier' && !lastButOneElement.greedy) {
        if (lastElement.type === 'Assertion' && lastElement.kind === 'end') {
            context.reportRegExpNode({
                message: `Remove the '?' from this unnecessarily reluctant quantifier.`,
                regexpNode: lastButOneElement,
                node: context.node,
            });
        }
        else if (lastElement.type === 'Quantifier' && lastElement.min === 0) {
            report(lastButOneElement, context);
        }
    }
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$1H = createRegExpRule(context => {
    function checkAlternation(alternation) {
        const { alternatives: alts } = alternation;
        if (alts.length <= 1) {
            return;
        }
        for (let i = 0; i < alts.length; i++) {
            let alt = alts[i];
            if (alt.elements.length === 0 && !isLastEmptyInGroup(alt)) {
                context.reportRegExpNode({
                    message: 'Remove this empty alternative.',
                    regexpNode: alt,
                    offset: i === alts.length - 1 ? [-1, 0] : [0, 1],
                    node: context.node,
                });
            }
        }
    }
    return {
        onPatternEnter: checkAlternation,
        onGroupEnter: checkAlternation,
        onCapturingGroupEnter: checkAlternation,
    };
});
function isLastEmptyInGroup(alt) {
    const group = alt.parent;
    return ((group.type === 'Group' || group.type === 'CapturingGroup') &&
        last$1(group.alternatives) === alt &&
        group.parent.type !== 'Quantifier');
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$1G = createRegExpRule(context => {
    function checkEmptyGroup(group) {
        const { alternatives } = group;
        if (alternatives.every(alt => alt.elements.length === 0)) {
            context.reportRegExpNode({
                message: 'Remove this empty group.',
                node: context.node,
                regexpNode: group,
            });
        }
    }
    return {
        onGroupEnter: checkEmptyGroup,
        onCapturingGroupEnter: checkEmptyGroup,
    };
});

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const equalityOperator = ['!=', '=='];
const plusMinusOperator = ['+=', '-='];
const rule$1F = {
    meta: {
        messages: {
            replaceOperator: "Replace '{{operator}}' operator with one of '<=', '>=', '<', or '>' comparison operators.",
        },
    },
    create(context) {
        return {
            ForStatement: (node) => {
                const forStatement = node;
                if (!forStatement.test || !forStatement.update) {
                    return;
                }
                const completeForStatement = node;
                const condition = completeForStatement.test;
                if (isEquality(condition) &&
                    isUpdateIncDec(completeForStatement.update) &&
                    !isException(completeForStatement, context)) {
                    context.report({
                        messageId: 'replaceOperator',
                        data: {
                            operator: condition.operator,
                        },
                        node: condition,
                    });
                }
            },
        };
    },
};
function isEquality(expression) {
    return !!(expression.type === 'BinaryExpression' && equalityOperator.includes(expression.operator));
}
function isUpdateIncDec(expression) {
    if (isIncDec(expression) || expression.type === 'UpdateExpression') {
        return true;
    }
    else if (expression.type === 'SequenceExpression') {
        return expression.expressions.every(isUpdateIncDec);
    }
    return false;
}
function isIncDec(expression) {
    return !!(expression.type === 'AssignmentExpression' && plusMinusOperator.includes(expression.operator));
}
function isException(forStatement, context) {
    return (isNontrivialConditionException(forStatement) ||
        isTrivialIteratorException(forStatement, context));
}
function isNontrivialConditionException(forStatement) {
    //If we reach this point, we know that test is an equality kind
    const condition = forStatement.test;
    var counters = [];
    collectCounters(forStatement.update, counters);
    return condition.left.type !== 'Identifier' || !counters.includes(condition.left.name);
}
function collectCounters(expression, counters) {
    let counter = undefined;
    if (isIncDec(expression)) {
        counter = expression.left;
    }
    else if (expression.type === 'UpdateExpression') {
        counter = expression.argument;
    }
    else if (expression.type === 'SequenceExpression') {
        expression.expressions.forEach(e => collectCounters(e, counters));
    }
    if (counter && counter.type === 'Identifier') {
        counters.push(counter.name);
    }
}
function isTrivialIteratorException(forStatement, context) {
    const init = forStatement.init;
    const condition = forStatement.test;
    if (init && isNotEqual(condition)) {
        const updatedByOne = checkForUpdateByOne(forStatement.update, forStatement.body, context);
        if (updatedByOne !== 0) {
            const beginValue = getValue(init);
            const endValue = getValue(condition);
            return (beginValue !== undefined &&
                endValue !== undefined &&
                updatedByOne === Math.sign(endValue - beginValue));
        }
    }
    return false;
}
function isNotEqual(node) {
    return !!(node && node.type === 'BinaryExpression' && node.operator === '!=');
}
function checkForUpdateByOne(update, loopBody, context) {
    if (isUpdateByOne(update, loopBody, context)) {
        if (update.operator === '++' || update.operator === '+=') {
            return +1;
        }
        if (update.operator === '--' || update.operator === '-=') {
            return -1;
        }
    }
    return 0;
}
function isUpdateByOne(update, loopBody, context) {
    return ((update.type === 'UpdateExpression' && !isUsedInsideBody$1(update.argument, loopBody, context)) ||
        (isUpdateOnOneWithAssign(update) && !isUsedInsideBody$1(update.left, loopBody, context)));
}
function isUsedInsideBody$1(id, loopBody, context) {
    if (id.type === 'Identifier') {
        const variable = getVariableFromName(context, id.name);
        const bodyRange = loopBody.range;
        if (variable && bodyRange) {
            return variable.references.some(ref => isInBody(ref.identifier, bodyRange));
        }
    }
    return false;
}
function isInBody(id, bodyRange) {
    return id && id.range && id.range[0] > bodyRange[0] && id.range[1] < bodyRange[1];
}
function getValue(node) {
    if (isNotEqual(node)) {
        return getInteger(node.right);
    }
    else if (isOneVarDeclaration(node)) {
        const variable = node.declarations[0];
        return getInteger(variable.init);
    }
    else if (node.type === 'AssignmentExpression') {
        return getInteger(node.right);
    }
    return undefined;
}
function getInteger(node) {
    if (node && node.type === 'Literal' && typeof node.value === 'number') {
        return node.value;
    }
    return undefined;
}
function isOneVarDeclaration(node) {
    return node.type === 'VariableDeclaration' && node.declarations.length === 1;
}
function isUpdateOnOneWithAssign(expression) {
    if (isIncDec(expression)) {
        const right = expression.right;
        return right.type === 'Literal' && right.value === 1;
    }
    return false;
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$1E = {
    meta: {
        messages: {
            useForOf: 'Use "for...of" to iterate over this "{{iterable}}".',
        },
    },
    create(context) {
        const services = context.parserServices;
        if (!parserServices.isRequiredParserServices(services)) {
            return {};
        }
        return {
            ForInStatement: (node) => {
                const type = getTypeFromTreeNode$1(node.right, services);
                if (isIterable(type)) {
                    const iterable = type.symbol ? type.symbol.name : 'String';
                    context.report({
                        messageId: 'useForOf',
                        data: { iterable },
                        loc: context.getSourceCode().getFirstToken(node).loc,
                    });
                }
            },
        };
    },
};
function isIterable(type) {
    return isCollection(type) || isString(type);
}
function isCollection(type) {
    return (type.symbol !== undefined &&
        [
            'Array',
            'Int8Array',
            'Uint8Array',
            'Uint8ClampedArray',
            'Int16Array',
            'Uint16Array',
            'Int32Array',
            'Uint32Array',
            'Float32Array',
            'Float64Array',
            'BigInt64Array',
            'BigUint64Array',
            'Set',
            'Map',
        ].includes(type.symbol.name));
}
function isString(type) {
    return ((type.symbol !== undefined && type.symbol.name === 'String') ||
        (type.flags & ts__default["default"].TypeFlags.StringLike) !== 0);
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$1D = {
    meta: {
        messages: {
            blockedFunction: 'Do not use function declarations within blocks.',
        },
    },
    create(context) {
        return {
            ':not(FunctionDeclaration, FunctionExpression, ArrowFunctionExpression) > BlockStatement > FunctionDeclaration': (node) => {
                context.report({
                    messageId: 'blockedFunction',
                    loc: locations.getMainFunctionTokenLocation(node, getParent(context), context),
                });
            },
        };
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
// https://jira.sonarsource.com/browse/RSPEC-2990
const rule$1C = {
    meta: {
        hasSuggestions: true,
        messages: {
            removeThis: `Remove the use of "this".`,
            suggestRemoveThis: 'Remove "this"',
            suggestUseWindow: 'Replace "this" with "window" object',
        },
    },
    create(context) {
        return {
            'MemberExpression[object.type="ThisExpression"]'(node) {
                const memberExpression = node;
                const scopeType = context.getScope().variableScope.type;
                const isInsideClass = context
                    .getAncestors()
                    .some(ancestor => ancestor.type === 'ClassDeclaration' || ancestor.type === 'ClassExpression');
                if ((scopeType === 'global' || scopeType === 'module') && !isInsideClass) {
                    const suggest = [];
                    if (!memberExpression.computed) {
                        const propertyText = context.getSourceCode().getText(memberExpression.property);
                        suggest.push({
                            messageId: 'suggestRemoveThis',
                            fix: fixer => fixer.replaceText(node, propertyText),
                        }, {
                            messageId: 'suggestUseWindow',
                            fix: fixer => fixer.replaceText(memberExpression.object, 'window'),
                        });
                    }
                    context.report({
                        messageId: 'removeThis',
                        node: memberExpression.object,
                        suggest,
                    });
                }
            },
        };
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
// https://jira.sonarsource.com/browse/RSPEC-2137
const illegalNames = ['eval', 'arguments', 'undefined', 'NaN', 'Infinity'];
const getDeclarationIssue = (redeclareType) => (name) => ({
    messageId: 'forbidDeclaration',
    data: { symbol: name, type: redeclareType },
});
const getModificationIssue = (functionName) => ({
    messageId: 'removeModification',
    data: { symbol: functionName },
});
const rule$1B = {
    meta: {
        messages: {
            removeModification: 'Remove the modification of "{{symbol}}".',
            forbidDeclaration: 'Do not use "{{symbol}}" to declare a {{type}} - use another name.',
        },
    },
    create(context) {
        return {
            'FunctionDeclaration, FunctionExpression': function (node) {
                const func = node;
                reportBadUsageOnFunction(func, func.id, context);
            },
            ArrowFunctionExpression: function (node) {
                reportBadUsageOnFunction(node, undefined, context);
            },
            VariableDeclaration(node) {
                node.declarations.forEach(decl => {
                    reportBadUsage(decl.id, getDeclarationIssue('variable'), context);
                });
            },
            UpdateExpression(node) {
                reportBadUsage(node.argument, getModificationIssue, context);
            },
            AssignmentExpression(node) {
                reportBadUsage(node.left, getModificationIssue, context);
            },
            CatchClause(node) {
                reportBadUsage(node.param, getDeclarationIssue('variable'), context);
            },
        };
    },
};
function reportBadUsageOnFunction(func, id, context) {
    reportBadUsage(id, getDeclarationIssue('function'), context);
    func.params.forEach(p => {
        reportBadUsage(p, getDeclarationIssue('parameter'), context);
    });
}
function reportBadUsage(node, buildMessageAndData, context) {
    if (node) {
        switch (node.type) {
            case 'Identifier': {
                if (illegalNames.includes(node.name)) {
                    context.report(Object.assign({ node: node }, buildMessageAndData(node.name)));
                }
                break;
            }
            case 'RestElement':
                reportBadUsage(node.argument, buildMessageAndData, context);
                break;
            case 'ObjectPattern':
                node.properties.forEach(prop => {
                    if (prop.type === 'Property') {
                        reportBadUsage(prop.value, buildMessageAndData, context);
                    }
                    else {
                        reportBadUsage(prop.argument, buildMessageAndData, context);
                    }
                });
                break;
            case 'ArrayPattern':
                node.elements.forEach(elem => {
                    reportBadUsage(elem, buildMessageAndData, context);
                });
                break;
            case 'AssignmentPattern':
                reportBadUsage(node.left, buildMessageAndData, context);
                break;
        }
    }
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$1A = {
    meta: {
        messages: {
            reviewCredential: 'Review this potentially hardcoded credential.',
        },
    },
    create(context) {
        const variableNames = context.options;
        const literalRegExp = variableNames.map(name => new RegExp(`${name}=.+`));
        return {
            VariableDeclarator: (node) => {
                const declaration = node;
                checkAssignment(context, variableNames, declaration.id, declaration.init);
            },
            AssignmentExpression: (node) => {
                const assignment = node;
                checkAssignment(context, variableNames, assignment.left, assignment.right);
            },
            Property: (node) => {
                const property = node;
                checkAssignment(context, variableNames, property.key, property.value);
            },
            Literal: (node) => {
                const literal = node;
                checkLiteral(context, literalRegExp, literal);
            },
        };
    },
};
function checkAssignment(context, patterns, variable, initializer) {
    if (initializer &&
        isStringLiteral(initializer) &&
        initializer.value.length > 0 &&
        patterns.some(pattern => context.getSourceCode().getText(variable).includes(pattern))) {
        context.report({
            messageId: 'reviewCredential',
            node: initializer,
        });
    }
}
function checkLiteral(context, patterns, literal) {
    if (isStringLiteral(literal) && patterns.some(pattern => pattern.test(literal.value))) {
        context.report({
            messageId: 'reviewCredential',
            node: literal,
        });
    }
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const netMaskRegex = /(^[^\/]+)\/\d{1,3}$/;
const acceptedIpAddresses = ['255.255.255.255', '::1', '::', '0:0:0:0:0:0:0:1', '0:0:0:0:0:0:0:0'];
const rule$1z = {
    meta: {
        messages: {
            checkIP: 'Make sure using a hardcoded IP address {{ip}} is safe here.',
        },
    },
    create(context) {
        function isException(ip) {
            return (ip.startsWith('127.') ||
                ip.startsWith('0.') ||
                // avoid FP for OID http://www.oid-info.com/introduction.htm
                ip.startsWith('2.5') ||
                acceptedIpAddresses.includes(ip));
        }
        function isIPV4OctalOrHex(ip) {
            const digits = ip.split('.');
            if (digits.length !== 4) {
                return false;
            }
            const decimalDigits = [];
            for (const digit of digits) {
                if (digit.match(/^0[0-7]*$/)) {
                    decimalDigits.push(parseInt(digit, 8));
                }
                else if (digit.match(/^0[xX][0-9a-fA-F]+$/)) {
                    decimalDigits.push(parseInt(digit, 16));
                }
                else {
                    return false;
                }
            }
            const convertedIp = `${decimalDigits[0]}.${decimalDigits[1]}.${decimalDigits[2]}.${decimalDigits[3]}`;
            return !isException(convertedIp) && net.isIP(convertedIp) !== 0;
        }
        return {
            Literal(node) {
                const { value } = node;
                if (typeof value !== 'string') {
                    return;
                }
                let ip = value;
                const result = value.match(netMaskRegex);
                if (result) {
                    ip = result[1];
                }
                if ((!isException(ip) && net.isIP(ip) !== 0) || isIPV4OctalOrHex(ip)) {
                    context.report({
                        node,
                        messageId: 'checkIP',
                        data: {
                            ip: value,
                        },
                    });
                }
            },
        };
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const DefinitelyTyped = '@types/';
/**
 * Cache for each dirname the dependencies of the nearest package.json.
 */
const cache = new Map();
const rule$1y = {
    meta: {
        messages: {
            removeOrAddDependency: 'Either remove this import or add it as a dependency.',
        },
    },
    create(context) {
        const whitelist = context.options;
        const dependencies = getDependencies(context.getFilename());
        const aliasedPathsMappingPatterns = extractPathMappingPatterns(context.parserServices);
        if (aliasedPathsMappingPatterns === 'matchAll') {
            // deactivates this rule altogether.
            return {};
        }
        return {
            CallExpression: (node) => {
                const call = node;
                if (call.callee.type === 'Identifier' &&
                    call.callee.name === 'require' &&
                    call.arguments.length === 1) {
                    const [argument] = call.arguments;
                    if (argument.type === 'Literal') {
                        const requireToken = call.callee;
                        raiseOnImplicitImport(argument, requireToken.loc, dependencies, whitelist, aliasedPathsMappingPatterns, context);
                    }
                }
            },
            ImportDeclaration: (node) => {
                const module = node.source;
                const importToken = context.getSourceCode().getFirstToken(node);
                raiseOnImplicitImport(module, importToken.loc, dependencies, whitelist, aliasedPathsMappingPatterns, context);
            },
        };
    },
};
function raiseOnImplicitImport(module, loc, dependencies, whitelist, aliasedPathsMappingPatterns, context) {
    const moduleName = module.value;
    if (typeof moduleName !== 'string') {
        return;
    }
    if (ts__namespace.isExternalModuleNameRelative(moduleName)) {
        return;
    }
    if (aliasedPathsMappingPatterns.some(pattern => pattern.isApplicableTo(moduleName))) {
        return;
    }
    const packageName = getPackageName(moduleName);
    if (!whitelist.includes(packageName) &&
        !builtins__default["default"].includes(packageName) &&
        !dependencies.has(packageName)) {
        context.report({
            messageId: 'removeOrAddDependency',
            loc,
        });
    }
}
function getPackageName(name) {
    /*
      - scoped `@namespace/foo/bar` -> package `@namespace/foo`
      - scope `foo/bar` -> package `foo`
    */
    const parts = name.split('/');
    if (!name.startsWith('@')) {
        return parts[0];
    }
    else {
        return `${parts[0]}/${parts[1]}`;
    }
}
function getDependencies(fileName) {
    const dirname = path__namespace.dirname(fileName);
    const cached = cache.get(dirname);
    if (cached) {
        return cached;
    }
    const result = new Set();
    const packageJsonPath = findPackageJson(path__namespace.resolve(dirname));
    if (packageJsonPath !== undefined) {
        try {
            // remove BOM from file content before parsing
            const content = JSON.parse(fs__namespace.readFileSync(packageJsonPath, 'utf8').replace(/^\uFEFF/, ''));
            if (content.dependencies !== undefined) {
                addDependencies(result, content.dependencies);
            }
            if (content.devDependencies !== undefined) {
                addDependencies(result, content.devDependencies);
            }
            if (content.peerDependencies !== undefined) {
                addDependencies(result, content.peerDependencies);
            }
        }
        catch (_a) { }
    }
    cache.set(dirname, result);
    return result;
}
function addDependencies(result, dependencies) {
    Object.keys(dependencies).forEach(name => result.add(name.startsWith(DefinitelyTyped) ? name.substring(DefinitelyTyped.length) : name));
}
function findPackageJson(current) {
    const fileName = path__namespace.join(current, 'package.json');
    if (fs__namespace.existsSync(fileName)) {
        return fileName;
    }
    const prev = current;
    current = path__namespace.dirname(current);
    if (prev !== current) {
        return findPackageJson(current);
    }
    return undefined;
}
class PathMappingNoAsteriskPattern {
    constructor(value) {
        this.value = value;
    }
    isApplicableTo(name) {
        return name === this.value;
    }
}
class PathMappingSingleAsteriskPattern {
    constructor(prefix, suffix) {
        this.prefix = prefix;
        this.suffix = suffix;
    }
    isApplicableTo(name) {
        return name.startsWith(this.prefix) && name.endsWith(this.suffix);
    }
}
const PATH_MAPPING_ASTERISK_PATTERN = /^([^*]*)\*([^*]*)$/; // matches any string with single asterisk '*'
const PATH_MAPPING_ASTERISK_PATTERN_PREFIX_IDX = 1;
const PATH_MAPPING_ASTERISK_PATTERN_SUFFIX_IDX = 2;
function extractPathMappingPatterns(parserServices) {
    const compilerOptions = parserServices.program && parserServices.program.getCompilerOptions();
    const paths = (compilerOptions && compilerOptions.paths) || [];
    const pathMappingPatterns = [];
    for (const p in paths) {
        if (p === '*') {
            return 'matchAll';
        }
        else {
            const m = p.match(PATH_MAPPING_ASTERISK_PATTERN);
            if (m) {
                pathMappingPatterns.push(new PathMappingSingleAsteriskPattern(m[PATH_MAPPING_ASTERISK_PATTERN_PREFIX_IDX], m[PATH_MAPPING_ASTERISK_PATTERN_SUFFIX_IDX]));
            }
            else if (!p.includes('*')) {
                pathMappingPatterns.push(new PathMappingNoAsteriskPattern(p));
            }
            else ;
        }
    }
    return pathMappingPatterns;
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const excludedNames = new Set(flatMap(Object.values(globalsByLibraries), globals => globals));
const rule$1x = {
    meta: {
        messages: {
            explicitModifier: 'Add the "let", "const" or "var" keyword to this declaration of "{{variable}}" to make it explicit.',
        },
    },
    create(context) {
        return {
            'Program:exit'() {
                const globalScope = context.getScope();
                const alreadyReported = new Set();
                globalScope.through
                    .filter(ref => ref.isWrite())
                    .forEach(ref => {
                    const name = ref.identifier.name;
                    if (!alreadyReported.has(name) && !excludedNames.has(name)) {
                        alreadyReported.add(name);
                        context.report({
                            messageId: 'explicitModifier',
                            data: {
                                variable: name,
                            },
                            node: ref.identifier,
                        });
                    }
                });
            },
        };
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$1w = {
    meta: {
        hasSuggestions: true,
        messages: {
            inMisuse: 'Use "indexOf" or "includes" (available from ES2016) instead.',
            suggestIndexOf: 'Replace with "indexOf" method',
            suggestIncludes: 'Replace with "includes" method',
        },
    },
    create(context) {
        const services = context.parserServices;
        function prototypeProperty(node) {
            const expr = node;
            if (!nodes.isLiteral(expr) || typeof expr.value !== 'string') {
                return false;
            }
            return ['indexOf', 'lastIndexOf', 'forEach', 'map', 'filter', 'every', 'some'].includes(expr.value);
        }
        if (parserServices.isRequiredParserServices(services)) {
            return {
                "BinaryExpression[operator='in']": (node) => {
                    const { left, right } = node;
                    if (isArray(right, services) && !prototypeProperty(left) && !isNumber$1(left, services)) {
                        const leftText = context.getSourceCode().getText(left);
                        const rightText = context.getSourceCode().getText(right);
                        context.report({
                            messageId: 'inMisuse',
                            node,
                            suggest: [
                                {
                                    messageId: 'suggestIndexOf',
                                    fix: fixer => fixer.replaceText(node, `${rightText}.indexOf(${leftText}) > -1`),
                                },
                                {
                                    messageId: 'suggestIncludes',
                                    fix: fixer => fixer.replaceText(node, `${rightText}.includes(${leftText})`),
                                },
                            ],
                        });
                    }
                },
            };
        }
        return {};
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const assertionFunctions = [
    'a',
    'an',
    'include',
    'includes',
    'contain',
    'contains',
    'equal',
    'equals',
    'eq',
    'eql',
    'eqls',
    'above',
    'gt',
    'greaterThan',
    'least',
    'gte',
    'below',
    'lt',
    'lessThan',
    'most',
    'lte',
    'within',
    'instanceof',
    'instanceOf',
    'property',
    'ownPropertyDescriptor',
    'haveOwnPropertyDescriptor',
    'lengthOf',
    'length',
    'match',
    'matches',
    'string',
    'key',
    'keys',
    'throw',
    'throws',
    'Throw',
    'respondTo',
    'respondsTo',
    'satisfy',
    'satisfies',
    'closeTo',
    'approximately',
    'members',
    'oneOf',
    'change',
    'changes',
    'increase',
    'increases',
    'decrease',
    'decreases',
    'by',
    'fail',
];
const gettersOrModifiers = [
    'to',
    'be',
    'been',
    'is',
    'that',
    'which',
    'and',
    'has',
    'have',
    'with',
    'at',
    'of',
    'same',
    'but',
    'does',
    'still',
    // Modifier functions
    'not',
    'deep',
    'nested',
    'own',
    'ordered',
    'any',
    'all',
    'itself',
    'should',
];
const rule$1v = {
    create(context) {
        return {
            ExpressionStatement(node) {
                const exprStatement = node;
                if (exprStatement.expression.type === 'MemberExpression') {
                    const { property } = exprStatement.expression;
                    if (isTestAssertion(exprStatement.expression)) {
                        if (isIdentifier(property, ...assertionFunctions)) {
                            context.report({
                                node: property,
                                message: `Call this '${property.name}' assertion.`,
                            });
                        }
                        if (isIdentifier(property, ...gettersOrModifiers)) {
                            context.report({
                                node: property,
                                message: `Complete this assertion; '${property.name}' doesn't assert anything by itself.`,
                            });
                        }
                    }
                }
                if (isExpectCall(exprStatement.expression)) {
                    const { callee } = exprStatement.expression;
                    context.report({
                        node: callee,
                        message: `Complete this assertion; '${callee.name}' doesn't assert anything by itself.`,
                    });
                }
            },
        };
    },
};
function isTestAssertion(node) {
    const { object, property } = node;
    // Chai's BDD style where 'should' extends Object.prototype https://www.chaijs.com/guide/styles/
    if (isIdentifier(object) && isIdentifier(property, 'should')) {
        return true;
    }
    if (isExpectCall(object) || isIdentifier(object, 'assert', 'expect', 'should')) {
        return true;
    }
    else if (object.type === 'MemberExpression') {
        return isTestAssertion(object);
    }
    else if (object.type === 'CallExpression' && object.callee.type === 'MemberExpression') {
        return isTestAssertion(object.callee);
    }
    return false;
}
function isExpectCall(node) {
    return (node.type === 'CallExpression' &&
        isIdentifier(node.callee, 'expect') &&
        !isNumberLiteral(node.arguments[0]));
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$1u = {
    meta: {
        schema: [
            {
                // internal parameter for rules having secondary locations
                enum: ['sonar-runtime'],
            },
        ],
    },
    create(context) {
        const sourceCode = context.getSourceCode();
        const functionContextStack = [];
        const checkOnFunctionExit = (node) => checkFunctionLikeDeclaration(node, functionContextStack[functionContextStack.length - 1]);
        function checkFunctionLikeDeclaration(node, functionContext) {
            if (!functionContext ||
                (!!node.returnType &&
                    declaredReturnTypeContainsVoidOrNeverTypes(node.returnType.typeAnnotation))) {
                return;
            }
            checkFunctionForImplicitReturn(functionContext);
            if (hasInconsistentReturns(functionContext)) {
                const [secondaryLocationsHolder, secondaryLocationMessages] = getSecondaryLocations(functionContext, node);
                const message = toEncodedMessage$1(`Refactor this function to use "return" consistently.`, secondaryLocationsHolder, secondaryLocationMessages);
                context.report({
                    message,
                    loc: locations.getMainFunctionTokenLocation(node, getParent(context), context),
                });
            }
        }
        function checkFunctionForImplicitReturn(functionContext) {
            // As this method is called at the exit point of a function definition, the current
            // segments are the ones leading to the exit point at the end of the function. If they
            // are reachable, it means there is an implicit return.
            functionContext.containsImplicitReturn = functionContext.codePath.currentSegments.some(segment => segment.reachable);
        }
        function getSecondaryLocations(functionContext, node) {
            const secondaryLocationsHolder = functionContext.returnStatements.slice();
            const secondaryLocationMessages = functionContext.returnStatements.map(returnStatement => returnStatement.argument ? 'Return with value' : 'Return without value');
            if (functionContext.containsImplicitReturn) {
                const closeCurlyBraceToken = sourceCode.getLastToken(node, token => token.value === '}');
                if (!!closeCurlyBraceToken) {
                    secondaryLocationsHolder.push(closeCurlyBraceToken);
                    secondaryLocationMessages.push('Implicit return without value');
                }
            }
            return [secondaryLocationsHolder, secondaryLocationMessages];
        }
        return {
            onCodePathStart(codePath) {
                functionContextStack.push({
                    codePath,
                    containsReturnWithValue: false,
                    containsReturnWithoutValue: false,
                    containsImplicitReturn: false,
                    returnStatements: [],
                });
            },
            onCodePathEnd() {
                functionContextStack.pop();
            },
            ReturnStatement(node) {
                const currentContext = functionContextStack[functionContextStack.length - 1];
                if (!!currentContext) {
                    const returnStatement = node;
                    currentContext.containsReturnWithValue =
                        currentContext.containsReturnWithValue || !!returnStatement.argument;
                    currentContext.containsReturnWithoutValue =
                        currentContext.containsReturnWithoutValue || !returnStatement.argument;
                    currentContext.returnStatements.push(returnStatement);
                }
            },
            'FunctionDeclaration:exit': checkOnFunctionExit,
            'FunctionExpression:exit': checkOnFunctionExit,
            'ArrowFunctionExpression:exit': checkOnFunctionExit,
        };
    },
};
function hasInconsistentReturns(functionContext) {
    return (functionContext.containsReturnWithValue &&
        (functionContext.containsReturnWithoutValue || functionContext.containsImplicitReturn));
}
function declaredReturnTypeContainsVoidOrNeverTypes(returnTypeNode) {
    return (isVoidType(returnTypeNode) ||
        (returnTypeNode.type === 'TSUnionType' &&
            returnTypeNode.types.some(declaredReturnTypeContainsVoidOrNeverTypes)));
}
function isVoidType(typeNode) {
    return (typeNode.type === 'TSUndefinedKeyword' ||
        typeNode.type === 'TSVoidKeyword' ||
        typeNode.type === 'TSNeverKeyword');
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const message$2 = `Review this expression to be sure that the concatenation was intended.`;
const objectLikeTypes = new Set(['object', 'Object']);
const rule$1t = {
    meta: {
        schema: [
            {
                // internal parameter for rules having secondary locations
                enum: ['sonar-runtime'],
            },
        ],
    },
    create(context) {
        const services = context.parserServices;
        if (!parserServices.isRequiredParserServices(services)) {
            return {};
        }
        const checker = services.program.getTypeChecker();
        function isStringPlusNonString(type1, type2) {
            if (isLiteralType(type1) || isLiteralType(type2)) {
                return false;
            }
            const isObjectLike = objectLikeTypes.has(checker.typeToString(type2));
            // @ts-ignore private API, see https://github.com/microsoft/TypeScript/issues/9879
            return isStringType(type1) && !isObjectLike && !checker.isTypeAssignableTo(type1, type2);
        }
        function getOperatorLocation(left, right) {
            return context
                .getSourceCode()
                .getTokensBetween(left, right)
                .find(token => token.value === '+').loc;
        }
        return {
            'BinaryExpression[operator="+"]'(node) {
                const { left, right } = node;
                if (isStringLiteral(left) ||
                    isStringLiteral(right) ||
                    isConcatenation$1(left) ||
                    isConcatenation$1(right)) {
                    return;
                }
                const leftType = getTypeFromTreeNode$1(left, services);
                const rightType = getTypeFromTreeNode$1(right, services);
                if (isStringPlusNonString(leftType, rightType) ||
                    isStringPlusNonString(rightType, leftType)) {
                    context.report({
                        message: toEncodedMessage$1(message$2, [left, right], [
                            `left operand has type ${checker.typeToString(leftType)}.`,
                            `right operand has type ${checker.typeToString(rightType)}.`,
                        ]),
                        loc: getOperatorLocation(left, right),
                    });
                }
            },
        };
    },
};
function isStringType(typ) {
    return (typ.getFlags() & ts__namespace.TypeFlags.StringLike) !== 0;
}
function isLiteralType(type) {
    if (type.isUnion()) {
        return type.types.some(t => isLiteralType(t));
    }
    return type.isStringLiteral();
}
function isConcatenation$1(node) {
    return node.type === 'BinaryExpression' && node.operator === '+';
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const linter = new eslint.Linter();
const noUnmodifiedLoopEslint = interceptReport(linter.getRules().get('no-unmodified-loop-condition'), onReport);
const MESSAGE$1 = "Correct this loop's end condition to not be invariant.";
const rule$1s = {
    // we copy the meta to have proper messageId
    meta: noUnmodifiedLoopEslint.meta,
    create(context) {
        const noUnmodifiedLoopListener = noUnmodifiedLoopEslint.create(context);
        return {
            WhileStatement: (node) => {
                checkWhileStatement(node, context);
            },
            DoWhileStatement: (node) => {
                checkWhileStatement(node, context);
            },
            ForStatement: (node) => {
                const forStatement = node;
                if (!forStatement.test ||
                    (forStatement.test.type === 'Literal' && forStatement.test.value === true)) {
                    const hasEndCondition = LoopVisitor.hasEndCondition(forStatement.body, context);
                    if (!hasEndCondition) {
                        const firstToken = context.getSourceCode().getFirstToken(node);
                        context.report({
                            loc: firstToken.loc,
                            message: MESSAGE$1,
                        });
                    }
                }
            },
            'Program:exit'() {
                // @ts-ignore
                noUnmodifiedLoopListener['Program:exit']();
            },
        };
    },
};
function checkWhileStatement(node, context) {
    const whileStatement = node;
    if (whileStatement.test.type === 'Literal' && whileStatement.test.value === true) {
        const hasEndCondition = LoopVisitor.hasEndCondition(whileStatement.body, context);
        if (!hasEndCondition) {
            const firstToken = context.getSourceCode().getFirstToken(node);
            context.report({ loc: firstToken.loc, message: MESSAGE$1 });
        }
    }
}
function onReport(context, reportDescriptor) {
    if ('node' in reportDescriptor) {
        const node = reportDescriptor['node'];
        if (node.type === 'Identifier' && node.name === 'undefined') {
            return;
        }
        context.report(reportDescriptor);
    }
}
class LoopVisitor {
    constructor() {
        this.hasEndCondition = false;
    }
    static hasEndCondition(node, context) {
        const visitor = new LoopVisitor();
        visitor.visit(node, context);
        return visitor.hasEndCondition;
    }
    visit(root, context) {
        const visitNode = (node, isNestedLoop = false) => {
            switch (node.type) {
                case 'WhileStatement':
                case 'DoWhileStatement':
                case 'ForStatement':
                    isNestedLoop = true;
                    break;
                case 'FunctionExpression':
                case 'FunctionDeclaration':
                    // Don't consider nested functions
                    return;
                case 'BreakStatement':
                    if (!isNestedLoop || !!node.label) {
                        this.hasEndCondition = true;
                    }
                    break;
                case 'YieldExpression':
                case 'ReturnStatement':
                case 'ThrowStatement':
                    this.hasEndCondition = true;
                    return;
            }
            childrenOf$1(node, context.getSourceCode().visitorKeys).forEach(child => visitNode(child, isNestedLoop));
        };
        visitNode(root);
    }
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const permissions = ['geolocation', 'camera', 'microphone', 'notifications', 'persistent-storage'];
const rule$1r = {
    meta: {
        messages: {
            checkPermission: 'Make sure the use of the {{feature}} is necessary.',
        },
    },
    create(context) {
        return {
            'CallExpression[callee.type="MemberExpression"]'(node) {
                const call = node;
                const callee = call.callee;
                if (isNavigatorMemberExpression(callee, 'permissions', 'query') &&
                    call.arguments.length > 0) {
                    checkPermissions(context, call);
                    return;
                }
                if (context.options.includes('geolocation') &&
                    isNavigatorMemberExpression(callee, 'geolocation', 'watchPosition', 'getCurrentPosition')) {
                    context.report({
                        messageId: 'checkPermission',
                        data: {
                            feature: 'geolocation',
                        },
                        node: callee,
                    });
                    return;
                }
                if (isNavigatorMemberExpression(callee, 'mediaDevices', 'getUserMedia') &&
                    call.arguments.length > 0) {
                    const firstArg = getValueOfExpression(context, call.arguments[0], 'ObjectExpression');
                    checkForCameraAndMicrophonePermissions(context, callee, firstArg);
                    return;
                }
                if (context.options.includes('notifications') &&
                    isMemberExpression(callee, 'Notification', 'requestPermission')) {
                    context.report({
                        messageId: 'checkPermission',
                        data: {
                            feature: 'notifications',
                        },
                        node: callee,
                    });
                    return;
                }
                if (context.options.includes('persistent-storage') &&
                    isMemberExpression(callee.object, 'navigator', 'storage')) {
                    context.report({
                        messageId: 'checkPermission',
                        data: {
                            feature: 'persistent-storage',
                        },
                        node: callee,
                    });
                }
            },
            NewExpression(node) {
                const { callee } = node;
                if (context.options.includes('notifications') && isIdentifier(callee, 'Notification')) {
                    context.report({
                        messageId: 'checkPermission',
                        data: {
                            feature: 'notifications',
                        },
                        node: callee,
                    });
                }
            },
        };
    },
};
function checkForCameraAndMicrophonePermissions(context, callee, firstArg) {
    if (!firstArg) {
        return;
    }
    const shouldCheckAudio = context.options.includes('microphone');
    const shouldCheckVideo = context.options.includes('camera');
    if (!shouldCheckAudio && !shouldCheckVideo) {
        return;
    }
    const perms = [];
    for (const prop of firstArg.properties) {
        if (prop.type === 'Property') {
            const { value, key } = prop;
            if (isIdentifier(key, 'audio') && shouldCheckAudio && isOtherThanFalse(context, value)) {
                perms.push('microphone');
            }
            else if (isIdentifier(key, 'video') &&
                shouldCheckVideo &&
                isOtherThanFalse(context, value)) {
                perms.push('camera');
            }
        }
    }
    if (perms.length > 0) {
        context.report({
            messageId: 'checkPermission',
            data: {
                feature: perms.join(' and '),
            },
            node: callee,
        });
    }
}
function isOtherThanFalse(context, value) {
    const exprValue = getValueOfExpression(context, value, 'Literal');
    if (exprValue && exprValue.value === false) {
        return false;
    }
    return true;
}
function checkPermissions(context, call) {
    const firstArg = getValueOfExpression(context, call.arguments[0], 'ObjectExpression');
    if ((firstArg === null || firstArg === void 0 ? void 0 : firstArg.type) === 'ObjectExpression') {
        const nameProp = firstArg.properties.find(prop => hasNamePropertyWithPermission(prop, context));
        if (nameProp) {
            const { value } = nameProp.value;
            context.report({
                messageId: 'checkPermission',
                data: {
                    feature: String(value),
                },
                node: nameProp,
            });
        }
    }
}
function isNavigatorMemberExpression({ object, property }, firstProperty, ...secondProperty) {
    return (isMemberExpression(object, 'navigator', firstProperty) &&
        isIdentifier(property, ...secondProperty));
}
function hasNamePropertyWithPermission(prop, context) {
    if (prop.type === 'Property' && isIdentifier(prop.key, 'name')) {
        const value = getValueOfExpression(context, prop.value, 'Literal');
        return (value &&
            typeof value.value === 'string' &&
            permissions.includes(value.value) &&
            context.options.includes(value.value));
    }
    return false;
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$1q = {
    meta: {
        messages: {
            refactorAwait: "Refactor this redundant 'await' on a non-promise.",
        },
    },
    create(context) {
        const services = context.parserServices;
        if (parserServices.isRequiredParserServices(services)) {
            return {
                AwaitExpression: (node) => {
                    const awaitedType = getTypeFromTreeNode$1(node.argument, services);
                    if (!hasThenMethod(awaitedType) && !isAny(awaitedType) && !isUnion(awaitedType)) {
                        context.report({
                            messageId: 'refactorAwait',
                            node,
                        });
                    }
                },
            };
        }
        return {};
    },
};
function hasThenMethod(type) {
    var _a;
    const thenProperty = type.getProperty('then');
    return (_a = thenProperty === null || thenProperty === void 0 ? void 0 : thenProperty.declarations) === null || _a === void 0 ? void 0 : _a.some(d => d.kind === ts__namespace.SyntaxKind.MethodSignature || d.kind === ts__namespace.SyntaxKind.MethodDeclaration);
}
function isAny(type) {
    return Boolean(type.flags & ts__namespace.TypeFlags.Any);
}
function isUnion(type) {
    return Boolean(type.flags & ts__namespace.TypeFlags.Union);
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$1p = {
    meta: {
        schema: [
            {
                // internal parameter for rules having secondary locations
                enum: ['sonar-runtime'],
            },
        ],
    },
    create(context) {
        const functionContextStack = [];
        const checkOnFunctionExit = (node) => checkInvariantReturnStatements(node, functionContextStack[functionContextStack.length - 1]);
        function checkInvariantReturnStatements(node, functionContext) {
            if (!functionContext || hasDifferentReturnTypes(functionContext)) {
                return;
            }
            const returnedValues = functionContext.returnStatements.map(returnStatement => returnStatement.argument);
            if (areAllSameValue(returnedValues, context.getScope())) {
                const message = toEncodedMessage$1(`Refactor this function to not always return the same value.`, returnedValues, returnedValues.map(_ => 'Returned value.'), returnedValues.length);
                context.report({
                    message,
                    loc: locations.getMainFunctionTokenLocation(node, getParent(context), context),
                });
            }
        }
        return {
            onCodePathStart(codePath) {
                functionContextStack.push({
                    codePath,
                    containsReturnWithoutValue: false,
                    returnStatements: [],
                });
            },
            onCodePathEnd() {
                functionContextStack.pop();
            },
            ReturnStatement(node) {
                const currentContext = functionContextStack[functionContextStack.length - 1];
                if (currentContext) {
                    const returnStatement = node;
                    currentContext.containsReturnWithoutValue =
                        currentContext.containsReturnWithoutValue || !returnStatement.argument;
                    currentContext.returnStatements.push(returnStatement);
                }
            },
            'FunctionDeclaration:exit': checkOnFunctionExit,
            'FunctionExpression:exit': checkOnFunctionExit,
            'ArrowFunctionExpression:exit': checkOnFunctionExit,
        };
    },
};
function hasDifferentReturnTypes(functionContext) {
    // As this method is called at the exit point of a function definition, the current
    // segments are the ones leading to the exit point at the end of the function. If they
    // are reachable, it means there is an implicit return.
    const hasImplicitReturn = functionContext.codePath.currentSegments.some(segment => segment.reachable);
    return (hasImplicitReturn ||
        functionContext.containsReturnWithoutValue ||
        functionContext.returnStatements.length <= 1 ||
        functionContext.codePath.thrownSegments.length > 0);
}
function areAllSameValue(returnedValues, scope) {
    const firstReturnedValue = returnedValues[0];
    const firstValue = getLiteralValue(firstReturnedValue, scope);
    if (firstValue !== undefined) {
        return returnedValues
            .slice(1)
            .every(returnedValue => getLiteralValue(returnedValue, scope) === firstValue);
    }
    else if (firstReturnedValue.type === 'Identifier') {
        const singleWriteVariable = getSingleWriteDefinition(firstReturnedValue.name, scope);
        if (singleWriteVariable) {
            const readReferenceIdentifiers = singleWriteVariable.variable.references
                .slice(1)
                .map(ref => ref.identifier);
            return returnedValues.every(returnedValue => readReferenceIdentifiers.includes(returnedValue));
        }
    }
    return false;
}
function getSingleWriteDefinition(variableName, scope) {
    const variable = scope.set.get(variableName);
    if (variable) {
        const references = variable.references.slice(1);
        if (!references.some(ref => ref.isWrite() || isPossibleObjectUpdate(ref))) {
            let initExpression = null;
            if (variable.defs.length === 1 && variable.defs[0].type === 'Variable') {
                initExpression = variable.defs[0].node.init;
            }
            return { variable, initExpression };
        }
    }
    return null;
}
function isPossibleObjectUpdate(ref) {
    const expressionStatement = findFirstMatchingAncestor(ref.identifier, n => n.type === 'ExpressionStatement' || FUNCTION_NODES.includes(n.type));
    // To avoid FP, we consider method calls as write operations, since we do not know whether they will
    // update the object state or not.
    return (expressionStatement &&
        expressionStatement.type === 'ExpressionStatement' &&
        (isElementWrite(expressionStatement, ref) ||
            expressionStatement.expression.type === 'CallExpression'));
}
function getLiteralValue(returnedValue, scope) {
    if (returnedValue.type === 'Literal') {
        return returnedValue.value;
    }
    else if (returnedValue.type === 'UnaryExpression') {
        const innerReturnedValue = getLiteralValue(returnedValue.argument, scope);
        return innerReturnedValue !== undefined
            ? evaluateUnaryLiteralExpression(returnedValue.operator, innerReturnedValue)
            : undefined;
    }
    else if (returnedValue.type === 'Identifier') {
        const singleWriteVariable = getSingleWriteDefinition(returnedValue.name, scope);
        if (singleWriteVariable && singleWriteVariable.initExpression) {
            return getLiteralValue(singleWriteVariable.initExpression, scope);
        }
    }
    return undefined;
}
function evaluateUnaryLiteralExpression(operator, innerReturnedValue) {
    switch (operator) {
        case '-':
            return -Number(innerReturnedValue);
        case '+':
            return Number(innerReturnedValue);
        case '~':
            return ~Number(innerReturnedValue);
        case '!':
            return !Boolean(innerReturnedValue);
        case 'typeof':
            return typeof innerReturnedValue;
        default:
            return undefined;
    }
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$1o = {
    meta: {
        schema: [
            {
                // internal parameter for rules having secondary locations
                enum: ['sonar-runtime'],
            },
        ],
    },
    create(context) {
        return {
            CallExpression(node) {
                const call = node;
                const { callee, arguments: args } = call;
                if (isSensitiveFQN(context, call) && args.length > 0) {
                    const xfwdProp = getObjectExpressionProperty(args[0], 'xfwd');
                    if (!xfwdProp) {
                        return;
                    }
                    const xfwdValue = getValueOfExpression(context, xfwdProp.value, 'Literal');
                    if ((xfwdValue === null || xfwdValue === void 0 ? void 0 : xfwdValue.value) === true) {
                        context.report({
                            node: callee,
                            message: toEncodedMessage$1('Make sure forwarding client IP address is safe here.', [
                                xfwdProp,
                            ]),
                        });
                    }
                }
            },
        };
    },
};
function isSensitiveFQN(context, call) {
    var _a, _b;
    const { callee } = call;
    if (callee.type === 'MemberExpression') {
        return (isCallToFQN(context, call, 'http-proxy', 'createProxyServer') ||
            isCallToFQN(context, call, 'http-proxy-middleware', 'createProxyMiddleware'));
    }
    return ((isIdentifier(callee, 'createProxyServer') &&
        ((_a = getModuleNameOfNode(context, callee)) === null || _a === void 0 ? void 0 : _a.value) === 'http-proxy') ||
        (isIdentifier(callee, 'createProxyMiddleware') &&
            ((_b = getModuleNameOfNode(context, callee)) === null || _b === void 0 ? void 0 : _b.value) === 'http-proxy-middleware'));
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
// https://jira.sonarsource.com/browse/RSPEC-1119
const rule$1n = {
    meta: {
        messages: {
            removeLabel: 'Refactor the code to remove this label and the need for it.',
        },
    },
    create(context) {
        return {
            LabeledStatement(node) {
                const sourceCode = context.getSourceCode();
                context.report({
                    messageId: 'removeLabel',
                    loc: sourceCode.getFirstToken(node).loc,
                });
            },
        };
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const HELMET$4 = 'helmet';
const NO_SNIFF = 'noSniff';
const rule$1m = Express.SensitiveMiddlewarePropertyRule(findFalseNoSniffPropertyFromHelmet, `Make sure allowing browsers to sniff MIME types is safe here.`);
/**
 * Looks for property `noSniff: false` in node looking
 * somewhat similar to `helmet(<options>?)`, and returns it.
 */
function findFalseNoSniffPropertyFromHelmet(context, node) {
    var _a;
    let sensitive;
    const { callee, arguments: args } = node;
    if (callee.type === 'Identifier' &&
        ((_a = getModuleNameOfNode(context, callee)) === null || _a === void 0 ? void 0 : _a.value) === HELMET$4 &&
        args.length === 1 &&
        args[0].type === 'ObjectExpression') {
        sensitive = getPropertyWithValue(context, args[0], NO_SNIFF, false);
    }
    return sensitive ? [sensitive] : [];
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const arrayMutatingMethods = ['reverse', "'reverse'", '"reverse"', ...sortLike];
const rule$1l = {
    meta: {
        messages: {
            moveMethod: 'Move this array "{{method}}" operation to a separate statement.',
        },
    },
    create(context) {
        const services = context.parserServices;
        if (!parserServices.isRequiredParserServices(services)) {
            return {};
        }
        return {
            CallExpression(node) {
                const callee = node.callee;
                if (callee.type === 'MemberExpression') {
                    const propertyText = context.getSourceCode().getText(callee.property);
                    if (isArrayMutatingCall(callee, services, propertyText)) {
                        const mutatedArray = callee.object;
                        if (isIdentifierOrPropertyAccessExpression(mutatedArray, services) &&
                            !isInSelfAssignment(mutatedArray, node) &&
                            isForbiddenOperation(node)) {
                            context.report({
                                messageId: 'moveMethod',
                                data: {
                                    method: formatMethod(propertyText),
                                },
                                node,
                            });
                        }
                    }
                }
            },
        };
    },
};
function formatMethod(mutatingMethod) {
    if (mutatingMethod.startsWith('"') || mutatingMethod.startsWith("'")) {
        return mutatingMethod.substr(1, mutatingMethod.length - 2);
    }
    else {
        return mutatingMethod;
    }
}
function isArrayMutatingCall(memberExpression, services, propertyText) {
    return arrayMutatingMethods.includes(propertyText) && isArray(memberExpression.object, services);
}
function isIdentifierOrPropertyAccessExpression(node, services) {
    return (node.type === 'Identifier' ||
        (node.type === 'MemberExpression' && !isGetAccessor(node.property, services)));
}
function isGetAccessor(node, services) {
    const symbol = getSymbolAtLocation(node, services);
    const declarations = symbol && symbol.declarations;
    return (declarations !== undefined &&
        declarations.length === 1 &&
        declarations[0].kind === ts__namespace.SyntaxKind.GetAccessor);
}
function isInSelfAssignment(mutatedArray, node) {
    const parent = node.parent;
    return (
    // check assignment
    parent !== undefined &&
        parent.type === 'AssignmentExpression' &&
        parent.operator === '=' &&
        parent.left.type === 'Identifier' &&
        mutatedArray.type === 'Identifier' &&
        parent.left.name === mutatedArray.name);
}
function isForbiddenOperation(node) {
    return !isStandaloneExpression(node) && !isReturnedExpression(node);
}
function isStandaloneExpression(node) {
    const parent = node.parent;
    return (parent === null || parent === void 0 ? void 0 : parent.type) === 'ExpressionStatement';
}
function isReturnedExpression(node) {
    const ancestors = localAncestorsChain(node);
    const returnIdx = ancestors.findIndex(ancestor => ancestor.type === 'ReturnStatement');
    return (returnIdx > -1 &&
        ancestors
            .slice(0, returnIdx)
            .every(ancestor => ['ArrayExpression', 'ObjectExpression', 'ConditionalExpression', 'SpreadElement'].includes(ancestor.type)));
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const HELMET$3 = 'helmet';
const HELMET_CSP = 'helmet-csp';
const DIRECTIVES = 'directives';
const CONTENT_SECURITY_POLICY = 'contentSecurityPolicy';
const BLOCK_ALL_MIXED_CONTENT_CAMEL = 'blockAllMixedContent';
const BLOCK_ALL_MIXED_CONTENT_HYPHEN = 'block-all-mixed-content';
const rule$1k = Express.SensitiveMiddlewarePropertyRule(findDirectivesWithMissingMixedContentPropertyFromHelmet, `Make sure allowing mixed-content is safe here.`);
function findDirectivesWithMissingMixedContentPropertyFromHelmet(context, node) {
    let sensitive;
    const { arguments: args } = node;
    if (args.length === 1) {
        const [options] = args;
        const maybeDirectives = getObjectExpressionProperty(options, DIRECTIVES);
        if (maybeDirectives &&
            isMissingMixedContentProperty(maybeDirectives) &&
            isValidHelmetModuleCall(context, node)) {
            sensitive = maybeDirectives;
        }
    }
    return sensitive ? [sensitive] : [];
}
function isValidHelmetModuleCall(context, callExpr) {
    var _a;
    const { callee } = callExpr;
    /* csp(options) */
    if (callee.type === 'Identifier' && ((_a = getModuleNameOfNode(context, callee)) === null || _a === void 0 ? void 0 : _a.value) === HELMET_CSP) {
        return true;
    }
    /* helmet.contentSecurityPolicy(options) */
    return isCallToFQN(context, callExpr, HELMET$3, CONTENT_SECURITY_POLICY);
}
function isMissingMixedContentProperty(directives) {
    return !(Boolean(getObjectExpressionProperty(directives.value, BLOCK_ALL_MIXED_CONTENT_CAMEL)) ||
        Boolean(getObjectExpressionProperty(directives.value, BLOCK_ALL_MIXED_CONTENT_HYPHEN)));
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$1j = {
    meta: {
        messages: {
            extractAssignment: 'Extract the assignment of "{{symbol}}" from this expression.',
        },
    },
    create(context) {
        function isAssignmentStatement(parent) {
            return parent.type === 'ExpressionStatement';
        }
        function isEnclosingChain(parent) {
            return parent.type === 'AssignmentExpression';
        }
        function isEnclosingRelation(parent) {
            return (parent.type === 'BinaryExpression' &&
                ['==', '!=', '===', '!==', '<', '<=', '>', '>='].includes(parent.operator));
        }
        function isEnclosingSequence(parent) {
            return parent.type === 'SequenceExpression';
        }
        function isEnclosingDeclarator(parent) {
            return parent.type === 'VariableDeclarator';
        }
        function isLambdaBody(parent, expr) {
            return parent.type === 'ArrowFunctionExpression' && parent.body === expr;
        }
        function isConditionalAssignment(parent, expr) {
            return parent.type === 'LogicalExpression' && parent.right === expr;
        }
        function isWhileCondition(parent, expr) {
            return ((parent.type === 'DoWhileStatement' || parent.type === 'WhileStatement') &&
                parent.test === expr);
        }
        function isForInitOrUpdate(parent, expr) {
            return parent.type === 'ForStatement' && (parent.init === expr || parent.update === expr);
        }
        return {
            AssignmentExpression: (node) => {
                const assignment = node;
                const parent = getParent(context);
                if (parent &&
                    !isAssignmentStatement(parent) &&
                    !isEnclosingChain(parent) &&
                    !isEnclosingRelation(parent) &&
                    !isEnclosingSequence(parent) &&
                    !isEnclosingDeclarator(parent) &&
                    !isLambdaBody(parent, assignment) &&
                    !isConditionalAssignment(parent, assignment) &&
                    !isWhileCondition(parent, assignment) &&
                    !isForInitOrUpdate(parent, assignment)) {
                    raiseIssue(assignment, context);
                }
            },
        };
    },
};
function raiseIssue(node, context) {
    const sourceCode = context.getSourceCode();
    const operator = sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);
    const text = sourceCode.getText(node.left);
    context.report({
        messageId: 'extractAssignment',
        data: {
            symbol: text,
        },
        loc: operator.loc,
    });
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
// https://jira.sonarsource.com/browse/RSPEC-3358
const rule$1i = {
    meta: {
        messages: {
            extractTernary: 'Extract this nested ternary operation into an independent statement.',
        },
    },
    create(context) {
        return {
            'ConditionalExpression ConditionalExpression': (node) => {
                if (!isNestingBroken(context.getAncestors())) {
                    context.report({
                        messageId: 'extractTernary',
                        node,
                    });
                }
            },
        };
    },
};
function isNestingBroken(ancestors) {
    let parent = ancestors.pop();
    while (parent.type !== 'ConditionalExpression') {
        if (breaksNesting(parent)) {
            return true;
        }
        parent = ancestors.pop();
    }
    return false;
}
function breaksNesting(node) {
    return [
        'ArrayExpression',
        'ObjectExpression',
        'FunctionExpression',
        'ArrowFunctionExpression',
    ].includes(node.type);
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
// https://jira.sonarsource.com/browse/RSPEC-881
const rule$1h = {
    meta: {
        messages: {
            extractOperation: 'Extract this {{incrementType}} operation into a dedicated statement.',
        },
    },
    create(context) {
        function reportUpdateExpression(node) {
            context.report({
                messageId: 'extractOperation',
                data: {
                    incrementType: node.operator === '++' ? 'increment' : 'decrement',
                },
                node,
            });
        }
        return {
            UpdateExpression(node) {
                if (!isIgnored(node, context.getAncestors())) {
                    reportUpdateExpression(node);
                }
            },
        };
    },
};
function isIgnored(node, ancestors) {
    const firstAncestor = ancestors.pop();
    if (firstAncestor) {
        switch (firstAncestor.type) {
            case 'ExpressionStatement':
                return true;
            case 'ForStatement':
                return firstAncestor.update === node;
            case 'SequenceExpression': {
                const secondAncestor = ancestors.pop();
                return (secondAncestor !== undefined &&
                    secondAncestor.type === 'ForStatement' &&
                    secondAncestor.update === firstAncestor);
            }
        }
    }
    return false;
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
// https://jira.sonarsource.com/browse/RSPEC-4624
const message$1 = 'Refactor this code to not use nested template literals.';
const rule$1g = {
    create(context) {
        return {
            'TemplateLiteral TemplateLiteral': function (node) {
                context.report({
                    message: message$1,
                    node,
                });
            },
        };
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const SYMBOL = 'Symbol';
const rule$1f = {
    meta: {
        schema: [
            {
                // internal parameter for rules having secondary locations
                enum: ['sonar-runtime'],
            },
        ],
    },
    create(context) {
        function isSymbol(node) {
            return node.type === 'Identifier' && node.name === SYMBOL;
        }
        function isShadowed(_node) {
            const variable = getVariableFromName(context, SYMBOL);
            return variable && variable.defs.length > 0;
        }
        return {
            NewExpression: (node) => {
                const { callee } = node;
                if (isSymbol(callee) && !isShadowed()) {
                    const newToken = context
                        .getSourceCode()
                        .getFirstToken(node, token => token.value === 'new');
                    context.report({
                        message: toEncodedMessage$1(`Remove this "new" operator.`, [callee]),
                        loc: newToken.loc,
                    });
                }
            },
        };
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$1e = {
    meta: {
        messages: {
            noReassignment: 'Introduce a new variable or use its initial value before reassigning "{{reference}}".',
        },
    },
    create(context) {
        let variableUsageContext = {
            type: 'global',
            variablesToCheckInCurrentScope: new Set(),
            variablesToCheck: new Set(),
            variablesRead: new Set(),
            referencesByIdentifier: new Map(),
        };
        function checkIdentifierUsage(identifier, identifierContextType) {
            if (variableUsageContext.type !== identifierContextType) {
                return;
            }
            const variableName = identifier.name;
            const currentReference = getReference(variableUsageContext, identifier);
            if (currentReference &&
                !currentReference.init &&
                !variableUsageContext.variablesRead.has(variableName)) {
                if (variableUsageContext.variablesToCheck.has(variableName) &&
                    currentReference.isWriteOnly() &&
                    !isUsedInWriteExpression(variableName, currentReference.writeExpr)) {
                    // we do not raise issue when value is reassigned inside a top-level IfStatement, as it might be a shift or
                    // default value reassignment
                    if (isInsideTopLevelIfStatement(context) ||
                        context.getAncestors().some(node => node.type === 'SwitchCase') // issue-2398
                    ) {
                        return;
                    }
                    raiseIssue(currentReference);
                }
                markAsRead(variableUsageContext, variableName);
            }
            else if (variableName === 'arguments') {
                markAllFunctionArgumentsAsRead(variableUsageContext);
            }
        }
        function isUsedInWriteExpression(variableName, writeExpr) {
            return (writeExpr &&
                context
                    .getSourceCode()
                    .getFirstToken(writeExpr, token => token.value === variableName || token.value === 'arguments'));
        }
        function raiseIssue(reference) {
            const locationHolder = getPreciseLocationHolder(reference);
            context.report(Object.assign({ messageId: 'noReassignment', data: {
                    reference: reference.identifier.name,
                } }, locationHolder));
        }
        function popContext() {
            variableUsageContext = variableUsageContext.parentContext
                ? variableUsageContext.parentContext
                : variableUsageContext;
        }
        return {
            onCodePathStart(_codePath, node) {
                const currentScope = context.getScope();
                if (currentScope && currentScope.type === 'function') {
                    const { referencesByIdentifier, variablesToCheck, variablesToCheckInCurrentScope } = computeNewContextInfo(variableUsageContext, context, node);
                    const functionName = getFunctionName(node);
                    if (functionName) {
                        variablesToCheck.delete(functionName);
                    }
                    variableUsageContext = {
                        type: 'function',
                        parentContext: variableUsageContext,
                        variablesToCheck,
                        referencesByIdentifier,
                        variablesToCheckInCurrentScope,
                        variablesRead: computeSetDifference(variableUsageContext.variablesRead, variablesToCheckInCurrentScope),
                    };
                }
                else {
                    variableUsageContext = {
                        type: 'global',
                        parentContext: variableUsageContext,
                        variablesToCheckInCurrentScope: new Set(),
                        variablesToCheck: new Set(),
                        variablesRead: new Set(),
                        referencesByIdentifier: new Map(),
                    };
                }
            },
            onCodePathSegmentLoop(_fromSegment, _toSegment, node) {
                const parent = getParent(context);
                if (!isForEachLoopStart(node, parent)) {
                    return;
                }
                const currentScope = context.getSourceCode().scopeManager.acquire(parent.body);
                const { referencesByIdentifier, variablesToCheck, variablesToCheckInCurrentScope } = computeNewContextInfo(variableUsageContext, context, parent.left);
                if (currentScope) {
                    for (const ref of currentScope.references) {
                        referencesByIdentifier.set(ref.identifier, ref);
                    }
                }
                // In case of array or object pattern expression, the left hand side are not declared variables but simply identifiers
                resolveIdentifiers(parent.left, true)
                    .map(identifier => identifier.name)
                    .forEach(name => {
                    variablesToCheck.add(name);
                    variablesToCheckInCurrentScope.add(name);
                });
                variableUsageContext = {
                    type: 'foreach',
                    parentContext: variableUsageContext,
                    variablesToCheckInCurrentScope,
                    variablesToCheck,
                    variablesRead: computeSetDifference(variableUsageContext.variablesRead, variablesToCheckInCurrentScope),
                    referencesByIdentifier,
                };
            },
            onCodePathSegmentStart(_segment, node) {
                if (node.type !== 'CatchClause') {
                    return;
                }
                const { referencesByIdentifier, variablesToCheck, variablesToCheckInCurrentScope } = computeNewContextInfo(variableUsageContext, context, node);
                variableUsageContext = {
                    type: 'catch',
                    parentContext: variableUsageContext,
                    variablesToCheckInCurrentScope,
                    variablesToCheck,
                    variablesRead: computeSetDifference(variableUsageContext.variablesRead, variablesToCheckInCurrentScope),
                    referencesByIdentifier,
                };
            },
            onCodePathEnd: popContext,
            'ForInStatement:exit': popContext,
            'ForOfStatement:exit': popContext,
            'CatchClause:exit': popContext,
            '*:function > BlockStatement Identifier': (node) => checkIdentifierUsage(node, 'function'),
            'ForInStatement > *:statement Identifier': (node) => checkIdentifierUsage(node, 'foreach'),
            'ForOfStatement > *:statement Identifier': (node) => checkIdentifierUsage(node, 'foreach'),
            'CatchClause > BlockStatement Identifier': (node) => checkIdentifierUsage(node, 'catch'),
        };
    },
};
function isInsideTopLevelIfStatement(context) {
    const ifStatementParent = context.getAncestors().find(node => node.type === 'IfStatement');
    if (ifStatementParent) {
        return (hasParentOfType(ifStatementParent.parent, ['BlockStatement']) &&
            hasParentOfType(ifStatementParent.parent.parent, FUNCTION_NODES));
    }
    return false;
}
function hasParentOfType(parent, expectedType) {
    return !!parent && expectedType.includes(parent.type);
}
/**
 * Computes the set difference (a \ b)
 */
function computeSetDifference(a, b) {
    return new Set([...a].filter(str => !b.has(str)));
}
function getFunctionName(node) {
    return !node.id ? null : node.id.name;
}
function isForEachLoopStart(node, parent) {
    return (node.type === 'BlockStatement' &&
        !!parent &&
        (parent.type === 'ForInStatement' || parent.type === 'ForOfStatement'));
}
function computeNewContextInfo(variableUsageContext, context, node) {
    const referencesByIdentifier = new Map();
    const variablesToCheck = new Set(variableUsageContext.variablesToCheck);
    const variablesToCheckInCurrentScope = new Set();
    context.getDeclaredVariables(node).forEach(variable => {
        variablesToCheck.add(variable.name);
        variablesToCheckInCurrentScope.add(variable.name);
        for (const currentRef of variable.references) {
            referencesByIdentifier.set(currentRef.identifier, currentRef);
        }
    });
    return { referencesByIdentifier, variablesToCheck, variablesToCheckInCurrentScope };
}
function markAsRead(context, variableName) {
    context.variablesRead.add(variableName);
    if (!context.variablesToCheckInCurrentScope.has(variableName) && context.parentContext) {
        markAsRead(context.parentContext, variableName);
    }
}
function markAllFunctionArgumentsAsRead(variableUsageContext) {
    let functionContext = variableUsageContext;
    while (functionContext && functionContext.type !== 'function') {
        functionContext = functionContext.parentContext;
    }
    if (functionContext) {
        for (const variableName of functionContext.variablesToCheckInCurrentScope) {
            functionContext.variablesRead.add(variableName);
        }
    }
}
function getPreciseLocationHolder(reference) {
    const identifierLoc = reference.identifier.loc;
    if (identifierLoc && reference.writeExpr && reference.writeExpr.loc) {
        return { loc: { start: identifierLoc.start, end: reference.writeExpr.loc.end } };
    }
    return { node: reference.identifier };
}
function getReference(variableUsageContext, identifier) {
    const identifierReference = variableUsageContext.referencesByIdentifier.get(identifier);
    if (!identifierReference && variableUsageContext.parentContext) {
        return getReference(variableUsageContext.parentContext, identifier);
    }
    return identifierReference;
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
// https://jira.sonarsource.com/browse/RSPEC-1533
const WRAPPER_TYPES = ['Boolean', 'Number', 'String'];
const rule$1d = {
    meta: {
        hasSuggestions: true,
        messages: {
            removeConstructor: 'Remove this use of "{{constructor}}" constructor.',
            replaceWrapper: 'Replace this "{{wrapper}}" wrapper object with primitive type "{{primitive}}".',
            suggestRemoveNew: 'Remove "new" operator',
            suggestReplaceWrapper: 'Replace "{{wrapper}}" with "{{primitive}}"',
        },
    },
    create(context) {
        return {
            NewExpression(node) {
                const constructor = node.callee;
                if (constructor.type === 'Identifier' && WRAPPER_TYPES.includes(constructor.name)) {
                    const newToken = context
                        .getSourceCode()
                        .getFirstToken(node, token => token.value === 'new');
                    const [begin, end] = newToken.range;
                    context.report({
                        messageId: 'removeConstructor',
                        data: {
                            constructor: constructor.name,
                        },
                        node,
                        suggest: [
                            {
                                messageId: 'suggestRemoveNew',
                                fix: fixer => fixer.removeRange([begin, end + 1]),
                            },
                        ],
                    });
                }
            },
            TSTypeReference(node) {
                const typeString = context.getSourceCode().getText(node);
                if (WRAPPER_TYPES.includes(typeString)) {
                    const primitiveType = typeString.toLowerCase();
                    context.report({
                        messageId: 'replaceWrapper',
                        data: {
                            wrapper: typeString,
                            primitive: primitiveType,
                        },
                        node,
                        suggest: [
                            {
                                messageId: 'suggestReplaceWrapper',
                                data: {
                                    wrapper: typeString,
                                    primitive: primitiveType,
                                },
                                fix: fixer => fixer.replaceText(node, primitiveType),
                            },
                        ],
                    });
                }
            },
        };
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$1c = {
    meta: {
        messages: {
            reviewAssignment: 'Review this redundant assignment: "{{symbol}}" already holds the assigned value along all execution paths.',
        },
    },
    create(context) {
        const codePathStack = [];
        const reachingDefsMap = new Map();
        // map from Variable to CodePath ids where variable is used
        const variableUsages = new Map();
        return {
            ':matches(AssignmentExpression, VariableDeclarator[init])': (node) => {
                pushAssignmentContext(node);
            },
            ':matches(AssignmentExpression, VariableDeclarator[init]):exit': () => {
                popAssignmentContext();
            },
            Identifier: (node) => {
                if (isEnumConstant()) {
                    return;
                }
                checkIdentifierUsage(node);
            },
            'Program:exit': () => {
                reachingDefinitions(reachingDefsMap);
                reachingDefsMap.forEach(defs => {
                    checkSegment(defs);
                });
                reachingDefsMap.clear();
                variableUsages.clear();
                while (codePathStack.length > 0) {
                    codePathStack.pop();
                }
            },
            // CodePath events
            onCodePathSegmentStart: (segment) => {
                reachingDefsMap.set(segment.id, new ReachingDefinitions(segment));
            },
            onCodePathStart: codePath => {
                pushContext(new CodePathContext(codePath));
            },
            onCodePathEnd: () => {
                popContext();
            },
        };
        function popAssignmentContext() {
            const assignment = peek(codePathStack).assignmentStack.pop();
            assignment.rhs.forEach(r => processReference(r));
            assignment.lhs.forEach(r => processReference(r));
        }
        function pushAssignmentContext(node) {
            peek(codePathStack).assignmentStack.push(new AssignmentContext(node));
        }
        function checkSegment(reachingDefs) {
            const assignedValuesMap = new Map(reachingDefs.in);
            reachingDefs.references.forEach(ref => {
                const variable = ref.resolved;
                if (!variable || !ref.isWrite() || !shouldReport(ref)) {
                    return;
                }
                const lhsValues = assignedValuesMap.get(variable);
                const rhsValues = resolveAssignedValues(variable, ref.writeExpr, assignedValuesMap, ref.from);
                if ((lhsValues === null || lhsValues === void 0 ? void 0 : lhsValues.type) === 'AssignedValues' && (lhsValues === null || lhsValues === void 0 ? void 0 : lhsValues.size) === 1) {
                    const [lhsVal] = [...lhsValues];
                    checkRedundantAssignement(ref, ref.writeExpr, lhsVal, rhsValues, variable.name);
                }
                assignedValuesMap.set(variable, rhsValues);
            });
        }
        function checkRedundantAssignement({ resolved: variable }, node, lhsVal, rhsValues, name) {
            if (rhsValues.type === 'UnknownValue' || rhsValues.size !== 1) {
                return;
            }
            const [rhsVal] = [...rhsValues];
            if (!isWrittenOnlyOnce(variable) && lhsVal === rhsVal) {
                context.report({
                    node: node,
                    messageId: 'reviewAssignment',
                    data: {
                        symbol: name,
                    },
                });
            }
        }
        // to avoid raising on code like:
        // while (cond) {  let x = 42; }
        function isWrittenOnlyOnce(variable) {
            return variable.references.filter(ref => ref.isWrite()).length === 1;
        }
        function shouldReport(ref) {
            const variable = ref.resolved;
            return variable && shouldReportReference(ref) && !variableUsedOutsideOfCodePath(variable);
        }
        function shouldReportReference(ref) {
            const variable = ref.resolved;
            return (variable &&
                !isDefaultParameter(ref) &&
                !variable.name.startsWith('_') &&
                !isCompoundAssignment(ref.writeExpr) &&
                !isSelfAssignement(ref) &&
                !variable.defs.some(def => def.type === 'Parameter' || (def.type === 'Variable' && !def.node.init)));
        }
        function isEnumConstant() {
            return context.getAncestors().some(n => n.type === 'TSEnumDeclaration');
        }
        function variableUsedOutsideOfCodePath(variable) {
            return variableUsages.get(variable).size > 1;
        }
        function checkIdentifierUsage(node) {
            const { ref, variable } = resolveReference(node);
            if (ref) {
                processReference(ref);
            }
            if (variable) {
                updateVariableUsages(variable);
            }
        }
        function processReference(ref) {
            const assignmentStack = peek(codePathStack).assignmentStack;
            if (assignmentStack.length > 0) {
                const assignment = peek(assignmentStack);
                assignment.add(ref);
            }
            else {
                peek(codePathStack).codePath.currentSegments.forEach(segment => {
                    const reachingDefs = reachingDefsForSegment(segment);
                    reachingDefs.add(ref);
                });
            }
        }
        function reachingDefsForSegment(segment) {
            let defs;
            if (reachingDefsMap.has(segment.id)) {
                defs = reachingDefsMap.get(segment.id);
            }
            else {
                defs = new ReachingDefinitions(segment);
                reachingDefsMap.set(segment.id, defs);
            }
            return defs;
        }
        function updateVariableUsages(variable) {
            const codePathId = peek(codePathStack).codePath.id;
            if (variableUsages.has(variable)) {
                variableUsages.get(variable).add(codePathId);
            }
            else {
                variableUsages.set(variable, new Set([codePathId]));
            }
        }
        function pushContext(codePathContext) {
            codePathStack.push(codePathContext);
        }
        function popContext() {
            codePathStack.pop();
        }
        function resolveReferenceRecursively(node, scope) {
            if (scope === null) {
                return { ref: null, variable: null };
            }
            const ref = scope.references.find(r => r.identifier === node);
            if (ref) {
                return { ref, variable: ref.resolved };
            }
            else {
                // if it's not a reference, it can be just declaration without initializer
                const variable = scope.variables.find(v => v.defs.find(def => def.name === node));
                if (variable) {
                    return { ref: null, variable };
                }
                // in theory we only need 1-level recursion, only for switch expression, which is likely a bug in eslint
                // generic recursion is used for safety & readability
                return resolveReferenceRecursively(node, scope.upper);
            }
        }
        function resolveReference(node) {
            return resolveReferenceRecursively(node, context.getScope());
        }
    },
};
class CodePathContext {
    constructor(codePath) {
        this.reachingDefinitionsMap = new Map();
        this.reachingDefinitionsStack = [];
        this.segments = new Map();
        this.assignmentStack = [];
        this.codePath = codePath;
    }
}
class AssignmentContext {
    constructor(node) {
        this.lhs = new Set();
        this.rhs = new Set();
        this.node = node;
    }
    isRhs(node) {
        return nodes.isAssignmentExpression(this.node) ? this.node.right === node : this.node.init === node;
    }
    isLhs(node) {
        return nodes.isAssignmentExpression(this.node) ? this.node.left === node : this.node.id === node;
    }
    add(ref) {
        let parent = ref.identifier;
        while (parent) {
            if (this.isLhs(parent)) {
                this.lhs.add(ref);
                break;
            }
            if (this.isRhs(parent)) {
                this.rhs.add(ref);
                break;
            }
            parent = parent.parent;
        }
        if (parent === null) {
            throw new Error('failed to find assignment lhs/rhs');
        }
    }
}
function peek(arr) {
    return arr[arr.length - 1];
}
function isSelfAssignement(ref) {
    var _a;
    const lhs = ref.resolved;
    if (((_a = ref.writeExpr) === null || _a === void 0 ? void 0 : _a.type) === 'Identifier') {
        const rhs = getVariableFromIdentifier(ref.writeExpr, ref.from);
        return lhs === rhs;
    }
    return false;
}
function isCompoundAssignment(writeExpr) {
    if (writeExpr && writeExpr.hasOwnProperty('parent')) {
        const node = writeExpr.parent;
        return node && node.type === 'AssignmentExpression' && node.operator !== '=';
    }
    return false;
}
function isDefaultParameter(ref) {
    if (ref.identifier.type !== 'Identifier') {
        return false;
    }
    const parent = ref.identifier.parent;
    return parent && parent.type === 'AssignmentPattern';
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$1b = {
    meta: {
        hasSuggestions: true,
        schema: [
            {
                // internal parameter for rules having secondary locations
                enum: ['sonar-runtime'],
            },
        ],
    },
    create(context) {
        if (!parserServices.isRequiredParserServices(context.parserServices)) {
            return {};
        }
        function checkProperty(node) {
            const tsNode = node;
            const optionalToken = context
                .getSourceCode()
                .getFirstToken(node, token => token.value === '?');
            if (!tsNode.optional || !optionalToken) {
                return;
            }
            const typeNode = getUndefinedTypeAnnotation(tsNode.typeAnnotation);
            if (typeNode) {
                const suggest = getQuickFixSuggestions(context, optionalToken, typeNode);
                const secondaryLocations = [typeNode];
                const message = toEncodedMessage$1("Consider removing 'undefined' type or '?' specifier, one of them is redundant.", secondaryLocations);
                context.report({
                    message,
                    loc: optionalToken.loc,
                    suggest,
                });
            }
        }
        return {
            'PropertyDefinition, TSPropertySignature': (node) => checkProperty(node),
        };
    },
};
function getUndefinedTypeAnnotation(tsTypeAnnotation) {
    if (tsTypeAnnotation) {
        return getUndefinedTypeNode(tsTypeAnnotation.typeAnnotation);
    }
    return undefined;
}
function getUndefinedTypeNode(typeNode) {
    if (typeNode.type === 'TSUndefinedKeyword') {
        return typeNode;
    }
    else if (typeNode.type === 'TSUnionType') {
        return typeNode.types.map(getUndefinedTypeNode).find(tpe => tpe !== undefined);
    }
    return undefined;
}
function getQuickFixSuggestions(context, optionalToken, undefinedType) {
    var _a;
    const suggestions = [
        {
            desc: 'Remove "?" operator',
            fix: fixer => fixer.remove(optionalToken),
        },
    ];
    if (((_a = undefinedType.parent) === null || _a === void 0 ? void 0 : _a.type) === 'TSUnionType') {
        suggestions.push(getUndefinedRemovalSuggestion(context, undefinedType));
    }
    return suggestions;
}
function getUndefinedRemovalSuggestion(context, undefinedType) {
    return {
        desc: 'Remove "undefined" type annotation',
        fix: fixer => {
            const fixes = [];
            const unionType = undefinedType.parent;
            if (unionType.types.length === 2) {
                const unionTypeNode = unionType;
                const otherType = unionType.types[0] === undefinedType ? unionType.types[1] : unionType.types[0];
                const otherTypeText = context.getSourceCode().getText(otherType);
                fixes.push(fixer.replaceText(unionTypeNode, otherTypeText));
                const tokenBefore = context.getSourceCode().getTokenBefore(unionTypeNode);
                const tokenAfter = context.getSourceCode().getTokenAfter(unionTypeNode);
                if ((tokenBefore === null || tokenBefore === void 0 ? void 0 : tokenBefore.value) === '(' && (tokenAfter === null || tokenAfter === void 0 ? void 0 : tokenAfter.value) === ')') {
                    fixes.push(fixer.remove(tokenBefore));
                    fixes.push(fixer.remove(tokenAfter));
                }
            }
            else {
                const index = unionType.types.indexOf(undefinedType);
                if (index === 0) {
                    fixes.push(fixer.removeRange([undefinedType.range[0], unionType.types[1].range[0]]));
                }
                else {
                    fixes.push(fixer.removeRange([unionType.types[index - 1].range[1], undefinedType.range[1]]));
                }
            }
            return fixes;
        },
    };
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$1a = {
    meta: {
        schema: [
            {
                // internal parameter for rules having secondary locations
                enum: ['sonar-runtime'],
            },
        ],
        hasSuggestions: true,
    },
    create(context) {
        return {
            '*': function (node) {
                checkRedundantParentheses(context.getSourceCode(), node, context);
            },
        };
    },
};
function checkRedundantParentheses(sourceCode, node, context) {
    const parenthesesPairsAroundNode = getParenthesesPairsAround(sourceCode, node, node);
    const parent = getParent(context);
    // Ignore parentheses pair from the parent node
    if (!!parent && isInParentNodeParentheses(node, parent)) {
        parenthesesPairsAroundNode.pop();
    }
    // One pair of parentheses is allowed for readability purposes
    parenthesesPairsAroundNode.shift();
    parenthesesPairsAroundNode.forEach(parentheses => {
        context.report({
            message: toEncodedMessage$1(`Remove these useless parentheses.`, [
                parentheses.closingParenthesis,
            ]),
            loc: parentheses.openingParenthesis.loc,
            suggest: [
                {
                    desc: 'Remove these useless parentheses',
                    fix(fixer) {
                        return [
                            fixer.remove(parentheses.openingParenthesis),
                            fixer.remove(parentheses.closingParenthesis),
                        ];
                    },
                },
            ],
        });
    });
}
function getParenthesesPairsAround(sourceCode, start, end) {
    const tokenBefore = sourceCode.getTokenBefore(start);
    const tokenAfter = sourceCode.getTokenAfter(end);
    if (!!tokenBefore && !!tokenAfter && tokenBefore.value === '(' && tokenAfter.value === ')') {
        return [
            { openingParenthesis: tokenBefore, closingParenthesis: tokenAfter },
            ...getParenthesesPairsAround(sourceCode, tokenBefore, tokenAfter),
        ];
    }
    return [];
}
function isInParentNodeParentheses(node, parent) {
    const nodeIsInConditionOfParent = (parent.type === 'IfStatement' ||
        parent.type === 'WhileStatement' ||
        parent.type === 'DoWhileStatement') &&
        parent.test === node;
    const nodeIsArgumentOfCallExpression = (parent.type === 'CallExpression' || parent.type === 'NewExpression') &&
        parent.arguments.includes(node);
    return nodeIsInConditionOfParent || nodeIsArgumentOfCallExpression;
}

const rule$19 = {
    meta: {
        schema: [
            {
                // internal parameter for rules having secondary locations
                enum: ['sonar-runtime'],
            },
        ],
    },
    create(context) {
        const excludedNames = new Set();
        const undeclaredIdentifiersByName = new Map();
        return {
            'Program:exit'() {
                excludedNames.clear();
                undeclaredIdentifiersByName.clear();
                const globalScope = context.getScope();
                globalScope.through.forEach(ref => {
                    const identifier = ref.identifier;
                    if (excludedNames.has(identifier.name)) {
                        return;
                    }
                    if (ref.writeExpr ||
                        hasTypeOfOperator(identifier) ||
                        isWithinWithStatement(identifier)) {
                        excludedNames.add(identifier.name);
                        return;
                    }
                    const undeclaredIndentifiers = undeclaredIdentifiersByName.get(identifier.name);
                    if (!!undeclaredIndentifiers) {
                        undeclaredIndentifiers.push(identifier);
                    }
                    else {
                        undeclaredIdentifiersByName.set(identifier.name, [identifier]);
                    }
                });
                undeclaredIdentifiersByName.forEach((identifiers, name) => {
                    context.report({
                        node: identifiers[0],
                        message: toEncodedMessage$1(`\"${name}\" does not exist. Change its name or declare it so that its usage doesn't result in a \"ReferenceError\".`, identifiers.slice(1)),
                    });
                });
            },
        };
    },
};
function isWithinWithStatement(node) {
    return !!findFirstMatchingAncestor(node, ancestor => ancestor.type === 'WithStatement');
}
function hasTypeOfOperator(node) {
    const parent = node.parent;
    return (parent === null || parent === void 0 ? void 0 : parent.type) === 'UnaryExpression' && parent.operator === 'typeof';
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const HELMET$2 = 'helmet';
const POLICY = 'policy';
const REFERRER_POLICY = 'referrerPolicy';
const UNSAFE_REFERRER_POLICY_VALUES = ['', 'unsafe-url', 'no-referrer-when-downgrade'];
const rule$18 = Express.SensitiveMiddlewarePropertyRule(findNoReferrerPolicyPropertyFromHelmet, `Make sure disabling strict HTTP no-referrer policy is safe here.`);
function findNoReferrerPolicyPropertyFromHelmet(context, node) {
    let sensitive;
    const { callee, arguments: args } = node;
    if (args.length === 1) {
        const [options] = args;
        /* helmet({ referrerPolicy: false }) or helmet.referrerPolicy({ policy: <unsafe_value> }) */
        if (isHelmetModuleNode(context, callee) && options.type === 'ObjectExpression') {
            sensitive = getPropertyWithValue(context, options, REFERRER_POLICY, false);
        }
        else if (callee.type === 'MemberExpression') {
            const { object, property } = callee;
            if (isHelmetModuleNode(context, object) &&
                property.type === 'Identifier' &&
                property.name === REFERRER_POLICY) {
                const maybePolicy = getObjectExpressionProperty(options, POLICY);
                if (maybePolicy && !isSafePolicy(maybePolicy)) {
                    sensitive = maybePolicy;
                }
            }
        }
    }
    return sensitive ? [sensitive] : [];
}
function isHelmetModuleNode(context, node) {
    var _a;
    return node.type === 'Identifier' && ((_a = getModuleNameOfNode(context, node)) === null || _a === void 0 ? void 0 : _a.value) === HELMET$2;
}
function isSafePolicy(policy) {
    const { value } = policy;
    const values = value.type === 'ArrayExpression' ? value.elements : [value];
    const sensitiveValue = values.find(v => (v === null || v === void 0 ? void 0 : v.type) === 'Literal' &&
        typeof v.value === 'string' &&
        UNSAFE_REFERRER_POLICY_VALUES.includes(v.value));
    return !Boolean(sensitiveValue);
}

const rule$17 = {
    meta: {
        messages: {
            standardImport: 'Use a standard "import" statement instead of "{{adhocImport}}".',
        },
    },
    create(context) {
        const services = context.parserServices;
        if (!parserServices.isRequiredParserServices(services)) {
            return {};
        }
        return {
            'CallExpression[callee.type="Identifier"]': (node) => {
                if (context.getScope().type !== 'module' && context.getScope().type !== 'global') {
                    return;
                }
                const callExpression = node;
                const identifier = callExpression.callee;
                if (isAmdImport(callExpression, identifier, services) ||
                    isCommonJsImport(callExpression, identifier, services)) {
                    context.report({
                        node: identifier,
                        messageId: 'standardImport',
                        data: {
                            adhocImport: identifier.name,
                        },
                    });
                }
            },
        };
    },
};
function isCommonJsImport(callExpression, identifier, services) {
    return (callExpression.arguments.length === 1 &&
        isString$1(callExpression.arguments[0], services) &&
        identifier.name === 'require');
}
function isAmdImport(callExpression, identifier, services) {
    if (identifier.name !== 'require' && identifier.name !== 'define') {
        return false;
    }
    if (callExpression.arguments.length !== 2 && callExpression.arguments.length !== 3) {
        return false;
    }
    return isFunction$2(callExpression.arguments[callExpression.arguments.length - 1], services);
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$16 = {
    meta: {
        messages: {
            removeOrChangeType: 'Remove this return type or change it to a more specific.',
        },
    },
    create(context) {
        const services = context.parserServices;
        if (parserServices.isRequiredParserServices(services)) {
            const returnedExpressions = [];
            return {
                ReturnStatement(node) {
                    if (returnedExpressions.length > 0) {
                        returnedExpressions[returnedExpressions.length - 1].push(node.argument);
                    }
                },
                FunctionDeclaration: function () {
                    returnedExpressions.push([]);
                },
                'FunctionDeclaration:exit': function (node) {
                    const returnType = node.returnType;
                    if (returnType &&
                        returnType.typeAnnotation.type === 'TSAnyKeyword' &&
                        returnedExpressions.length > 0 &&
                        allReturnTypesEqual(returnedExpressions[returnedExpressions.length - 1], services)) {
                        context.report({
                            messageId: 'removeOrChangeType',
                            loc: returnType.loc,
                        });
                    }
                    returnedExpressions.pop();
                },
            };
        }
        return {};
    },
};
function allReturnTypesEqual(returns, services) {
    const firstReturnType = getTypeFromTreeNode(returns.pop(), services);
    if (!!firstReturnType && !!isPrimitiveType(firstReturnType)) {
        return returns.every(nextReturn => {
            const nextReturnType = getTypeFromTreeNode(nextReturn, services);
            return !!nextReturnType && nextReturnType.flags === firstReturnType.flags;
        });
    }
    return false;
}
function getTypeFromTreeNode(node, services) {
    const checker = services.program.getTypeChecker();
    return checker.getTypeAtLocation(services.esTreeNodeToTSNodeMap.get(node));
}
function isPrimitiveType({ flags }) {
    return (flags & ts__namespace.TypeFlags.BooleanLike ||
        flags & ts__namespace.TypeFlags.NumberLike ||
        flags & ts__namespace.TypeFlags.StringLike ||
        flags & ts__namespace.TypeFlags.EnumLike);
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$15 = {
    meta: {
        schema: [
            {
                // internal parameter for rules having secondary locations
                enum: ['sonar-runtime'],
            },
        ],
    },
    create(context) {
        if (!Chai.isImported(context)) {
            return {};
        }
        return {
            ExpressionStatement(node) {
                const { expression } = node;
                checkExpect(context, expression);
                checkShould(context, expression);
                checkAssert(context, expression);
            },
        };
    },
};
function checkAssert(context, expression) {
    if (expression.type === 'CallExpression') {
        const { callee, arguments: args } = expression;
        if (callee.type === 'MemberExpression' && isIdentifier(callee.object, 'assert')) {
            findDuplicates(context, args);
        }
    }
}
function checkExpect(context, expression) {
    let currentExpression = expression;
    let args = [];
    while (true) {
        if (currentExpression.type === 'CallExpression') {
            args = [...currentExpression.arguments, ...args];
            currentExpression = currentExpression.callee;
        }
        else if (currentExpression.type === 'MemberExpression') {
            currentExpression = currentExpression.object;
        }
        else if (isIdentifier(currentExpression, 'expect')) {
            break;
        }
        else {
            return;
        }
    }
    findDuplicates(context, args);
}
function checkShould(context, expression) {
    let currentExpression = expression;
    let args = [];
    let hasShould = false;
    while (true) {
        if (currentExpression.type === 'CallExpression') {
            args = [...currentExpression.arguments, ...args];
            currentExpression = currentExpression.callee;
        }
        else if (currentExpression.type === 'MemberExpression') {
            if (isIdentifier(currentExpression.property, 'should')) {
                hasShould = true;
            }
            currentExpression = currentExpression.object;
        }
        else if (isIdentifier(currentExpression, 'should')) {
            break;
        }
        else if (hasShould) {
            args = [currentExpression, ...args];
            break;
        }
        else {
            return;
        }
    }
    findDuplicates(context, args);
}
function findDuplicates(context, args) {
    const castedContext = context.getSourceCode();
    for (let i = 0; i < args.length; i++) {
        for (let j = i + 1; j < args.length; j++) {
            const duplicates = equivalence.areEquivalent(args[i], args[j], castedContext);
            if (duplicates && !isLiteral$2(args[i])) {
                const message = toEncodedMessage$1(`Replace this argument or its duplicate.`, [args[j]]);
                context.report({ message, node: args[i] });
            }
        }
    }
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
// https://jira.sonarsource.com/browse/RSPEC-105
const rule$14 = {
    meta: {
        messages: {
            replaceTab: 'Replace all tab characters in this file by sequences of white-spaces.',
        },
    },
    create(context) {
        return {
            'Program:exit': function () {
                const firstTab = context
                    .getSourceCode()
                    .lines.map((content, line) => ({ content, line }))
                    .find(t => t.content.includes('\t'));
                if (firstTab !== undefined) {
                    context.report({
                        messageId: 'replaceTab',
                        loc: { line: firstTab.line + 1, column: 0 },
                    });
                }
            },
        };
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$13 = {
    meta: {
        schema: [
            {
                // internal parameter for rules having secondary locations
                enum: ['sonar-runtime'],
            },
        ],
    },
    create(context) {
        const services = context.parserServices;
        if (parserServices.isRequiredParserServices(services)) {
            return {
                TryStatement: (node) => visitTryStatement(node, context, services),
            };
        }
        return {};
    },
};
function visitTryStatement(tryStmt, context, services) {
    if (tryStmt.handler) {
        // without '.catch()'
        const openPromises = [];
        // with '.catch()'
        const capturedPromises = [];
        let hasPotentiallyThrowingCalls = false;
        CallLikeExpressionVisitor.getCallExpressions(tryStmt.block, context).forEach(callLikeExpr => {
            if (callLikeExpr.type === 'AwaitExpression' ||
                !isThenable(callLikeExpr, services)) {
                hasPotentiallyThrowingCalls = true;
                return;
            }
            if (isAwaitLike(callLikeExpr) || isThened(callLikeExpr) || isCatch(callLikeExpr)) {
                return;
            }
            (isCaught(callLikeExpr) ? capturedPromises : openPromises).push(callLikeExpr);
        });
        if (!hasPotentiallyThrowingCalls) {
            checkForWrongCatch(tryStmt, openPromises, context);
            checkForUselessCatch(tryStmt, openPromises, capturedPromises, context);
        }
    }
}
class CallLikeExpressionVisitor {
    constructor() {
        this.callLikeExpressions = [];
    }
    static getCallExpressions(node, context) {
        const visitor = new CallLikeExpressionVisitor();
        visitor.visit(node, context);
        return visitor.callLikeExpressions;
    }
    visit(root, context) {
        const visitNode = (node) => {
            switch (node.type) {
                case 'AwaitExpression':
                case 'CallExpression':
                case 'NewExpression':
                    this.callLikeExpressions.push(node);
                    break;
                case 'FunctionDeclaration':
                case 'FunctionExpression':
                case 'ArrowFunctionExpression':
                    return;
            }
            childrenOf(node, context.getSourceCode().visitorKeys).forEach(visitNode);
        };
        visitNode(root);
    }
}
function checkForWrongCatch(tryStmt, openPromises, context) {
    if (openPromises.length > 0) {
        const ending = openPromises.length > 1 ? 's' : '';
        const message = `Consider using 'await' for the promise${ending} inside this 'try' or replace it with 'Promise.prototype.catch(...)' usage${ending}.`;
        const token = context.getSourceCode().getFirstToken(tryStmt);
        context.report({
            message: toEncodedMessage$1(message, openPromises, Array(openPromises.length).fill('Promise')),
            loc: token.loc,
        });
    }
}
function checkForUselessCatch(tryStmt, openPromises, capturedPromises, context) {
    if (openPromises.length === 0 && capturedPromises.length > 0) {
        const ending = capturedPromises.length > 1 ? 's' : '';
        const message = `Consider removing this 'try' statement as promise${ending} rejection is already captured by '.catch()' method.`;
        const token = context.getSourceCode().getFirstToken(tryStmt);
        context.report({
            message: toEncodedMessage$1(message, capturedPromises, Array(capturedPromises.length).fill('Caught promise')),
            loc: token.loc,
        });
    }
}
function isAwaitLike(callExpr) {
    return (callExpr.parent &&
        (callExpr.parent.type === 'AwaitExpression' || callExpr.parent.type === 'YieldExpression'));
}
function isThened(callExpr) {
    return (callExpr.parent &&
        callExpr.parent.type === 'MemberExpression' &&
        callExpr.parent.property.type === 'Identifier' &&
        callExpr.parent.property.name === 'then');
}
function isCaught(callExpr) {
    return (callExpr.parent &&
        callExpr.parent.type === 'MemberExpression' &&
        callExpr.parent.property.type === 'Identifier' &&
        callExpr.parent.property.name === 'catch');
}
function isCatch(callExpr) {
    return (callExpr.type === 'CallExpression' &&
        callExpr.callee.type === 'MemberExpression' &&
        callExpr.callee.property.type === 'Identifier' &&
        callExpr.callee.property.name === 'catch');
}
function childrenOf(node, visitorKeys) {
    const keys = visitorKeys[node.type];
    const children = [];
    if (keys) {
        for (const key of keys) {
            const child = node[key];
            if (Array.isArray(child)) {
                children.push(...child);
            }
            else {
                children.push(child);
            }
        }
    }
    return children.filter(Boolean);
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$12 = {
    meta: {
        hasSuggestions: true,
        messages: {
            removeUndefined: 'Remove this redundant "undefined".',
            suggestRemoveUndefined: 'Remove this redundant argument',
        },
    },
    create(context) {
        const services = context.parserServices;
        if (parserServices.isRequiredParserServices(services)) {
            return {
                CallExpression: (node) => {
                    const call = node;
                    const { arguments: args } = call;
                    if (args.length === 0) {
                        return;
                    }
                    const lastArgument = args[args.length - 1];
                    if (isUndefined$1(lastArgument) && isOptionalParameter(args.length - 1, call, services)) {
                        context.report({
                            messageId: 'removeUndefined',
                            node: lastArgument,
                            suggest: [
                                {
                                    messageId: 'suggestRemoveUndefined',
                                    fix: fixer => {
                                        if (call.arguments.length === 1) {
                                            const openingParen = context.getSourceCode().getTokenAfter(call.callee);
                                            const closingParen = context.getSourceCode().getLastToken(node);
                                            const [, begin] = openingParen.range;
                                            const [end] = closingParen.range;
                                            return fixer.removeRange([begin, end]);
                                        }
                                        else {
                                            const [, begin] = args[args.length - 2].range;
                                            const [, end] = lastArgument.range;
                                            return fixer.removeRange([begin, end]);
                                        }
                                    },
                                },
                            ],
                        });
                    }
                },
            };
        }
        return {};
    },
};
function isUndefined$1(node) {
    return node.type === 'Identifier' && node.name === 'undefined';
}
function isOptionalParameter(paramIndex, node, services) {
    const signature = services.program
        .getTypeChecker()
        .getResolvedSignature(services.esTreeNodeToTSNodeMap.get(node));
    if (signature) {
        const declaration = signature.declaration;
        if (declaration && isFunctionLikeDeclaration(declaration)) {
            const { parameters } = declaration;
            const parameter = parameters[paramIndex];
            return parameter && (parameter.initializer || parameter.questionToken);
        }
    }
    return false;
}
function isFunctionLikeDeclaration(declaration) {
    return [
        ts__namespace.SyntaxKind.FunctionDeclaration,
        ts__namespace.SyntaxKind.FunctionExpression,
        ts__namespace.SyntaxKind.ArrowFunction,
        ts__namespace.SyntaxKind.MethodDeclaration,
        ts__namespace.SyntaxKind.Constructor,
        ts__namespace.SyntaxKind.GetAccessor,
        ts__namespace.SyntaxKind.SetAccessor,
    ].includes(declaration.kind);
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
// https://jira.sonarsource.com/browse/RSPEC-2138
const rule$11 = {
    meta: {
        messages: {
            useNull: 'Use null instead.',
        },
    },
    create(context) {
        function raiseOnUndefined(node) {
            if (node.type === 'Identifier' && node.name === 'undefined') {
                context.report({
                    messageId: 'useNull',
                    node,
                });
            }
        }
        return {
            VariableDeclarator: (node) => {
                const { init } = node;
                if (init) {
                    raiseOnUndefined(init);
                }
            },
            AssignmentExpression: (node) => {
                const { right } = node;
                raiseOnUndefined(right);
            },
        };
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
// https://jira.sonarsource.com/browse/RSPEC-2681
const NestingStatementLike = [
    'IfStatement',
    'ForStatement',
    'ForInStatement',
    'ForOfStatement',
    'WhileStatement',
];
const rule$10 = {
    create(context) {
        return {
            Program: (node) => checkStatements(node.body, context),
            BlockStatement: (node) => checkStatements(node.body, context),
            TSModuleBlock: (node) => checkStatements(node.body, context),
        };
    },
};
function checkStatements(statements, context) {
    chain(statements)
        .filter(chainedStatements => chainedStatements.areUnenclosed())
        .forEach(unenclosedConsecutives => {
        if (unenclosedConsecutives.areAdjacent()) {
            raiseAdjacenceIssue(unenclosedConsecutives, context);
        }
        else if (unenclosedConsecutives.areBothIndented()) {
            raiseBlockIssue(unenclosedConsecutives, countStatementsInTheSamePile(unenclosedConsecutives.prev, statements), context);
        }
        else if (unenclosedConsecutives.areInlinedAndIndented()) {
            raiseInlineAndIndentedIssue(unenclosedConsecutives, context);
        }
    });
}
function chain(statements) {
    return statements
        .reduce((result, statement, i, array) => {
        if (i < array.length - 1 && isNestingStatement(statement)) {
            result.push({ prev: statement, next: array[i + 1] });
        }
        return result;
    }, new Array())
        .map(pair => {
        return new ChainedStatements(pair.prev, extractLastBody(pair.prev), pair.next);
    });
}
function extractLastBody(statement) {
    if (statement.type === 'IfStatement') {
        if (statement.alternate) {
            return statement.alternate;
        }
        else {
            return statement.consequent;
        }
    }
    else {
        return statement.body;
    }
}
function countStatementsInTheSamePile(reference, statements) {
    const startOfPile = position(reference).start;
    let lastLineOfPile = startOfPile.line;
    for (const statement of statements) {
        const currentPosition = position(statement);
        const currentLine = currentPosition.end.line;
        const currentIndentation = currentPosition.start.column;
        if (currentLine > startOfPile.line) {
            if (currentIndentation === startOfPile.column) {
                lastLineOfPile = currentPosition.end.line;
            }
            else {
                break;
            }
        }
    }
    return lastLineOfPile - startOfPile.line + 1;
}
function raiseAdjacenceIssue(adjacentStatements, context) {
    context.report({
        message: `This statement will not be executed ${adjacentStatements.includedStatementQualifier()}; only the first statement will be. ` +
            `The rest will execute ${adjacentStatements.excludedStatementsQualifier()}.`,
        node: adjacentStatements.next,
    });
}
function raiseBlockIssue(piledStatements, sizeOfPile, context) {
    context.report({
        message: `This line will not be executed ${piledStatements.includedStatementQualifier()}; only the first line of this ${sizeOfPile}-line block will be. ` +
            `The rest will execute ${piledStatements.excludedStatementsQualifier()}.`,
        node: piledStatements.next,
    });
}
function raiseInlineAndIndentedIssue(chainedStatements, context) {
    context.report({
        message: `This line will not be executed ${chainedStatements.includedStatementQualifier()}; only the first statement will be. ` +
            `The rest will execute ${chainedStatements.excludedStatementsQualifier()}.`,
        node: chainedStatements.next,
    });
}
function isNestingStatement(node) {
    return NestingStatementLike.includes(node.type);
}
class ChainedStatements {
    constructor(topStatement, prev, next) {
        this.topStatement = topStatement;
        this.prev = prev;
        this.next = next;
        const topPosition = position(topStatement);
        const prevPosition = position(prev);
        const nextPosition = position(next);
        this.positions = {
            prevTopStart: topPosition.start,
            prevTopEnd: topPosition.end,
            prevStart: prevPosition.start,
            prevEnd: prevPosition.end,
            nextStart: nextPosition.start,
            nextEnd: nextPosition.end,
        };
    }
    areUnenclosed() {
        return this.prev.type !== 'BlockStatement';
    }
    areAdjacent() {
        return this.positions.prevEnd.line === this.positions.nextStart.line;
    }
    areBothIndented() {
        return (this.positions.prevStart.column === this.positions.nextStart.column && this.prevIsIndented());
    }
    areInlinedAndIndented() {
        return (this.positions.prevStart.line === this.positions.prevTopEnd.line &&
            this.positions.nextStart.column > this.positions.prevTopStart.column);
    }
    includedStatementQualifier() {
        return this.topStatement.type === 'IfStatement' ? 'conditionally' : 'in a loop';
    }
    excludedStatementsQualifier() {
        return this.topStatement.type === 'IfStatement' ? 'unconditionally' : 'only once';
    }
    prevIsIndented() {
        return this.positions.prevStart.column > this.positions.prevTopStart.column;
    }
}
function position(node) {
    return node.loc;
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const ADM_ZIP = 'adm-zip';
const rule$$ = {
    meta: {
        messages: {
            safeExpanding: 'Make sure that expanding this archive file is safe here.',
        },
    },
    create(context) {
        function canBeProperty(prop, name) {
            return (prop.type === 'SpreadElement' ||
                isIdentifier(prop.key, name) ||
                (isLiteral$2(prop.key) && prop.key.value === name));
        }
        function isCallToAdmZipExtractAll({ callee }) {
            return callee.type === 'MemberExpression' && isIdentifier(callee.property, 'extractAllTo');
        }
        function isAdmZipLibraryInScope() {
            return isAdmZipLibraryImported() || isAdmZipLibraryRequired();
        }
        function isAdmZipLibraryImported() {
            return getImportDeclarations(context).some(i => i.source.value === ADM_ZIP);
        }
        function isAdmZipLibraryRequired() {
            return getRequireCalls(context).some(r => r.arguments[0].type === 'Literal' && r.arguments[0].value === ADM_ZIP);
        }
        function isSensiteTarCall(call) {
            if (isCallToFQN(context, call, 'tar', 'x')) {
                const firstArg = call.arguments.length > 0 ? call.arguments[0] : null;
                if (!firstArg) {
                    return false;
                }
                const firstArgValue = getValueOfExpression(context, firstArg, 'ObjectExpression');
                return (!!firstArgValue && !firstArgValue.properties.some(prop => canBeProperty(prop, 'filter')));
            }
            return false;
        }
        function isSensiteExtractZipCall(call) {
            var _a;
            if (call.callee.type === 'Identifier' &&
                ((_a = getModuleNameOfIdentifier(context, call.callee)) === null || _a === void 0 ? void 0 : _a.value) === 'extract-zip') {
                const secondArg = call.arguments.length > 1 ? call.arguments[1] : null;
                if (!secondArg) {
                    return false;
                }
                const secondArgValue = getValueOfExpression(context, secondArg, 'ObjectExpression');
                return (!!secondArgValue &&
                    !secondArgValue.properties.some(prop => canBeProperty(prop, 'onEntry')));
            }
            return false;
        }
        return {
            CallExpression(node) {
                const call = node;
                if (isSensiteTarCall(call) ||
                    (isCallToAdmZipExtractAll(call) && isAdmZipLibraryInScope()) ||
                    isCallToFQN(context, call, 'jszip', 'loadAsync') ||
                    isCallToFQN(context, call, 'yauzl', 'open') ||
                    isSensiteExtractZipCall(call)) {
                    context.report({
                        messageId: 'safeExpanding',
                        node: call.callee,
                    });
                }
            },
        };
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$_ = {
    meta: {
        hasSuggestions: true,
        messages: {
            throwOrRemoveError: 'Throw this error or remove this useless statement.',
            suggestThrowError: 'Throw this error',
        },
    },
    create(context) {
        function looksLikeAnError(expression) {
            const text = context.getSourceCode().getText(expression);
            return text.endsWith('Error') || text.endsWith('Exception');
        }
        return {
            'ExpressionStatement > NewExpression': function (node) {
                const expression = node.callee;
                if (looksLikeAnError(expression)) {
                    context.report({
                        messageId: 'throwOrRemoveError',
                        node,
                        suggest: [
                            {
                                messageId: 'suggestThrowError',
                                fix: fixer => fixer.insertTextBefore(getParent(context), 'throw '),
                            },
                        ],
                    });
                }
            },
        };
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
// https://jira.sonarsource.com/browse/RSPEC-1172
const rule$Z = {
    meta: {
        hasSuggestions: true,
        messages: {
            removeOrRenameParameter: 'Remove the unused function parameter "{{param}}" or rename it to "_{{param}}" to make intention explicit.',
            suggestRemoveParameter: 'Remove "{{param}}" (beware of call sites)',
            suggestRenameParameter: 'Rename "{{param}}" to "_{{param}}"',
        },
    },
    create(context) {
        return {
            'FunctionDeclaration, FunctionExpression': function (node) {
                reportUnusedArgument(node, node.id, context);
            },
            ArrowFunctionExpression: (node) => {
                reportUnusedArgument(node, undefined, context);
            },
        };
    },
};
function reportUnusedArgument(node, functionId, context) {
    const parent = node.parent;
    if (parent && parent.type === 'Property' && parent.kind === 'set') {
        return;
    }
    if (context
        .getScope()
        .variables.some(v => v.name === 'arguments' && v.identifiers.length === 0 && v.references.length > 0)) {
        return;
    }
    let parametersVariable = context.getDeclaredVariables(node);
    if (functionId) {
        parametersVariable = parametersVariable.filter(v => v.name !== functionId.name);
    }
    for (const param of parametersVariable) {
        if (isUnusedVariable(param) && !isIgnoredParameter(param) && !isParameterProperty(param)) {
            context.report({
                messageId: 'removeOrRenameParameter',
                node: param.identifiers[0],
                data: {
                    param: param.name,
                },
                suggest: getSuggestions(param, context),
            });
        }
    }
}
function getSuggestions(paramVariable, context) {
    const paramIdentifier = paramVariable.identifiers[0];
    const suggestions = [
        {
            messageId: 'suggestRenameParameter',
            data: {
                param: paramVariable.name,
            },
            fix: fixer => fixer.insertTextBefore(paramIdentifier, '_'),
        },
    ];
    const func = paramVariable.defs[0].node;
    if (paramIdentifier.parent === func) {
        suggestions.push(getParameterRemovalSuggestion(func, paramVariable, paramIdentifier, context));
    }
    return suggestions;
}
function getParameterRemovalSuggestion(func, paramVariable, paramIdentifier, context) {
    return {
        messageId: 'suggestRemoveParameter',
        data: {
            param: paramVariable.name,
        },
        fix: fixer => {
            const paramIndex = func.params.indexOf(paramIdentifier);
            const param = func.params[paramIndex];
            if (func.params.length === 1) {
                const openingParenthesis = context.getSourceCode().getTokenBefore(param);
                const closingParenthesis = context
                    .getSourceCode()
                    .getTokenAfter(param, token => token.value === ')');
                let [start, end] = param.range;
                if (openingParenthesis && openingParenthesis.value === '(') {
                    start = openingParenthesis.range[0];
                    end = closingParenthesis.range[1];
                }
                return fixer.replaceTextRange([start, end], '()');
            }
            else if (func.params.length - 1 === paramIndex) {
                const commaAfter = context
                    .getSourceCode()
                    .getTokenAfter(param, token => token.value === ',');
                const commaBefore = context
                    .getSourceCode()
                    .getTokenBefore(param, token => token.value === ',');
                let start = commaBefore.range[1];
                let end = param.range[1];
                if (commaAfter) {
                    end = commaAfter.range[1];
                }
                else {
                    start = commaBefore.range[0];
                }
                return fixer.removeRange([start, end]);
            }
            else {
                const [start] = func.params[paramIndex].range;
                const [end] = func.params[paramIndex + 1].range;
                return fixer.removeRange([start, end]);
            }
        },
    };
}
function isUnusedVariable(variable) {
    const refs = variable.references;
    //Parameter with default value has one reference, but should still be considered as unused.
    return refs.length === 0 || (refs.length === 1 && refs[0].init);
}
function isIgnoredParameter(variable) {
    return variable.name.startsWith('_');
}
function isParameterProperty(variable) {
    return variable.defs.some(def => { var _a; return ((_a = def.name.parent) === null || _a === void 0 ? void 0 : _a.type) === 'TSParameterProperty'; });
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
// https://jira.sonarsource.com/browse/RSPEC-2123
const rule$Y = {
    meta: {
        messages: {
            removeIncrement: 'Remove this {{updateOperator}}rement or correct the code not to waste it.',
        },
    },
    create(context) {
        function reportUpdateExpression(updateExpression) {
            const updateOperator = updateExpression.operator === '++' ? 'inc' : 'dec';
            context.report({
                messageId: 'removeIncrement',
                data: {
                    updateOperator,
                },
                node: updateExpression,
            });
        }
        return {
            'ReturnStatement > UpdateExpression': function (node) {
                const updateExpression = node;
                const argument = updateExpression.argument;
                if (!updateExpression.prefix &&
                    argument.type === 'Identifier' &&
                    isLocalIdentifier(argument, context.getScope())) {
                    reportUpdateExpression(updateExpression);
                }
            },
            AssignmentExpression(node) {
                const assignment = node;
                const rhs = assignment.right;
                if (rhs.type === 'UpdateExpression' && !rhs.prefix) {
                    const lhs = assignment.left;
                    if (lhs.type === 'Identifier' &&
                        rhs.argument.type === 'Identifier' &&
                        rhs.argument.name === lhs.name) {
                        reportUpdateExpression(rhs);
                    }
                }
            },
        };
    },
};
function isLocalIdentifier(id, scope) {
    return scope.variables.some(v => v.identifiers.some(i => i.name === id.name));
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$X = {
    meta: {
        messages: {
            removeIntersection: 'Remove this type without members or change this type intersection.',
            simplifyIntersection: 'Simplify this intersection as it always has type "{{type}}".',
        },
    },
    create(context) {
        const services = context.parserServices;
        if (parserServices.isRequiredParserServices(services)) {
            return {
                TSIntersectionType: (node) => {
                    const intersection = node;
                    const anyOrNever = intersection.types.find(typeNode => ['TSAnyKeyword', 'TSNeverKeyword'].includes(typeNode.type));
                    if (anyOrNever) {
                        context.report({
                            messageId: 'simplifyIntersection',
                            data: {
                                type: anyOrNever.type === 'TSAnyKeyword' ? 'any' : 'never',
                            },
                            node,
                        });
                    }
                    else {
                        intersection.types.forEach(typeNode => {
                            const tp = services.program
                                .getTypeChecker()
                                .getTypeAtLocation(services.esTreeNodeToTSNodeMap.get(typeNode));
                            if (isTypeWithoutMembers(tp)) {
                                context.report({
                                    messageId: 'removeIntersection',
                                    node: typeNode,
                                });
                            }
                        });
                    }
                },
            };
        }
        return {};
    },
};
function isTypeWithoutMembers(tp) {
    return isNullLike(tp) || (isEmptyInterface(tp) && isStandaloneInterface(tp.symbol));
}
function isNullLike(tp) {
    return (Boolean(tp.flags & ts__namespace.TypeFlags.Null) ||
        Boolean(tp.flags & ts__namespace.TypeFlags.Undefined) ||
        Boolean(tp.flags & ts__namespace.TypeFlags.Void));
}
function isEmptyInterface(tp) {
    return (tp.getProperties().length === 0 &&
        (!tp.declaredIndexInfos ||
            tp.declaredIndexInfos.length === 0));
}
function isStandaloneInterface(typeSymbol) {
    // there is no declarations for `{}`
    // otherwise check that none of declarations has a heritage clause (`extends X` or `implements X`)
    if (!typeSymbol) {
        return false;
    }
    const { declarations } = typeSymbol;
    return (!declarations ||
        declarations.every(declaration => {
            return (isInterfaceDeclaration(declaration) && (declaration.heritageClauses || []).length === 0);
        }));
}
function isInterfaceDeclaration(declaration) {
    return declaration.kind === ts__namespace.SyntaxKind.InterfaceDeclaration;
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$W = {
    meta: {
        schema: [
            {
                // internal parameter for rules having secondary locations
                enum: ['sonar-runtime'],
            },
        ],
    },
    create(context) {
        return {
            "VariableDeclaration[kind='var']": (node) => {
                const variables = context.getDeclaredVariables(node);
                for (const variable of variables) {
                    const declaration = variable.identifiers[0];
                    const misused = variable.references
                        .filter(reference => !reference.init && comesBefore(reference.identifier, declaration))
                        .map(reference => reference.identifier);
                    if (misused.length > 0) {
                        context.report({
                            message: toEncodedMessage$1(`Move the declaration of \"${declaration.name}\" before this usage.`, [declaration], ['Declaration']),
                            node: misused[0],
                        });
                    }
                }
            },
        };
    },
};
function comesBefore(node, other) {
    const nodeLine = line(node), otherLine = line(other);
    return nodeLine < otherLine || (nodeLine === otherLine && column(node) < column(other));
}
function line(node) {
    return node.loc.start.line;
}
function column(node) {
    return node.loc.start.column;
}

const rule$V = {
    meta: {
        messages: {
            safeVueBypassing: 'Make sure bypassing Vue built-in sanitization is safe here.',
        },
    },
    create(context) {
        const services = context.parserServices;
        function attrsHref(calleeName) {
            // select call expression with given name where second argument is object expression like { attrs: { href: 'bla' } }
            return `CallExpression[callee.name='${calleeName}'] ObjectExpression.arguments:nth-child(2) > Property[key.name='attrs'] > ObjectExpression.value > Property[key.name='href']`;
        }
        const ruleListener = {
            ["JSXAttribute[name.name='domPropsInnerHTML']," +
                "Property[key.name='domProps'] > ObjectExpression.value > Property[key.name='innerHTML']"](node) {
                context.report({ node, messageId: 'safeVueBypassing' });
            },
            [`${attrsHref('createElement')},${attrsHref('h')}`](node) {
                context.report({ node, messageId: 'safeVueBypassing' });
            },
        };
        // @ts-ignore
        if (services.defineTemplateBodyVisitor) {
            // analyze <template> in .vue file
            const templateBodyVisitor = context.parserServices.defineTemplateBodyVisitor({
                ["VAttribute[directive=true][key.name.name='html']," +
                    "VAttribute[directive=true][key.argument.name='href']"](node) {
                    context.report({
                        loc: node.loc,
                        messageId: 'safeVueBypassing',
                    });
                },
            });
            Object.assign(ruleListener, templateBodyVisitor);
        }
        return ruleListener;
    },
};

const WEAK_CIPHERS = ['bf', 'blowfish', 'des', 'rc2', 'rc4'];
const rule$U = {
    meta: {
        messages: {
            strongerCipher: 'Use a strong cipher algorithm.',
        },
    },
    create(context) {
        return {
            CallExpression(node) {
                var _a;
                const callExpression = node;
                if (isCallToFQN(context, callExpression, 'crypto', 'createCipheriv')) {
                    const algorithm = getValueOfExpression(context, callExpression.arguments[0], 'Literal');
                    const algorithmValue = (_a = algorithm === null || algorithm === void 0 ? void 0 : algorithm.value) === null || _a === void 0 ? void 0 : _a.toString().toLowerCase();
                    if (algorithm &&
                        algorithmValue &&
                        WEAK_CIPHERS.findIndex(cipher => algorithmValue.startsWith(cipher)) >= 0) {
                        context.report({
                            messageId: 'strongerCipher',
                            node: algorithm,
                        });
                    }
                }
            },
        };
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const MINIMAL_MODULUS_LENGTH = 2048;
const MINIMAL_DIVISOR_LENGTH = 224;
const WEAK_CURVES = [
    'secp112r1',
    'secp112r2',
    'secp128r1',
    'secp128r2',
    'secp160k1',
    'secp160r1',
    'secp160r2',
    'secp160r2',
    'secp192k1',
    'secp192r1',
    'prime192v2',
    'prime192v3',
    'sect113r1',
    'sect113r2',
    'sect131r1',
    'sect131r2',
    'sect163k1',
    'sect163r1',
    'sect163r2',
    'sect193r1',
    'sect193r2',
    'c2tnb191v1',
    'c2tnb191v2',
    'c2tnb191v3',
];
const rule$T = {
    meta: {
        messages: {
            modulusLength: 'Use a modulus length of at least {{minimalLength}} bits for {{algorithm}} cipher algorithm.',
            divisorLength: 'Use a divisor length of at least {{minimalLength}} bits for {{algorithm}} cipher algorithm.',
            strongerCurve: `{{curve}} doesn't provide enough security. Use a stronger curve.`,
        },
    },
    create(context) {
        function getNumericValue(node) {
            const literal = getValueOfExpression(context, node, 'Literal');
            if (literal && typeof literal.value === 'number') {
                return literal.value;
            }
            return undefined;
        }
        function checkRsaAndDsaOptions(algorithm, options) {
            const modulusProperty = getObjectExpressionProperty(options, 'modulusLength');
            const modulusLength = getNumericValue(modulusProperty === null || modulusProperty === void 0 ? void 0 : modulusProperty.value);
            if (modulusProperty && modulusLength && modulusLength < MINIMAL_MODULUS_LENGTH) {
                context.report({
                    node: modulusProperty,
                    messageId: 'modulusLength',
                    data: {
                        minimalLength: MINIMAL_MODULUS_LENGTH.toString(),
                        algorithm,
                    },
                });
            }
            const divisorProperty = getObjectExpressionProperty(options, 'divisorLength');
            const divisorLength = getNumericValue(divisorProperty === null || divisorProperty === void 0 ? void 0 : divisorProperty.value);
            if (divisorProperty && divisorLength && divisorLength < MINIMAL_DIVISOR_LENGTH) {
                context.report({
                    node: divisorProperty,
                    messageId: 'divisorLength',
                    data: {
                        minimalLength: MINIMAL_DIVISOR_LENGTH.toString(),
                        algorithm,
                    },
                });
            }
        }
        function checkEcCurve(options) {
            var _a, _b;
            const namedCurveProperty = getObjectExpressionProperty(options, 'namedCurve');
            const namedCurve = (_b = (_a = getValueOfExpression(context, namedCurveProperty === null || namedCurveProperty === void 0 ? void 0 : namedCurveProperty.value, 'Literal')) === null || _a === void 0 ? void 0 : _a.value) === null || _b === void 0 ? void 0 : _b.toString();
            if (namedCurveProperty && namedCurve && WEAK_CURVES.includes(namedCurve)) {
                context.report({
                    node: namedCurveProperty,
                    messageId: 'strongerCurve',
                    data: {
                        curve: namedCurve,
                    },
                });
            }
        }
        return {
            CallExpression: (node) => {
                var _a;
                const callExpression = node;
                const { callee } = callExpression;
                if (callee.type === 'MemberExpression' &&
                    isIdentifier(callee.property, 'generateKeyPair', 'generateKeyPairSync')) {
                    if (callExpression.arguments.length < 2) {
                        return;
                    }
                    const [algorithmArg, options] = callExpression.arguments;
                    const optionsArg = getValueOfExpression(context, options, 'ObjectExpression');
                    if (!optionsArg) {
                        return;
                    }
                    const algorithm = (_a = getValueOfExpression(context, algorithmArg, 'Literal')) === null || _a === void 0 ? void 0 : _a.value;
                    if (algorithm === 'rsa' || algorithm === 'dsa') {
                        checkRsaAndDsaOptions(algorithm, optionsArg);
                    }
                    else if (algorithm === 'ec') {
                        checkEcCurve(optionsArg);
                    }
                }
            },
        };
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
// https://jira.sonarsource.com/browse/RSPEC-2208
const rule$S = {
    meta: {
        messages: {
            wildcardImport: 'Explicitly {{xPort}} the specific member needed.',
        },
    },
    create(context) {
        function report(node, xPort) {
            context.report({
                messageId: 'wildcardImport',
                data: { xPort },
                node,
            });
        }
        return {
            ImportNamespaceSpecifier: (node) => report(node, 'import'),
            ExportAllDeclaration: (node) => report(node, 'export'),
        };
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const MESSAGE = 'Convert this operand into a number.';
const rule$R = {
    meta: {
        schema: [
            {
                // internal parameter for rules having secondary locations
                enum: ['sonar-runtime'],
            },
        ],
    },
    create(context) {
        const services = context.parserServices;
        if (!parserServices.isRequiredParserServices(services)) {
            return {};
        }
        return {
            BinaryExpression: (node) => {
                const binaryExpression = node;
                const operator = binaryExpression.operator;
                const leftType = getTypeFromTreeNode$1(binaryExpression.left, services);
                const rightType = getTypeFromTreeNode$1(binaryExpression.right, services);
                if (operator === '+') {
                    checkPlus(leftType, rightType, binaryExpression, context);
                }
                if (operator === '<' || operator === '>' || operator === '<=' || operator === '>=') {
                    checkComparison(leftType, rightType, binaryExpression, context);
                }
                if (operator === '-' || operator === '*' || operator === '/' || operator === '%') {
                    checkArithmetic(leftType, rightType, binaryExpression, context);
                }
            },
            AssignmentExpression: (node) => {
                const assignmentExpression = node;
                const operator = assignmentExpression.operator;
                const leftType = getTypeFromTreeNode$1(assignmentExpression.left, services);
                const rightType = getTypeFromTreeNode$1(assignmentExpression.right, services);
                if (operator === '+=') {
                    checkPlus(leftType, rightType, assignmentExpression, context);
                }
                if (operator === '-=' || operator === '*=' || operator === '/=' || operator === '%=') {
                    checkArithmetic(leftType, rightType, assignmentExpression, context);
                }
            },
            'UnaryExpression[operator="-"]': (node) => {
                const unaryExpression = node;
                const type = getTypeFromTreeNode$1(unaryExpression.argument, services);
                if (isBooleanStringOrDate(type)) {
                    context.report({
                        node: unaryExpression.argument,
                        message: toEncodedMessage$1(MESSAGE, []),
                    });
                }
            },
            UpdateExpression: (node) => {
                const updateExpression = node;
                const type = getTypeFromTreeNode$1(updateExpression.argument, services);
                if (isBooleanStringOrDate(type)) {
                    context.report({
                        node: updateExpression.argument,
                        message: toEncodedMessage$1(MESSAGE, []),
                    });
                }
            },
        };
    },
};
function isDateMinusDateException(leftType, rightType, operator) {
    var _a, _b, _c;
    if (operator !== '-' && operator !== '-=') {
        return false;
    }
    if (((_a = leftType.symbol) === null || _a === void 0 ? void 0 : _a.name) === 'Date' &&
        (((_b = rightType.symbol) === null || _b === void 0 ? void 0 : _b.name) === 'Date' || (rightType.flags & ts__default["default"].TypeFlags.Any) > 0)) {
        return true;
    }
    if (((_c = rightType.symbol) === null || _c === void 0 ? void 0 : _c.name) === 'Date' && (leftType.flags & ts__default["default"].TypeFlags.Any) > 0) {
        return true;
    }
    return false;
}
function checkPlus(leftType, rightType, expression, context) {
    if (isNumber(leftType) && isBooleanOrDate(rightType)) {
        context.report({
            node: expression.right,
            message: toEncodedMessage$1(MESSAGE, [expression.left]),
        });
    }
    if (isNumber(rightType) && isBooleanOrDate(leftType)) {
        context.report({
            node: expression.left,
            message: toEncodedMessage$1(MESSAGE, [expression.right]),
        });
    }
}
function checkComparison(leftType, rightType, expression, context) {
    if (isBooleanOrNumber(leftType) && isBooleanStringOrDate(rightType)) {
        context.report({
            node: expression.right,
            message: toEncodedMessage$1(MESSAGE, []),
        });
    }
    else if (isBooleanOrNumber(rightType) && isBooleanStringOrDate(leftType)) {
        context.report({
            node: expression.left,
            message: toEncodedMessage$1(MESSAGE, []),
        });
    }
}
function checkArithmetic(leftType, rightType, expression, context) {
    if (isDateMinusDateException(leftType, rightType, expression.operator)) {
        return;
    }
    const secondaryLocations = [];
    if (isBooleanStringOrDate(leftType)) {
        secondaryLocations.push(expression.left);
    }
    if (isBooleanStringOrDate(rightType)) {
        secondaryLocations.push(expression.right);
    }
    if (secondaryLocations.length !== 0) {
        context.report({
            node: expression,
            message: toEncodedMessage$1('Convert the operands of this operation into numbers.', secondaryLocations),
        });
    }
}
function isBooleanOrDate(type) {
    var _a;
    if (isBoolean(type)) {
        return true;
    }
    return ((_a = type.symbol) === null || _a === void 0 ? void 0 : _a.name) === 'Date';
}
function isBooleanOrNumber(type) {
    return isBoolean(type) || isNumber(type);
}
function isBoolean(type) {
    var _a;
    return (type.flags & ts__default["default"].TypeFlags.BooleanLike) > 0 || ((_a = type.symbol) === null || _a === void 0 ? void 0 : _a.name) === 'Boolean';
}
function isNumber(type) {
    var _a;
    return (type.flags & ts__default["default"].TypeFlags.NumberLike) > 0 || ((_a = type.symbol) === null || _a === void 0 ? void 0 : _a.name) === 'Number';
}
function isBooleanStringOrDate(type) {
    var _a;
    return isBoolean(type) || isStringType$1(type) || ((_a = type.symbol) === null || _a === void 0 ? void 0 : _a.name) === 'Date';
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$Q = {
    meta: {
        messages: {
            nullDereference: 'TypeError can be thrown as "{{symbol}}" might be null or undefined here.',
        },
    },
    create(context) {
        const services = context.parserServices;
        if (!parserServices.isRequiredParserServices(services)) {
            return {};
        }
        const alreadyRaisedSymbols = new Set();
        function checkNullDereference(node) {
            var _a;
            if (node.type !== 'Identifier') {
                return;
            }
            const scope = context.getScope();
            const symbol = (_a = scope.references.find(v => v.identifier === node)) === null || _a === void 0 ? void 0 : _a.resolved;
            if (!symbol) {
                return;
            }
            const enclosingFunction = context.getAncestors().find(n => functionLike$1.has(n.type));
            if (!alreadyRaisedSymbols.has(symbol) &&
                !isWrittenInInnerFunction(symbol, enclosingFunction) &&
                isUndefinedOrNull(node, services)) {
                alreadyRaisedSymbols.add(symbol);
                context.report({
                    messageId: 'nullDereference',
                    data: {
                        symbol: node.name,
                    },
                    node,
                });
            }
        }
        function isWrittenInInnerFunction(symbol, fn) {
            return symbol.references.some(ref => {
                if (ref.isWrite() && ref.identifier.hasOwnProperty('parent')) {
                    const enclosingFn = findFirstMatchingAncestor(ref.identifier, node => functionLike$1.has(node.type));
                    return enclosingFn && enclosingFn !== fn;
                }
                return false;
            });
        }
        return {
            MemberExpression(node) {
                const { object, optional } = node;
                if (!optional) {
                    checkNullDereference(object);
                }
            },
            ForOfStatement(node) {
                const { right } = node;
                checkNullDereference(right);
            },
            'Program:exit'() {
                alreadyRaisedSymbols.clear();
            },
        };
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const BINARY_OPERATORS = ['/', '*', '%', '-', '-=', '*=', '/=', '%='];
const UNARY_OPERATORS = ['++', '--', '+', '-'];
const rule$P = {
    meta: {
        messages: {
            noEvaluatedNaN: 'Change the expression which uses this operand so that it can\'t evaluate to "NaN" (Not a Number).',
        },
    },
    create(context) {
        const services = context.parserServices;
        if (!parserServices.isRequiredParserServices(services)) {
            return {};
        }
        function isObjectType(...types) {
            return types.some(t => { var _a; return !!(t.getFlags() & ts.TypeFlags.Object) && !isDate(t) && ((_a = t.symbol) === null || _a === void 0 ? void 0 : _a.name) !== 'Number'; });
        }
        function isDate(type) {
            const { typeToString } = services.program.getTypeChecker();
            return typeToString(type) === 'Date';
        }
        return {
            'BinaryExpression, AssignmentExpression': (node) => {
                const expression = node;
                if (!BINARY_OPERATORS.includes(expression.operator)) {
                    return;
                }
                const leftType = getTypeFromTreeNode$1(expression.left, services);
                const rightType = getTypeFromTreeNode$1(expression.right, services);
                if (isObjectType(leftType)) {
                    context.report({ node: expression.left, messageId: 'noEvaluatedNaN' });
                }
                if (isObjectType(rightType)) {
                    context.report({ node: expression.right, messageId: 'noEvaluatedNaN' });
                }
            },
            'UnaryExpression, UpdateExpression': (node) => {
                const expr = node;
                if (!UNARY_OPERATORS.includes(expr.operator)) {
                    return;
                }
                const argType = getTypeFromTreeNode$1(expr.argument, services);
                if (isObjectType(argType)) {
                    context.report({ node, messageId: 'noEvaluatedNaN' });
                }
            },
        };
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const EXEC_FUNCTIONS = ['exec', 'execSync'];
const SPAWN_EXEC_FILE_FUNCTIONS = ['spawn', 'spawnSync', 'execFile', 'execFileSync'];
const CHILD_PROCESS_MODULE = 'child_process';
const rule$O = {
    meta: {
        messages: {
            safeOSCommand: 'Make sure that executing this OS command is safe here.',
        },
    },
    create(context) {
        return {
            CallExpression: (node) => checkCallExpression$2(node, context),
        };
    },
};
function checkCallExpression$2({ callee, arguments: args }, context) {
    if (callee.type === 'MemberExpression') {
        if (callee.object.type === 'Identifier') {
            const moduleName = getModuleNameOfIdentifier(context, callee.object);
            checkOSCommand(moduleName, callee.property, args, context);
        }
    }
    else if (callee.type === 'Identifier') {
        const moduleName = getModuleNameOfImportedIdentifier(context, callee);
        checkOSCommand(moduleName, callee, args, context);
    }
}
function checkOSCommand(moduleName, callee, args, context) {
    if (moduleName && moduleName.value === CHILD_PROCESS_MODULE && isQuestionable$2(callee, args)) {
        context.report({
            node: callee,
            messageId: 'safeOSCommand',
        });
    }
}
function isQuestionable$2(expression, [command, ...otherArguments]) {
    // if command is hardcoded => no issue
    if (!command || command.type === 'Literal') {
        return false;
    }
    // for `spawn` and `execFile`, `shell` option must be set to `true`
    if (isIdentifier(expression, ...SPAWN_EXEC_FILE_FUNCTIONS)) {
        return containsShellOption(otherArguments);
    }
    return isIdentifier(expression, ...EXEC_FUNCTIONS);
}
function containsShellOption(otherArguments) {
    return otherArguments.some(arg => arg.type === 'ObjectExpression' &&
        arg.properties.filter(v => v.type === 'Property').some(({ key, value }) => isIdentifier(key, 'shell') && value.type === 'Literal' && value.value === true));
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const POST_MESSAGE = 'postMessage';
const ADD_EVENT_LISTENER = 'addEventListener';
const rule$N = {
    meta: {
        messages: {
            specifyTarget: `Specify a target origin for this message.`,
            verifyOrigin: `Verify the origin of the received message.`,
        },
    },
    create(context) {
        const services = context.parserServices;
        if (!parserServices.isRequiredParserServices(services)) {
            return {};
        }
        return {
            [`CallExpression:matches([callee.name="${POST_MESSAGE}"], [callee.property.name="${POST_MESSAGE}"])`]: (node) => {
                checkPostMessageCall(node, context);
            },
            [`CallExpression[callee.property.name="${ADD_EVENT_LISTENER}"]`]: (node) => {
                checkAddEventListenerCall(node, context);
            },
        };
    },
};
function isWindowObject(node, context) {
    const type = getTypeAsString(node, context.parserServices);
    const hasWindowName = WindowNameVisitor.containsWindowName(node, context);
    return type.match(/window/i) || type.match(/globalThis/i) || hasWindowName;
}
function checkPostMessageCall(callExpr, context) {
    var _a;
    const { callee } = callExpr;
    // Window.postMessage() can take 2 or 3 arguments
    if (![2, 3].includes(callExpr.arguments.length) ||
        ((_a = getValueOfExpression(context, callExpr.arguments[1], 'Literal')) === null || _a === void 0 ? void 0 : _a.value) !== '*') {
        return;
    }
    if (callee.type === 'Identifier') {
        context.report({
            node: callee,
            messageId: 'specifyTarget',
        });
    }
    if (callee.type !== 'MemberExpression') {
        return;
    }
    if (isWindowObject(callee.object, context)) {
        context.report({
            node: callee,
            messageId: 'specifyTarget',
        });
    }
}
function checkAddEventListenerCall(callExpr, context) {
    const { callee, arguments: args } = callExpr;
    if (!isWindowObject(callee, context) ||
        args.length < 2 ||
        !isMessageTypeEvent(args[0], context)) {
        return;
    }
    const listener = resolveFunction(context, args[1]);
    if (!listener || listener.params.length === 0) {
        return;
    }
    const event = listener.params[0];
    if (event.type !== 'Identifier') {
        return;
    }
    const hasVerifiedOrigin = EventListenerVisitor.isSenderIdentityVerified(listener.body, event, context);
    if (!hasVerifiedOrigin) {
        context.report({
            node: callee,
            messageId: 'verifyOrigin',
        });
    }
}
function isMessageTypeEvent(eventNode, context) {
    const eventValue = getValueOfExpression(context, eventNode, 'Literal');
    return typeof (eventValue === null || eventValue === void 0 ? void 0 : eventValue.value) === 'string' && eventValue.value.toLowerCase() === 'message';
}
class WindowNameVisitor {
    constructor() {
        this.hasWindowName = false;
    }
    static containsWindowName(node, context) {
        const visitor = new WindowNameVisitor();
        visitor.visit(node, context);
        return visitor.hasWindowName;
    }
    visit(root, context) {
        const visitNode = (node) => {
            if (node.type === 'Identifier' && node.name.match(/window/i)) {
                this.hasWindowName = true;
            }
            childrenOf$1(node, context.getSourceCode().visitorKeys).forEach(visitNode);
        };
        visitNode(root);
    }
}
class EventListenerVisitor {
    constructor() {
        this.hasVerifiedOrigin = false;
    }
    static isSenderIdentityVerified(node, event, context) {
        const visitor = new EventListenerVisitor();
        visitor.visit(node, event, context);
        return visitor.hasVerifiedOrigin;
    }
    visit(root, event, context) {
        const visitNode = (node) => {
            var _a;
            if (this.hasVerifiedOrigin) {
                return;
            }
            const n = node;
            if (n.type === 'MemberExpression' && ((_a = n.parent) === null || _a === void 0 ? void 0 : _a.type) === 'BinaryExpression') {
                const { object, property } = n;
                if (object.type === 'Identifier' &&
                    object.name === event.name &&
                    property.type === 'Identifier' &&
                    property.name === 'origin') {
                    this.hasVerifiedOrigin = true;
                    return;
                }
            }
            childrenOf$1(node, context.getSourceCode().visitorKeys).forEach(visitNode);
        };
        visitNode(root);
    }
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
// https://jira.sonarsource.com/browse/RSPEC-4524
const rule$M = {
    meta: {
        messages: {
            defaultLast: 'Move this "default" clause to the end of this "switch" statement.',
        },
    },
    create(context) {
        const sourceCode = context.getSourceCode();
        return {
            SwitchStatement(node) {
                const cases = node.cases;
                const defaultPosition = cases.findIndex(c => c.test === null);
                if (defaultPosition >= 0 && defaultPosition !== cases.length - 1) {
                    context.report({
                        messageId: 'defaultLast',
                        loc: sourceCode.getFirstToken(cases[defaultPosition]).loc,
                    });
                }
            },
        };
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$L = {
    meta: {
        hasSuggestions: true,
        messages: {
            promiseAction: 'Replace this trivial promise with "Promise.{{action}}".',
            suggestPromiseAction: 'Replace with "Promise.{{action}}"',
        },
    },
    create(context) {
        return {
            NewExpression: (node) => {
                const newExpr = node;
                const executor = getPromiseExecutor(newExpr, context);
                if (executor) {
                    checkExecutor(newExpr, executor, context);
                }
            },
        };
    },
};
function getPromiseExecutor(node, context) {
    if (node.callee.type === 'Identifier' &&
        context.getSourceCode().getText(node.callee) === 'Promise' &&
        node.arguments.length === 1) {
        return node.arguments[0];
    }
    return undefined;
}
function checkExecutor(newExpr, executor, context) {
    if (!isFunctionNode(executor)) {
        return;
    }
    const { params, body } = executor;
    const [resolveParameterDeclaration, rejectParameterDeclaration] = params;
    const resolveParameterName = getParameterName(resolveParameterDeclaration);
    const rejectParameterName = getParameterName(rejectParameterDeclaration);
    const bodyExpression = getOnlyBodyExpression(body);
    if (bodyExpression && bodyExpression.type === 'CallExpression') {
        const { callee, arguments: args } = bodyExpression;
        if (callee.type === 'Identifier') {
            const action = getPromiseAction(callee.name, resolveParameterName, rejectParameterName);
            if (action && args.length === 1) {
                context.report({
                    messageId: 'promiseAction',
                    data: {
                        action,
                    },
                    node: newExpr.callee,
                    suggest: [
                        {
                            messageId: 'suggestPromiseAction',
                            data: {
                                action,
                            },
                            fix: fixer => {
                                const argText = context.getSourceCode().getText(args[0]);
                                return fixer.replaceText(newExpr, `Promise.${action}(${argText})`);
                            },
                        },
                    ],
                });
            }
        }
    }
}
function getOnlyBodyExpression(node) {
    let bodyExpression;
    if (node.type === 'BlockStatement') {
        if (node.body.length === 1) {
            const statement = node.body[0];
            if (statement.type === 'ExpressionStatement') {
                bodyExpression = statement.expression;
            }
        }
    }
    else {
        bodyExpression = node;
    }
    return bodyExpression;
}
function getPromiseAction(callee, resolveParameterName, rejectParameterName) {
    switch (callee) {
        case resolveParameterName:
            return 'resolve';
        case rejectParameterName:
            return 'reject';
        default:
            return undefined;
    }
}
function getParameterName(node) {
    return node && node.type === 'Identifier' ? node.name : undefined;
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$K = {
    meta: {
        hasSuggestions: true,
        messages: {
            useTypePredicate: 'Declare this function return type using type predicate "{{castedExpressionText}} is {{castedTypeText}}".',
            suggestTypePredicate: 'Use type predicate',
        },
    },
    create(context) {
        return {
            "MethodDefinition[kind='method'] FunctionExpression": function (node) {
                checkFunctionLikeDeclaration(node, context);
            },
            FunctionDeclaration(node) {
                checkFunctionLikeDeclaration(node, context);
            },
        };
    },
};
function checkFunctionLikeDeclaration(functionDeclaration, context) {
    if (functionDeclaration.returnType &&
        functionDeclaration.returnType.typeAnnotation.type === 'TSTypePredicate') {
        return;
    }
    const body = functionDeclaration.body;
    const returnedExpression = getReturnedExpression(body);
    if (!returnedExpression) {
        return;
    }
    if (isInequalityBinaryExpression(returnedExpression)) {
        const { left, right } = returnedExpression;
        if (isUndefined(right)) {
            checkCastedType(functionDeclaration, left, context);
        }
        else if (isUndefined(left)) {
            checkCastedType(functionDeclaration, right, context);
        }
    }
    else if (isBooleanCall(returnedExpression)) {
        checkCastedType(functionDeclaration, returnedExpression.arguments[0], context);
    }
    else if (isNegation(returnedExpression) && isNegation(returnedExpression.argument)) {
        checkCastedType(functionDeclaration, returnedExpression.argument.argument, context);
    }
}
function getReturnedExpression(block) {
    if (block && block.body.length === 1) {
        const statement = block.body[0];
        if (statement.type === 'ReturnStatement') {
            return statement.argument;
        }
    }
    return undefined;
}
function isInequalityBinaryExpression(returnExpression) {
    return (returnExpression.type === 'BinaryExpression' &&
        (returnExpression.operator === '!==' || returnExpression.operator === '!='));
}
function checkCastedType(node, expression, context) {
    const sourceCode = context.getSourceCode();
    const castedType = getCastTupleFromMemberExpression(expression);
    if (castedType && castedType[1].type !== 'TSAnyKeyword') {
        const nOfParam = node.params.length;
        if (nOfParam === 1 || (nOfParam === 0 && castedType[0].type === 'ThisExpression')) {
            const castedExpressionText = sourceCode.getText(castedType[0]);
            const castedTypeText = sourceCode.getText(castedType[1]);
            const predicate = `: ${castedExpressionText} is ${castedTypeText}`;
            const suggest = getTypePredicateSuggestion(node, context, predicate);
            context.report({
                messageId: 'useTypePredicate',
                data: {
                    castedExpressionText,
                    castedTypeText,
                },
                loc: locations.getMainFunctionTokenLocation(node, getParent(context), context),
                suggest,
            });
        }
    }
}
function getTypePredicateSuggestion(node, context, predicate) {
    const suggestions = [];
    let fix;
    if (node.returnType) {
        fix = fixer => fixer.replaceText(node.returnType, predicate);
    }
    else {
        const closingParenthesis = context
            .getSourceCode()
            .getTokenBefore(node.body, token => token.value === ')');
        fix = fixer => fixer.insertTextAfter(closingParenthesis, predicate);
    }
    suggestions.push({ messageId: 'suggestTypePredicate', fix });
    return suggestions;
}
function getCastTupleFromMemberExpression(node) {
    if (node.type === 'MemberExpression') {
        const object = node.object;
        if (object.type === 'TSAsExpression' || object.type === 'TSTypeAssertion') {
            return [object.expression, object.typeAnnotation];
        }
    }
    return undefined;
}
function isNegation(node) {
    return node.type === 'UnaryExpression' && node.prefix && node.operator === '!';
}
function isUndefined(node) {
    return node.type === 'Identifier' && node.name === 'undefined';
}
function isBooleanCall(node) {
    if (node.type === 'CallExpression') {
        const callee = node.callee;
        return node.arguments.length === 1 && callee.type === 'Identifier' && callee.name === 'Boolean';
    }
    return false;
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$J = {
    meta: {
        messages: {
            safeArg: `Make sure that command line arguments are used safely here.`,
        },
    },
    create(context) {
        return {
            MemberExpression(node) {
                if (isMemberExpression(node, 'process', 'argv')) {
                    context.report({
                        messageId: 'safeArg',
                        node,
                    });
                }
            },
        };
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const ERRORHANDLER_MODULE = 'errorhandler';
const rule$I = {
    meta: {
        messages: {
            deactivateDebug: 'Make sure this debug feature is deactivated before delivering the code in production.',
        },
    },
    create(context) {
        return {
            CallExpression(node) {
                const callExpression = node;
                // app.use(...)
                checkErrorHandlerMiddleware(context, callExpression);
            },
        };
    },
};
function checkErrorHandlerMiddleware(context, callExpression) {
    var _a;
    const { callee, arguments: args } = callExpression;
    if (callee.type === 'MemberExpression' &&
        isIdentifier(callee.property, 'use') &&
        args.length > 0 &&
        !isInsideConditional(context)) {
        for (const m of flattenArgs(context, args)) {
            const middleware = getUniqueWriteUsageOrNode(context, m);
            if (middleware &&
                middleware.type === 'CallExpression' &&
                ((_a = getModuleNameOfNode(context, middleware.callee)) === null || _a === void 0 ? void 0 : _a.value) === ERRORHANDLER_MODULE) {
                context.report({
                    node: middleware,
                    messageId: 'deactivateDebug',
                });
            }
        }
    }
}
function isInsideConditional(context) {
    const ancestors = context.getAncestors();
    return ancestors.some(ancestor => ancestor.type === 'IfStatement');
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$H = {
    meta: {
        messages: {
            safeGenerator: 'Make sure that using this pseudorandom number generator is safe here.',
        },
    },
    create(context) {
        return {
            CallExpression(node) {
                const { callee } = node;
                if (isMemberExpression(callee, 'Math', 'random')) {
                    context.report({
                        messageId: 'safeGenerator',
                        node,
                    });
                }
            },
        };
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
// https://jira.sonarsource.com/browse/RSPEC-5443
const UNIX_DIRECTORIES = [
    '/tmp/',
    '/var/tmp/',
    '/usr/tmp/',
    '/dev/shm/',
    '/dev/mqueue/',
    '/run/lock/',
    '/var/run/lock/',
    '/library/caches/',
    '/users/shared/',
    '/private/tmp/',
    '/private/var/tmp/',
].map(v => new RegExp(`^${v}`, 'i'));
const WINDOWS_DIRECTORIES_PATTERN = new RegExp('^[^\\\\]*(\\\\){1,2}(Windows(\\\\){1,2}Temp|Temp|TMP)(\\\\.*|$)', 'i');
const SENSITIVE_ENV_VARIABLES = ['TMPDIR', 'TMP', 'TEMPDIR', 'TEMP'];
const rule$G = {
    meta: {
        messages: {
            safeDirectory: 'Make sure publicly writable directories are used safely here.',
        },
    },
    create(context) {
        return {
            Literal: (node) => {
                var _a;
                const literal = node;
                // Using literal.raw instead of literal.value as the latter escapes backslashes
                const value = (_a = literal.raw) === null || _a === void 0 ? void 0 : _a.slice(1, literal.raw.length - 1);
                if (value &&
                    (UNIX_DIRECTORIES.find(i => value.match(i)) || value.match(WINDOWS_DIRECTORIES_PATTERN))) {
                    context.report({
                        node: literal,
                        messageId: 'safeDirectory',
                    });
                }
            },
            MemberExpression: (node) => {
                const memberExpression = node;
                const { object, property } = memberExpression;
                if (property.type !== 'Identifier' ||
                    !SENSITIVE_ENV_VARIABLES.includes(property.name) ||
                    object.type !== 'MemberExpression') {
                    return;
                }
                if (object.property.type === 'Identifier' &&
                    object.property.name === 'env' &&
                    object.object.type === 'Identifier' &&
                    object.object.name === 'process') {
                    context.report({ node: memberExpression, messageId: 'safeDirectory' });
                }
            },
        };
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const DEFAULT_THESHOLD = 20;
const rule$F = {
    meta: {
        schema: [
            { type: 'integer' },
            {
                // internal parameter for rules having secondary locations
                enum: ['sonar-runtime'],
            },
        ],
    },
    create(context) {
        const threshold = context.options.length > 0 ? context.options[0] : DEFAULT_THESHOLD;
        const services = context.parserServices;
        const regexNodes = [];
        return {
            'Literal[regex]:exit': (node) => {
                regexNodes.push(node);
            },
            'NewExpression:exit': (node) => {
                if (isRegExpConstructor(node)) {
                    regexNodes.push(node);
                }
            },
            'CallExpression:exit': (node) => {
                const callExpr = node;
                if (parserServices.isRequiredParserServices(services) && isStringRegexMethodCall(callExpr, services)) {
                    regexNodes.push(callExpr.arguments[0]);
                }
                else if (isRegExpConstructor(callExpr)) {
                    regexNodes.push(callExpr);
                }
            },
            'Program:exit': () => {
                regexNodes.forEach(regexNode => checkRegexComplexity(regexNode, threshold, context));
            },
        };
    },
};
function checkRegexComplexity(regexNode, threshold, context) {
    for (const regexParts of findRegexParts(regexNode, context)) {
        let complexity = 0;
        const secondaryLocations = [];
        const secondaryMessages = [];
        for (const regexPart of regexParts) {
            const calculator = new ComplexityCalculator(regexPart, context);
            calculator.visit();
            calculator.components.forEach(component => {
                secondaryLocations.push(component.location);
                secondaryMessages.push(component.message);
            });
            complexity += calculator.complexity;
        }
        if (complexity > threshold) {
            context.report({
                message: toEncodedMessage$1(`Simplify this regular expression to reduce its complexity from ${complexity} to the ${threshold} allowed.`, secondaryLocations, secondaryMessages, complexity - threshold),
                node: regexParts[0],
            });
        }
    }
}
function findRegexParts(node, context) {
    const finder = new RegexPartFinder(context);
    finder.find(node);
    return finder.parts;
}
class RegexPartFinder {
    constructor(context) {
        this.context = context;
        this.parts = [];
    }
    find(node) {
        if (isRegExpConstructor(node)) {
            this.find(node.arguments[0]);
        }
        else if (isRegexLiteral(node)) {
            this.parts.push([node]);
        }
        else if (isStringLiteral(node)) {
            this.parts.push([node]);
        }
        else if (isStaticTemplateLiteral(node)) {
            this.parts.push([node]);
        }
        else if (isIdentifier(node)) {
            const initializer = getUniqueWriteUsage(this.context, node.name);
            if (initializer) {
                this.find(initializer);
            }
        }
        else if (isBinaryPlus(node)) {
            const literals = [];
            this.findInStringConcatenation(node.left, literals);
            this.findInStringConcatenation(node.right, literals);
            if (literals.length > 0) {
                this.parts.push(literals);
            }
        }
    }
    findInStringConcatenation(node, literals) {
        if (isStringLiteral(node)) {
            literals.push(node);
        }
        else if (isBinaryPlus(node)) {
            this.findInStringConcatenation(node.left, literals);
            this.findInStringConcatenation(node.right, literals);
        }
        else {
            this.find(node);
        }
    }
}
class ComplexityCalculator {
    constructor(regexPart, context) {
        this.regexPart = regexPart;
        this.context = context;
        this.nesting = 1;
        this.complexity = 0;
        this.components = [];
        this.regexPartAST = getParsedRegex(regexPart, context);
    }
    visit() {
        if (!this.regexPartAST) {
            return;
        }
        regexpp__namespace.visitRegExpAST(this.regexPartAST, {
            onAssertionEnter: (node) => {
                /* lookaround */
                if (node.kind === 'lookahead' || node.kind === 'lookbehind') {
                    const [start, end] = getRegexpRange(this.regexPart, node);
                    this.increaseComplexity(this.nesting, node, [
                        0,
                        -(end - start - 1) + (node.kind === 'lookahead' ? '?='.length : '?<='.length),
                    ]);
                    this.nesting++;
                    this.onDisjunctionEnter(node);
                }
            },
            onAssertionLeave: (node) => {
                /* lookaround */
                if (node.kind === 'lookahead' || node.kind === 'lookbehind') {
                    this.onDisjunctionLeave(node);
                    this.nesting--;
                }
            },
            onBackreferenceEnter: (node) => {
                this.increaseComplexity(1, node);
            },
            onCapturingGroupEnter: (node) => {
                /* disjunction */
                this.onDisjunctionEnter(node);
            },
            onCapturingGroupLeave: (node) => {
                /* disjunction */
                this.onDisjunctionLeave(node);
            },
            onCharacterClassEnter: (node) => {
                /* character class */
                const [start, end] = getRegexpRange(this.regexPart, node);
                this.increaseComplexity(1, node, [0, -(end - start - 1)]);
                this.nesting++;
            },
            onCharacterClassLeave: (_node) => {
                /* character class */
                this.nesting--;
            },
            onGroupEnter: (node) => {
                /* disjunction */
                this.onDisjunctionEnter(node);
            },
            onGroupLeave: (node) => {
                /* disjunction */
                this.onDisjunctionLeave(node);
            },
            onPatternEnter: (node) => {
                /* disjunction */
                this.onDisjunctionEnter(node);
            },
            onPatternLeave: (node) => {
                /* disjunction */
                this.onDisjunctionLeave(node);
            },
            onQuantifierEnter: (node) => {
                /* repetition */
                const [start] = getRegexpRange(this.regexPart, node);
                const [, end] = getRegexpRange(this.regexPart, node.element);
                this.increaseComplexity(this.nesting, node, [end - start, 0]);
                this.nesting++;
            },
            onQuantifierLeave: (_node) => {
                /* repetition */
                this.nesting--;
            },
        });
    }
    increaseComplexity(increment, node, offset) {
        this.complexity += increment;
        let message = '+' + increment;
        if (increment > 1) {
            message += ` (incl ${increment - 1} for nesting)`;
        }
        const loc = getRegexpLocation(this.regexPart, node, this.context, offset);
        this.components.push({
            location: {
                loc,
            },
            message,
        });
    }
    onDisjunctionEnter(node) {
        if (node.alternatives.length > 1) {
            let { alternatives } = node;
            let increment = this.nesting;
            while (alternatives.length > 1) {
                const [start, end] = getRegexpRange(this.regexPart, alternatives[1]);
                this.increaseComplexity(increment, alternatives[1], [-1, -(end - start)]);
                increment = 1;
                alternatives = alternatives.slice(1);
            }
            this.nesting++;
        }
    }
    onDisjunctionLeave(node) {
        if (node.alternatives.length > 1) {
            this.nesting--;
        }
    }
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const stringMethods = ['match', 'search', 'split'];
const minPatternLength = 3;
const specialChars = ['+', '*', '{'];
const rule$E = {
    meta: {
        messages: {
            safeRegex: 'Make sure that using a regular expression is safe here.',
        },
    },
    create(context) {
        return {
            Literal(node) {
                const { regex } = node;
                if (regex) {
                    const { pattern } = regex;
                    if (isUnsafeRegexLiteral(pattern)) {
                        context.report({
                            messageId: 'safeRegex',
                            node,
                        });
                    }
                }
            },
            CallExpression(node) {
                const { callee, arguments: args } = node;
                if (isMemberWithProperty$1(callee, ...stringMethods)) {
                    checkFirstArgument(args, context);
                }
            },
            NewExpression(node) {
                const { callee, arguments: args } = node;
                if (isIdentifier(callee, 'RegExp')) {
                    checkFirstArgument(args, context);
                }
            },
        };
    },
};
function checkFirstArgument(args, context) {
    const firstArg = args[0];
    if (firstArg &&
        firstArg.type === 'Literal' &&
        typeof firstArg.value === 'string' &&
        isUnsafeRegexLiteral(firstArg.value)) {
        context.report({
            messageId: 'safeRegex',
            node: firstArg,
        });
    }
}
function isUnsafeRegexLiteral(value) {
    return value.length >= minPatternLength && hasEnoughNumberOfSpecialChars(value);
}
function hasEnoughNumberOfSpecialChars(value) {
    let numberOfSpecialChars = 0;
    for (const c of value) {
        if (specialChars.includes(c)) {
            numberOfSpecialChars++;
        }
        if (numberOfSpecialChars === 2) {
            return true;
        }
    }
    return false;
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$D = {
    meta: {
        messages: {
            createSession: 'Create a new session during user authentication to prevent session fixation attacks.',
        },
    },
    create(context) {
        let sessionRegenerate = false;
        function isSessionRegenerate(node) {
            return (node.type === 'CallExpression' &&
                node.callee.type === 'MemberExpression' &&
                isIdentifier(node.callee.property, 'regenerate'));
        }
        function visitCallback(node) {
            if (sessionRegenerate) {
                // terminate recursion once call is detected
                return;
            }
            if (isSessionRegenerate(node)) {
                sessionRegenerate = true;
                return;
            }
            childrenOf$1(node, context.getSourceCode().visitorKeys).forEach(visitCallback);
        }
        function hasSessionFalseOption(callExpression) {
            const opt = callExpression.arguments[1];
            if ((opt === null || opt === void 0 ? void 0 : opt.type) === 'ObjectExpression') {
                const sessionProp = getPropertyWithValue(context, opt, 'session', false);
                return !!sessionProp;
            }
            return false;
        }
        return {
            CallExpression: (node) => {
                const callExpression = node;
                if (isCallToFQN(context, callExpression, 'passport', 'authenticate')) {
                    if (hasSessionFalseOption(callExpression)) {
                        return;
                    }
                    const parent = last$1(context.getAncestors());
                    if (parent.type === 'CallExpression') {
                        const callback = getValueOfExpression(context, parent.arguments[2], 'FunctionExpression');
                        if (callback && callback.type === 'FunctionExpression') {
                            sessionRegenerate = false;
                            visitCallback(callback);
                            if (!sessionRegenerate) {
                                context.report({ node: callback, messageId: 'createSession' });
                            }
                        }
                    }
                }
            },
        };
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$C = {
    meta: {
        schema: [
            {
                // internal parameter for rules having secondary locations
                enum: ['sonar-runtime'],
            },
        ],
    },
    create(context) {
        function raiseIssue(node, begin, end, positionMessage) {
            const properties = node.properties;
            const secondaryNodes = [];
            const secondaryMessages = [];
            for (let i = begin; i < end; i++) {
                const prop = properties[i];
                if (prop.shorthand) {
                    secondaryNodes.push(prop);
                    secondaryMessages.push(`Move to ${positionMessage}`);
                }
            }
            const message = toEncodedMessage$1(`Group all shorthand properties at ${positionMessage} of this object declaration.`, secondaryNodes, secondaryMessages);
            context.report({
                message,
                loc: context.getSourceCode().getFirstToken(node).loc,
            });
        }
        return {
            ObjectExpression(node) {
                const objectExpression = node;
                const objectExpressionProperties = objectExpression.properties;
                if (objectExpressionProperties.some(p => p.type !== 'Property')) {
                    return;
                }
                const isShorthandPropertyList = objectExpressionProperties.map(p => p.shorthand);
                const shorthandPropertiesNumber = isShorthandPropertyList.filter(b => b).length;
                const numberOfShorthandAtBeginning = getNumberOfTrueAtBeginning(isShorthandPropertyList);
                const numberOfShorthandAtEnd = getNumberOfTrueAtBeginning([...isShorthandPropertyList].reverse());
                const allAtBeginning = numberOfShorthandAtBeginning === shorthandPropertiesNumber;
                const allAtEnd = numberOfShorthandAtEnd === shorthandPropertiesNumber;
                const propertiesNumber = isShorthandPropertyList.length;
                if (!allAtBeginning && numberOfShorthandAtBeginning > numberOfShorthandAtEnd) {
                    raiseIssue(objectExpression, numberOfShorthandAtBeginning, propertiesNumber, 'the beginning');
                }
                else if (!allAtEnd && numberOfShorthandAtEnd > numberOfShorthandAtBeginning) {
                    raiseIssue(objectExpression, 0, propertiesNumber - numberOfShorthandAtEnd, 'the end');
                }
                else if (!allAtBeginning && !allAtEnd) {
                    raiseIssue(objectExpression, 0, propertiesNumber, 'either the beginning or end');
                }
            },
        };
    },
};
function getNumberOfTrueAtBeginning(list) {
    let numberOfTrueAtBeginning = 0;
    for (const b of list) {
        if (b) {
            numberOfTrueAtBeginning++;
        }
        else {
            break;
        }
    }
    return numberOfTrueAtBeginning;
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$B = createRegExpRule(context => {
    function checkAlternation(alternation) {
        const { alternatives } = alternation;
        if (alternatives.length <= 1) {
            return;
        }
        if (alternatives.every(alt => alt.elements.length === 1 && alt.elements[0].type === 'Character')) {
            context.reportRegExpNode({
                message: 'Replace this alternation with a character class.',
                node: context.node,
                regexpNode: alternation,
            });
        }
    }
    return {
        onPatternEnter: checkAlternation,
        onGroupEnter: checkAlternation,
        onCapturingGroupEnter: checkAlternation,
        onAssertionEnter(node) {
            if (node.kind === 'lookahead' || node.kind === 'lookbehind') {
                checkAlternation(node);
            }
        },
    };
});

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const message = `Make sure the regex used here, which is vulnerable to super-linear runtime due to backtracking, cannot lead to denial of service.`;
const rule$A = createRegExpRule(context => {
    return {
        onRegExpLiteralEnter: (node) => {
            const { reports } = scslre.analyse(node);
            if (reports.length > 0) {
                context.report({
                    message,
                    node: context.node,
                });
            }
        },
    };
});

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const NET_MODULE = 'net';
const SOCKET_CREATION_FUNCTIONS = new Set(['createConnection', 'connect']);
const SOCKET_CONSTRUCTOR = 'Socket';
const rule$z = {
    meta: {
        messages: {
            safeSocket: 'Make sure that sockets are used safely here.',
        },
    },
    create(context) {
        return {
            NewExpression: (node) => checkCallExpression$1(node, context),
            CallExpression: (node) => checkCallExpression$1(node, context),
        };
    },
};
function checkCallExpression$1({ callee, type }, context) {
    let moduleName;
    let expression;
    if (callee.type === 'MemberExpression' && callee.object.type === 'Identifier') {
        moduleName = getModuleNameOfIdentifier(context, callee.object);
        expression = callee.property;
    }
    if (callee.type === 'Identifier') {
        moduleName = getModuleNameOfImportedIdentifier(context, callee);
        expression = callee;
    }
    if (expression && isQuestionable$1(expression, type === 'NewExpression', moduleName)) {
        context.report({ messageId: 'safeSocket', node: callee });
    }
}
function isQuestionable$1(expression, isConstructor, moduleName) {
    if (!moduleName || moduleName.value !== NET_MODULE || expression.type !== 'Identifier') {
        return false;
    }
    if (isConstructor) {
        return expression.name === SOCKET_CONSTRUCTOR;
    }
    return SOCKET_CREATION_FUNCTIONS.has(expression.name);
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$y = {
    meta: {
        schema: [
            {
                // internal parameter for rules having secondary locations
                enum: ['sonar-runtime'],
            },
        ],
    },
    create(context) {
        let scopeRanges = [];
        let reported = [];
        function enterScope(node) {
            scopeRanges.push(node.range);
        }
        function exitScope() {
            scopeRanges.pop();
        }
        return {
            Program(node) {
                scopeRanges = [node.range];
                reported = [];
            },
            BlockStatement: enterScope,
            'BlockStatement:exit': exitScope,
            ForStatement: enterScope,
            'ForStatement:exit': exitScope,
            ForInStatement: enterScope,
            'ForInStatement:exit': exitScope,
            ForOfStatement: enterScope,
            'ForOfStatement:exit': exitScope,
            SwitchStatement: enterScope,
            'SwitchStatement:exit': exitScope,
            VariableDeclaration: (node) => {
                const varDeclaration = node;
                if (varDeclaration.kind !== 'var') {
                    return;
                }
                const scopeRange = scopeRanges[scopeRanges.length - 1];
                function isOutsideOfScope(reference) {
                    const idRange = reference.range;
                    return idRange[0] < scopeRange[0] || idRange[1] > scopeRange[1];
                }
                context.getDeclaredVariables(node).forEach(variable => {
                    const referencesOutside = variable.references
                        .map(ref => ref.identifier)
                        .filter(isOutsideOfScope);
                    if (referencesOutside.length === 0) {
                        return;
                    }
                    const definition = variable.defs.find(def => varDeclaration.declarations.includes(def.node));
                    if (definition && !reported.includes(definition.name)) {
                        context.report({
                            node: definition.name,
                            message: toEncodedMessage$1(`Consider moving declaration of '${variable.name}' ` +
                                `as it is referenced outside current binding context.`, referencesOutside, Array(referencesOutside.length).fill('Outside reference.')),
                        });
                        variable.defs.map(def => def.name).forEach(defId => reported.push(defId));
                    }
                });
            },
        };
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$x = {
    meta: {
        messages: {
            functionMaxLine: 'This function has {{lineCount}} lines, which is greater than the {{threshold}} lines authorized. Split it into smaller functions.',
        },
        schema: [{ type: 'integer' }],
    },
    create(context) {
        const [threshold] = context.options;
        const sourceCode = context.getSourceCode();
        const lines = sourceCode.lines;
        const commentLineNumbers = getCommentLineNumbers(sourceCode.getAllComments());
        return {
            'FunctionDeclaration, FunctionExpression, ArrowFunctionExpression': (node) => {
                const parent = getParent(context);
                if (!node.loc || isIIFE(node, parent)) {
                    return;
                }
                const lineCount = getLocsNumber(node.loc, lines, commentLineNumbers);
                if (lineCount > threshold) {
                    context.report({
                        messageId: 'functionMaxLine',
                        data: {
                            lineCount: lineCount.toString(),
                            threshold,
                        },
                        loc: locations.getMainFunctionTokenLocation(node, getParent(context), context),
                    });
                }
            },
        };
    },
};
function getLocsNumber(loc, lines, commentLineNumbers) {
    let lineCount = 0;
    for (let i = loc.start.line - 1; i < loc.end.line; ++i) {
        const line = lines[i];
        const comment = commentLineNumbers.get(i + 1);
        if (comment && isFullLineComment(line, i + 1, comment)) {
            continue;
        }
        if (line.match(/^\s*$/u)) {
            continue;
        }
        lineCount++;
    }
    return lineCount;
}
function getCommentLineNumbers(comments) {
    const map = new Map();
    comments.forEach(comment => {
        if (comment.loc) {
            for (let i = comment.loc.start.line; i <= comment.loc.end.line; i++) {
                map.set(i, comment);
            }
        }
    });
    return map;
}
function isFullLineComment(line, lineNumber, comment) {
    if (!comment.loc) {
        return false;
    }
    const start = comment.loc.start, end = comment.loc.end, isFirstTokenOnLine = start.line === lineNumber && !line.slice(0, start.column).trim(), isLastTokenOnLine = end.line === lineNumber && !line.slice(end.column).trim();
    return (comment &&
        (start.line < lineNumber || isFirstTokenOnLine) &&
        (end.line > lineNumber || isLastTokenOnLine));
}
function isIIFE(node, parent) {
    return (node.type === 'FunctionExpression' &&
        parent &&
        parent.type === 'CallExpression' &&
        parent.callee === node);
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$w = {
    meta: {
        messages: {
            maxFileLine: 'This file has {{lineCount}} lines, which is greater than {{threshold}} authorized. Split it into smaller files.',
        },
        schema: [{ type: 'integer' }],
    },
    create(context) {
        const [threshold] = context.options;
        const sourceCode = context.getSourceCode();
        const lines = sourceCode.lines;
        const commentLineNumbers = getCommentLineNumbers(sourceCode.getAllComments());
        return {
            'Program:exit': (node) => {
                if (!node.loc) {
                    return;
                }
                const lineCount = getLocsNumber(node.loc, lines, commentLineNumbers);
                if (lineCount > threshold) {
                    context.report({
                        messageId: 'maxFileLine',
                        data: {
                            lineCount: lineCount.toString(),
                            threshold,
                        },
                        loc: { line: 0, column: 0 },
                    });
                }
            },
        };
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$v = createRegExpRule(context => {
    return {
        onCharacterEnter: (character) => {
            const { value, raw } = character;
            if (value >= 0x00 && value <= 0x1f && (raw.startsWith('\\x') || raw.startsWith('\\u'))) {
                context.reportRegExpNode({
                    message: `Remove this control character: ${character.raw}.`,
                    node: context.node,
                    regexpNode: character,
                });
            }
        },
    };
});

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$u = {
    meta: {
        messages: {
            switchEnd: 'End this switch case with an unconditional break, continue, return or throw statement.',
        },
    },
    create(context) {
        let currentCodePath = null;
        let currentCodeSegment = null;
        let enteringSwitchCase = false;
        const segmentsWithExit = new Set();
        const initialSegmentBySwitchCase = new Map();
        const switchCaseStack = [];
        function noComment(node) {
            return context.getSourceCode().getCommentsAfter(node).length === 0;
        }
        function isAfterProcessExitCall(segment, initialSegment) {
            const stack = [];
            const visitedSegments = new Set();
            stack.push(segment);
            while (stack.length !== 0) {
                const current = stack.pop();
                visitedSegments.add(current.id);
                if (!segmentsWithExit.has(current.id)) {
                    if (current === initialSegment) {
                        return false;
                    }
                    current.prevSegments.filter(p => !visitedSegments.has(p.id)).forEach(p => stack.push(p));
                }
            }
            return true;
        }
        return {
            onCodePathStart(codePath) {
                currentCodePath = codePath;
            },
            onCodePathEnd() {
                currentCodePath = currentCodePath.upper;
            },
            onCodePathSegmentStart(segment) {
                currentCodeSegment = segment;
                if (enteringSwitchCase) {
                    initialSegmentBySwitchCase.set(switchCaseStack.pop(), currentCodeSegment);
                    enteringSwitchCase = false;
                }
            },
            CallExpression(node) {
                const callExpr = node;
                if (isProcessExitCall(callExpr)) {
                    segmentsWithExit.add(currentCodeSegment.id);
                }
            },
            SwitchCase(node) {
                enteringSwitchCase = true;
                switchCaseStack.push(node);
            },
            'SwitchCase:exit'(node) {
                const switchCase = node;
                const initialSegment = initialSegmentBySwitchCase.get(switchCase);
                const isReachable = currentCodePath.currentSegments.some(s => s.reachable && !isAfterProcessExitCall(s, initialSegment));
                const { cases } = getParent(context);
                if (isReachable &&
                    switchCase.consequent.length > 0 &&
                    cases[cases.length - 1] !== node &&
                    noComment(switchCase)) {
                    context.report({
                        messageId: 'switchEnd',
                        loc: context.getSourceCode().getFirstToken(node).loc,
                    });
                }
            },
        };
    },
};
function isProcessExitCall(callExpr) {
    return (callExpr.callee.type === 'MemberExpression' &&
        callExpr.callee.object.type === 'Identifier' &&
        callExpr.callee.object.name === 'process' &&
        callExpr.callee.property.type === 'Identifier' &&
        callExpr.callee.property.name === 'exit');
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const validator = new regexpp.RegExpValidator();
const rule$t = {
    create(context) {
        function getFlags(node) {
            if (node.arguments.length < 2) {
                return '';
            }
            if (isStringLiteral(node.arguments[1])) {
                return node.arguments[1].value;
            }
            return null;
        }
        function validateRegExpPattern(pattern, uFlag) {
            try {
                validator.validatePattern(pattern, undefined, undefined, uFlag);
                return null;
            }
            catch (err) {
                return err.message;
            }
        }
        function validateRegExpFlags(flags) {
            try {
                validator.validateFlags(flags);
                return null;
            }
            catch (_a) {
                return `Invalid flags supplied to RegExp constructor '${flags}'`;
            }
        }
        function isRegExpConstructor(call) {
            const { callee } = call;
            return callee.type === 'Identifier' && callee.name === 'RegExp';
        }
        function isStringMatch(call) {
            const services = context.parserServices;
            if (!parserServices.isRequiredParserServices(services)) {
                return false;
            }
            const { callee } = call;
            return (callee.type === 'MemberExpression' &&
                isStringType$1(getTypeFromTreeNode$1(callee.object, services)) &&
                isIdentifier(callee.property, 'match'));
        }
        function getPattern(call) {
            if (isStringLiteral(call.arguments[0])) {
                return call.arguments[0].value;
            }
            return null;
        }
        return {
            'CallExpression, NewExpression'(node) {
                const call = node;
                if (!isRegExpConstructor(call) && !isStringMatch(call)) {
                    return;
                }
                const pattern = getPattern(call);
                if (!pattern) {
                    return;
                }
                const flags = getFlags(call);
                const message = (flags && validateRegExpFlags(flags)) ||
                    // If flags are unknown, report the regex only if its pattern is invalid both with and without the "u" flag
                    (flags === null
                        ? validateRegExpPattern(pattern, true) && validateRegExpPattern(pattern, false)
                        : validateRegExpPattern(pattern, flags.includes('u')));
                if (message) {
                    context.report({
                        node,
                        message,
                    });
                }
            },
        };
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$s = createRegExpRule(context => {
    function characters(nodes) {
        let current = [];
        const sequences = [current];
        for (const node of nodes) {
            if (node.type === 'Character') {
                current.push(node);
            }
            else if (node.type === 'CharacterClassRange') {
                // for following regexp [xa-z] we produce [[xa],[z]]
                // we would report for example if instead of 'xa' there would be unicode combined class
                current.push(node.min);
                current = [node.max];
                sequences.push(current);
            }
            else if (node.type === 'CharacterSet' && current.length > 0) {
                // CharacterSet is for example [\d], ., or \p{ASCII}
                // see https://github.com/mysticatea/regexpp/blob/master/src/ast.ts#L222
                current = [];
                sequences.push(current);
            }
        }
        return sequences;
    }
    return {
        onCharacterClassEnter(ccNode) {
            for (const chars of characters(ccNode.elements)) {
                const idx = chars.findIndex((c, i) => i !== 0 && isCombiningCharacter(c.value) && !isCombiningCharacter(chars[i - 1].value));
                if (idx >= 0) {
                    const combinedChar = chars[idx - 1].raw + chars[idx].raw;
                    const message = `Move this Unicode combined character '${combinedChar}' outside of [...]`;
                    context.reportRegExpNode({ regexpNode: chars[idx], node: context.node, message });
                }
            }
        },
    };
});
function isCombiningCharacter(codePoint) {
    return /^[\p{Mc}\p{Me}\p{Mn}]$/u.test(String.fromCodePoint(codePoint));
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$r = createRegExpRule(context => {
    let rawPattern;
    return {
        onRegExpLiteralEnter: (node) => {
            rawPattern = node.raw;
        },
        onCharacterEnter: (node) => {
            if (node.raw !== ' ' || node.parent.type === 'CharacterClass') {
                return;
            }
            const nextChar = rawPattern[node.start + 1];
            if (nextChar !== ' ') {
                const spacesBefore = countSpacesBefore(rawPattern, node.start);
                if (spacesBefore > 0) {
                    const spacesNumber = spacesBefore + 1;
                    context.reportRegExpNode({
                        message: `If multiple spaces are required here, use number quantifier ({${spacesNumber}}).`,
                        regexpNode: node,
                        offset: [-spacesNumber + 1, 0],
                        node: context.node,
                    });
                }
            }
        },
    };
});
function countSpacesBefore(pattern, index) {
    let counter = 0;
    for (let i = index - 1; i > 0; i--) {
        if (pattern[i] === ' ') {
            counter++;
        }
        else {
            break;
        }
    }
    return counter;
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
// https://jira.sonarsource.com/browse/RSPEC-1481
const rule$q = {
    meta: {
        messages: {
            unusedFunction: `Remove unused function '{{symbol}}'.`,
            unusedVariable: `Remove the declaration of the unused '{{symbol}}' variable.`,
        },
    },
    create(context) {
        let toIgnore = [];
        let jsxComponentsToIgnore = [];
        function checkVariable(v, toCheck) {
            if (v.defs.length === 0) {
                return;
            }
            const type = v.defs[0].type;
            if (type !== 'Variable' && type !== 'FunctionName') {
                return;
            }
            if (toCheck === 'let-const-function') {
                const def = v.defs[0];
                if (def.parent && def.parent.type === 'VariableDeclaration' && def.parent.kind === 'var') {
                    return;
                }
            }
            const defs = v.defs.map(def => def.name);
            const unused = v.references.every(ref => defs.includes(ref.identifier));
            if (unused && !toIgnore.includes(defs[0]) && !jsxComponentsToIgnore.includes(v.name)) {
                const messageAndData = getMessageAndData(v.name, type === 'FunctionName');
                defs.forEach(def => context.report(Object.assign({ node: def }, messageAndData)));
            }
        }
        function isParentOfModuleScope(scope) {
            return scope.childScopes.some(s => s.type === 'module');
        }
        function checkScope(scope, checkedInParent) {
            let toCheck = checkedInParent;
            if (scope.type === 'function' && !isParentOfModuleScope(scope)) {
                toCheck = 'all';
            }
            else if (checkedInParent === 'nothing' && scope.type === 'block') {
                toCheck = 'let-const-function';
            }
            if (toCheck !== 'nothing' && scope.type !== 'function-expression-name') {
                scope.variables.forEach(v => checkVariable(v, toCheck));
            }
            scope.childScopes.forEach(childScope => checkScope(childScope, toCheck));
        }
        return {
            ObjectPattern: (node) => {
                const elements = node.properties;
                const hasRest = elements.some(element => element.type === 'RestElement');
                if (!hasRest) {
                    return;
                }
                elements.forEach(element => {
                    if (element.type === 'Property' &&
                        element.shorthand &&
                        element.value.type === 'Identifier') {
                        toIgnore.push(element.value);
                    }
                });
            },
            JSXIdentifier: (node) => {
                // using 'any' as standard typings for AST don't provide types for JSX
                jsxComponentsToIgnore.push(node.name);
            },
            'Program:exit': () => {
                checkScope(context.getScope(), 'nothing');
                toIgnore = [];
                jsxComponentsToIgnore = [];
            },
        };
    },
};
function getMessageAndData(name, isFunction) {
    if (isFunction) {
        return { messageId: 'unusedFunction', data: { symbol: name } };
    }
    else {
        return { messageId: 'unusedVariable', data: { symbol: name } };
    }
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const dbModules = ['pg', 'mysql', 'mysql2', 'sequelize'];
const rule$p = {
    meta: {
        messages: {
            safeQuery: `Make sure that executing SQL queries is safe here.`,
        },
    },
    create(context) {
        let isDbModuleImported = false;
        return {
            Program() {
                // init flag for each file
                isDbModuleImported = false;
            },
            ImportDeclaration(node) {
                const { source } = node;
                if (dbModules.includes(String(source.value))) {
                    isDbModuleImported = true;
                }
            },
            CallExpression(node) {
                const call = node;
                const { callee, arguments: args } = call;
                if (isRequireModule(call, ...dbModules)) {
                    isDbModuleImported = true;
                    return;
                }
                if (isDbModuleImported &&
                    isMemberWithProperty$1(callee, 'query') &&
                    isQuestionable(args[0])) {
                    context.report({
                        messageId: 'safeQuery',
                        node: callee,
                    });
                }
            },
        };
    },
};
function isQuestionable(sqlQuery) {
    if (!sqlQuery) {
        return false;
    }
    if (isTemplateWithVar(sqlQuery)) {
        return true;
    }
    if (isConcatenation(sqlQuery)) {
        return isVariableConcat(sqlQuery);
    }
    return (sqlQuery.type === 'CallExpression' && isMemberWithProperty$1(sqlQuery.callee, 'concat', 'replace'));
}
function isVariableConcat(node) {
    const { left, right } = node;
    if (!isHardcodedLiteral(right)) {
        return true;
    }
    if (isConcatenation(left)) {
        return isVariableConcat(left);
    }
    return !isHardcodedLiteral(left);
}
function isTemplateWithVar(node) {
    return node.type === 'TemplateLiteral' && node.expressions.length !== 0;
}
function isTemplateWithoutVar(node) {
    return node.type === 'TemplateLiteral' && node.expressions.length === 0;
}
function isConcatenation(node) {
    return node.type === 'BinaryExpression' && node.operator === '+';
}
function isHardcodedLiteral(node) {
    return node.type === 'Literal' || isTemplateWithoutVar(node);
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$o = {
    meta: {
        messages: {
            safeStdin: `Make sure that reading the standard input is safe here.`,
        },
    },
    create(context) {
        return {
            MemberExpression(node) {
                if (isMemberExpression(node, 'process', 'stdin')) {
                    context.report({
                        messageId: 'safeStdin',
                        node,
                    });
                }
            },
        };
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$n = {
    meta: {
        schema: [
            {
                // internal parameter for rules having secondary locations
                enum: ['sonar-runtime'],
            },
        ],
    },
    create(context) {
        const invocations = new Map();
        const regexes = [];
        const resets = new Set();
        return {
            'Literal:exit': (node) => {
                extractRegex(node, regexes);
            },
            'CallExpression:exit': (node) => {
                const callExpr = node;
                extractRegex(node, regexes);
                extractRegexInvocation(callExpr, regexes, invocations, context);
                checkWhileConditionRegex(callExpr, context);
            },
            'MemberExpression:exit': (node) => {
                extractResetRegex(node, regexes, resets, context);
            },
            'NewExpression:exit': (node) => {
                extractRegex(node, regexes);
            },
            'Program:exit': () => {
                regexes.forEach(regex => checkGlobalStickyRegex(regex, context));
                invocations.forEach((usages, regex) => checkMultipleInputsRegex(regex, usages, resets, context));
            },
        };
    },
};
function extractRegex(node, acc) {
    if (isRegexLiteral(node)) {
        const { flags } = node.regex;
        acc.push({ node, flags });
    }
    else if (isRegExpConstructor(node)) {
        const flags = getFlags(node) || '';
        acc.push({ node, flags });
    }
}
function extractRegexInvocation(callExpr, regexes, invocations, context) {
    if (isCallingMethod(callExpr, 1, 'exec', 'test') &&
        callExpr.callee.object.type === 'Identifier') {
        const { object } = callExpr.callee;
        const variable = getVariableFromName(context, object.name);
        if (variable) {
            const value = getUniqueWriteUsage(context, variable.name);
            const regex = regexes.find(r => r.node === value);
            if (regex && regex.flags.includes('g')) {
                const usages = invocations.get(variable);
                if (usages) {
                    usages.push(callExpr);
                }
                else {
                    invocations.set(variable, [callExpr]);
                }
            }
        }
    }
}
function extractResetRegex(node, regexes, resets, context) {
    /* RegExp.prototype.lastIndex = ... */
    if (isDotNotation(node) &&
        node.object.type === 'Identifier' &&
        node.property.name === 'lastIndex') {
        const parent = getParent(context);
        if ((parent === null || parent === void 0 ? void 0 : parent.type) === 'AssignmentExpression' && parent.left === node) {
            const variable = getVariableFromName(context, node.object.name);
            if (variable) {
                const value = getUniqueWriteUsage(context, variable.name);
                const regex = regexes.find(r => r.node === value);
                if (regex) {
                    resets.add(variable);
                }
            }
        }
    }
}
function checkWhileConditionRegex(callExpr, context) {
    /* RegExp.prototype.exec() within while conditions */
    if (isMethodCall(callExpr)) {
        const { object, property } = callExpr.callee;
        if ((isRegexLiteral(object) || isRegExpConstructor(object)) && property.name === 'exec') {
            const flags = object.type === 'Literal' ? object.regex.flags : getFlags(object);
            if (flags && flags.includes('g') && isWithinWhileCondition(callExpr, context)) {
                context.report({
                    message: toEncodedMessage$1('Extract this regular expression to avoid infinite loop.', []),
                    node: object,
                });
            }
        }
    }
}
function checkGlobalStickyRegex(regex, context) {
    /* RegExp with `g` and `y` flags */
    if (regex.flags.includes('g') && regex.flags.includes('y')) {
        context.report({
            message: toEncodedMessage$1(`Remove the 'g' flag from this regex as it is shadowed by the 'y' flag.`, []),
            node: regex.node,
        });
    }
}
function checkMultipleInputsRegex(regex, usages, resets, context) {
    /* RegExp.prototype.exec(input) / RegExp.prototype.test(input) */
    if (!resets.has(regex)) {
        const definition = regex.defs.find(def => def.type === 'Variable' && def.node.init);
        const uniqueInputs = new Set(usages.map(callExpr => context.getSourceCode().getText(callExpr.arguments[0])));
        const regexReset = uniqueInputs.has(`''`) || uniqueInputs.has(`""`);
        if (definition && uniqueInputs.size > 1 && !regexReset) {
            const pattern = definition.node.init;
            context.report({
                message: toEncodedMessage$1(`Remove the 'g' flag from this regex as it is used on different inputs.`, usages, usages.map((_, idx) => `Usage ${idx + 1}`)),
                node: pattern,
            });
        }
    }
}
function isWithinWhileCondition(node, context) {
    const ancestors = context.getAncestors();
    let parent;
    let child = node;
    while ((parent = ancestors.pop()) !== undefined) {
        if (functionLike$1.has(parent.type)) {
            break;
        }
        if (parent.type === 'WhileStatement' || parent.type === 'DoWhileStatement') {
            return parent.test === child;
        }
        child = parent;
    }
    return false;
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const HSTS = 'hsts';
const HELMET$1 = 'helmet';
const MAX_AGE = 'maxAge';
const INCLUDE_SUB_DOMAINS = 'includeSubDomains';
const RECOMMENDED_MAX_AGE = 15552000;
const rule$m = Express.SensitiveMiddlewarePropertyRule(findSensitiveTransportSecurityPolicyProperty, `Disabling Strict-Transport-Security policy is security-sensitive.`);
function findSensitiveTransportSecurityPolicyProperty(context, node) {
    const sensitiveFinders = [findSensitiveHsts, findSensitiveMaxAge, findSensitiveIncludeSubDomains];
    const sensitives = [];
    const { callee, arguments: args } = node;
    if (args.length === 1 && args[0].type === 'ObjectExpression') {
        const [options] = args;
        for (const finder of sensitiveFinders) {
            const maybeSensitive = finder(context, callee, options);
            if (maybeSensitive) {
                sensitives.push(maybeSensitive);
            }
        }
    }
    return sensitives;
}
function findSensitiveHsts(context, middleware, options) {
    if (isModuleNode(context, middleware, HELMET$1)) {
        return getPropertyWithValue(context, options, HSTS, false);
    }
    return undefined;
}
function findSensitiveMaxAge(context, middleware, options) {
    if (isHstsMiddlewareNode(context, middleware)) {
        const maybeMaxAgeProperty = getObjectExpressionProperty(options, MAX_AGE);
        if (maybeMaxAgeProperty) {
            const maybeMaxAgeValue = getValueOfExpression(context, maybeMaxAgeProperty.value, 'Literal');
            if (typeof (maybeMaxAgeValue === null || maybeMaxAgeValue === void 0 ? void 0 : maybeMaxAgeValue.value) === 'number' &&
                maybeMaxAgeValue.value < RECOMMENDED_MAX_AGE) {
                return maybeMaxAgeProperty;
            }
        }
    }
    return undefined;
}
function findSensitiveIncludeSubDomains(context, middleware, options) {
    if (isHstsMiddlewareNode(context, middleware)) {
        return getPropertyWithValue(context, options, INCLUDE_SUB_DOMAINS, false);
    }
    return undefined;
}
function isHstsMiddlewareNode(context, node) {
    return (isModuleNode(context, node, HSTS) ||
        (node.type === 'MemberExpression' &&
            isModuleNode(context, node.object, HELMET$1) &&
            node.property.type === 'Identifier' &&
            node.property.name === HSTS));
}
function isModuleNode(context, node, moduleName) {
    var _a;
    return node.type === 'Identifier' && ((_a = getModuleNameOfNode(context, node)) === null || _a === void 0 ? void 0 : _a.value) === moduleName;
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$l = {
    meta: {
        schema: [
            {
                // internal parameter for rules having secondary locations
                enum: ['sonar-runtime'],
            },
        ],
    },
    create(context) {
        const services = context.parserServices;
        if (!parserServices.isRequiredParserServices(services)) {
            return {};
        }
        return {
            BinaryExpression: (node) => {
                const { operator, left, right } = node;
                if (['<', '<=', '>', '>='].includes(operator) &&
                    isString$1(left, services) &&
                    isString$1(right, services) &&
                    !isLiteralException(left) &&
                    !isLiteralException(right) &&
                    !isWithinSortCallback(context)) {
                    context.report({
                        message: toEncodedMessage$1(`Convert operands of this use of "${operator}" to number type.`, [left, right]),
                        loc: context
                            .getSourceCode()
                            .getTokensBetween(left, right)
                            .find(token => token.type === 'Punctuator' && token.value === operator).loc,
                    });
                }
            },
        };
    },
};
function isLiteralException(node) {
    return node.type === 'Literal' && node.raw.length === 3;
}
function isWithinSortCallback(context) {
    const ancestors = context.getAncestors().reverse();
    const maybeCallback = ancestors.find(node => ['ArrowFunctionExpression', 'FunctionExpression'].includes(node.type));
    if (maybeCallback) {
        const callback = maybeCallback;
        const parent = callback.parent;
        if ((parent === null || parent === void 0 ? void 0 : parent.type) === 'CallExpression') {
            const { callee, arguments: args } = parent;
            let funcName;
            if (callee.type === 'Identifier') {
                funcName = callee.name;
            }
            else if (callee.type === 'MemberExpression' && callee.property.type === 'Identifier') {
                funcName = callee.property.name;
            }
            return funcName && funcName.match(/sort/i) && args.some(arg => arg === callback);
        }
    }
    return false;
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rules$1 = new eslint.Linter().getRules();
const constructorSuperRule = rules$1.get('constructor-super');
const noThisBeforeSuperRule = rules$1.get('no-this-before-super');
const rule$k = {
    // meta of constructor-super and no-this-before-super is required for issue messages
    meta: {
        messages: Object.assign(Object.assign({}, constructorSuperRule.meta.messages), noThisBeforeSuperRule.meta.messages),
    },
    create(context) {
        const constructorSuperListener = constructorSuperRule.create(context);
        const notThisBeforeSuperListener = noThisBeforeSuperRule.create(context);
        return mergeRules(constructorSuperListener, notThisBeforeSuperListener);
    },
};
function mergeRules(rule1, rule2) {
    const merged = Object.assign(Object.assign({}, rule1), rule2);
    for (const listener in merged) {
        if (rule1.hasOwnProperty(listener) && rule2.hasOwnProperty(listener)) {
            merged[listener] = mergeListeners(rule1[listener], rule2[listener]);
        }
    }
    return merged;
}
function mergeListeners(listener1, listener2) {
    return (...args) => {
        if (listener1) {
            listener1(...args);
        }
        if (listener2) {
            listener2(...args);
        }
    };
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
// https://jira.sonarsource.com/browse/RSPEC-131
const rule$j = {
    meta: {
        messages: {
            switchDefault: `Add a "default" clause to this "switch" statement.`,
        },
    },
    create(context) {
        return {
            SwitchStatement(node) {
                const { cases } = node;
                const defaultClause = cases.find(c => c.test === null);
                if (!defaultClause) {
                    const switchKeyword = context
                        .getSourceCode()
                        .getFirstToken(node, token => token.type === 'Keyword' && token.value === 'switch');
                    context.report({
                        messageId: 'switchDefault',
                        loc: switchKeyword.loc,
                    });
                }
            },
        };
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$i = {
    create(context) {
        let catchWithDone = false;
        function isInsideTest() {
            return context
                .getAncestors()
                .some(n => n.type === 'CallExpression' && Mocha.isTestConstruct(n));
        }
        return {
            'CatchClause CallExpression[callee.name="done"]': (_node) => {
                catchWithDone = true;
            },
            'CatchClause:exit': (node) => {
                if (!catchWithDone || !isInsideTest()) {
                    return;
                }
                catchWithDone = false;
                const { param } = node;
                if (param && param.type === 'Identifier') {
                    const exception = getVariableFromIdentifier(param, context.getScope());
                    if (exception && exception.references.length === 0) {
                        context.report({
                            node: param,
                            message: 'Either the exception should be passed to "done(e)", or the exception should be tested further.',
                        });
                    }
                }
            },
            CallExpression(node) {
                const callExpr = node;
                if (isInsideTest() &&
                    isThrowAssertWithoutNot(callExpr) &&
                    (callExpr.arguments.length === 0 ||
                        (callExpr.arguments.length === 1 && isIdentifier(callExpr.arguments[0], 'Error')))) {
                    context.report({
                        node: callExpr.callee.property,
                        message: 'Assert more concrete exception type or assert the message of exception.',
                    });
                }
            },
        };
    },
};
// find nodes in shape expect(...).a.b.c.throw() or a.should.throw()
function isThrowAssertWithoutNot(node) {
    if (node.callee.type !== 'MemberExpression') {
        return false;
    }
    let { object, property } = node.callee;
    if (!isIdentifier(property, 'throw')) {
        return false;
    }
    while (object.type === 'MemberExpression') {
        if (isIdentifier(object.property, 'not')) {
            return false;
        }
        if (isIdentifier(object.property, 'should')) {
            return true;
        }
        object = object.object;
    }
    return object.type === 'CallExpression' && isIdentifier(object.callee, 'expect');
}

const rule$h = {
    meta: {
        schema: [
            {
                // internal parameter for rules having secondary locations
                enum: ['sonar-runtime'],
            },
        ],
    },
    create(context) {
        let jumpTargets = [];
        function enterScope() {
            jumpTargets.push(new JumpTarget());
        }
        function leaveScope() {
            jumpTargets.pop();
        }
        function increateNumberOfJumpsInScopes(jump, label) {
            for (const jumpTarget of [...jumpTargets].reverse()) {
                jumpTarget.jumps.push(jump);
                if (label === jumpTarget.label) {
                    break;
                }
            }
        }
        function leaveScopeAndCheckNumberOfJumps(node) {
            var _a;
            const jumps = (_a = jumpTargets.pop()) === null || _a === void 0 ? void 0 : _a.jumps;
            if (jumps && jumps.length > 1) {
                const sourceCode = context.getSourceCode();
                const firstToken = sourceCode.getFirstToken(node);
                context.report({
                    loc: firstToken.loc,
                    message: toEncodedMessage$1('Reduce the total number of "break" and "continue" statements in this loop to use one at most.', jumps, jumps.map(jmp => jmp.type === 'BreakStatement' ? '"break" statement.' : '"continue" statement.')),
                });
            }
        }
        return {
            Program: () => {
                jumpTargets = [];
            },
            BreakStatement: (node) => {
                var _a;
                const breakStatement = node;
                increateNumberOfJumpsInScopes(breakStatement, (_a = breakStatement.label) === null || _a === void 0 ? void 0 : _a.name);
            },
            ContinueStatement: (node) => {
                var _a;
                const continueStatement = node;
                increateNumberOfJumpsInScopes(continueStatement, (_a = continueStatement.label) === null || _a === void 0 ? void 0 : _a.name);
            },
            SwitchStatement: enterScope,
            'SwitchStatement:exit': leaveScope,
            ForStatement: enterScope,
            'ForStatement:exit': leaveScopeAndCheckNumberOfJumps,
            ForInStatement: enterScope,
            'ForInStatement:exit': leaveScopeAndCheckNumberOfJumps,
            ForOfStatement: enterScope,
            'ForOfStatement:exit': leaveScopeAndCheckNumberOfJumps,
            WhileStatement: enterScope,
            'WhileStatement:exit': leaveScopeAndCheckNumberOfJumps,
            DoWhileStatement: enterScope,
            'DoWhileStatement:exit': leaveScopeAndCheckNumberOfJumps,
            LabeledStatement: (node) => {
                const labeledStatement = node;
                jumpTargets.push(new JumpTarget(labeledStatement.label.name));
            },
            'LabeledStatement:exit': leaveScope,
        };
    },
};
class JumpTarget {
    constructor(label) {
        this.jumps = [];
        this.label = label;
    }
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$g = createRegExpRule(context => {
    const unicodeProperties = [];
    const unicodeCharacters = [];
    let rawPattern;
    let isUnicodeEnabled = false;
    return {
        onRegExpLiteralEnter: (node) => {
            rawPattern = node.raw;
            isUnicodeEnabled = node.flags.unicode;
        },
        onQuantifierEnter: (quantifier) => {
            if (isUnicodeEnabled) {
                return;
            }
            /* \u{hhhh}, \u{hhhhh} */
            const { raw, min: hex } = quantifier;
            if (raw.startsWith('\\u') &&
                !raw.includes(',') &&
                ['hhhh'.length, 'hhhhh'.length].includes(hex.toString().length)) {
                unicodeCharacters.push(quantifier);
            }
        },
        onCharacterEnter: (character) => {
            if (isUnicodeEnabled) {
                return;
            }
            const c = character.raw;
            if (c !== '\\p' && c !== '\\P') {
                return;
            }
            let state = 'start';
            let offset = character.start + c.length;
            let nextChar;
            do {
                nextChar = rawPattern[offset];
                offset++;
                switch (state) {
                    case 'start':
                        if (nextChar === '{') {
                            state = 'openingBracket';
                        }
                        else {
                            state = 'end';
                        }
                        break;
                    case 'openingBracket':
                        if (/[a-zA-Z]/.test(nextChar)) {
                            state = 'alpha';
                        }
                        else {
                            state = 'end';
                        }
                        break;
                    case 'alpha':
                        if (/[a-zA-Z]/.test(nextChar)) {
                            state = 'alpha';
                        }
                        else if (nextChar === '=') {
                            state = 'equal';
                        }
                        else if (nextChar === '}') {
                            state = 'closingBracket';
                        }
                        else {
                            state = 'end';
                        }
                        break;
                    case 'equal':
                        if (/[a-zA-Z]/.test(nextChar)) {
                            state = 'alpha1';
                        }
                        else {
                            state = 'end';
                        }
                        break;
                    case 'alpha1':
                        if (/[a-zA-Z]/.test(nextChar)) {
                            state = 'alpha1';
                        }
                        else if (nextChar === '}') {
                            state = 'closingBracket';
                        }
                        else {
                            state = 'end';
                        }
                        break;
                    case 'closingBracket':
                        state = 'end';
                        unicodeProperties.push({ character, offset: offset - c.length - 1 });
                        break;
                }
            } while (state !== 'end');
        },
        onRegExpLiteralLeave: (regexp) => {
            if (!isUnicodeEnabled && (unicodeProperties.length > 0 || unicodeCharacters.length > 0)) {
                const secondaryLocations = [];
                const secondaryMessages = [];
                unicodeProperties.forEach(p => {
                    secondaryLocations.push({
                        loc: getRegexpLocation(context.node, p.character, context, [0, p.offset]),
                    });
                    secondaryMessages.push('Unicode property');
                });
                unicodeCharacters.forEach(c => {
                    secondaryLocations.push({ loc: getRegexpLocation(context.node, c, context) });
                    secondaryMessages.push('Unicode character');
                });
                context.reportRegExpNode({
                    message: toEncodedMessage$1(`Enable the 'u' flag for this regex using Unicode constructs.`, secondaryLocations, secondaryMessages),
                    node: context.node,
                    regexpNode: regexp,
                });
            }
        },
    };
}, {
    meta: {
        schema: [
            {
                // internal parameter for rules having secondary locations
                enum: ['sonar-runtime'],
            },
        ],
    },
});

function removeNodeWithLeadingWhitespaces(context, node, fixer, removeUntil) {
    const previousComments = context.getSourceCode().getCommentsBefore(node);
    let start = 0;
    if (previousComments.length === 0) {
        const previousToken = context.getSourceCode().getTokenBefore(node);
        if (previousToken) {
            start = previousToken.range[1];
        }
    }
    else {
        start = previousComments[previousComments.length - 1].range[1];
    }
    const end = removeUntil ? removeUntil : node.range[1];
    return fixer.removeRange([start, end]);
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const EXCLUDED_IMPORTS = ['React'];
const rule$f = {
    meta: {
        messages: {
            removeUnusedImport: `Remove this unused import of '{{symbol}}'.`,
            suggestRemoveWholeStatement: `Remove this import statement`,
            suggestRemoveOneVariable: `Remove this variable import`,
        },
        hasSuggestions: true,
    },
    create(context) {
        const isJsxPragmaSet = context
            .getSourceCode()
            .getAllComments()
            .findIndex(comment => comment.value.includes('@jsx jsx')) > -1;
        const unusedImports = [];
        const vueIdentifiers = new Set();
        const tsTypeIdentifiers = new Set();
        const saveTypeIdentifier = (node) => tsTypeIdentifiers.add(node.name);
        function isExcluded(variable) {
            return EXCLUDED_IMPORTS.includes(variable.name);
        }
        function isUnused(variable) {
            return variable.references.length === 0;
        }
        function isImplicitJsx(variable) {
            return variable.name === 'jsx' && isJsxPragmaSet;
        }
        function getJsxFactories() {
            const factories = new Set();
            const parserServices$1 = context.parserServices;
            if (parserServices.isRequiredParserServices(parserServices$1)) {
                const compilerOptions = parserServices$1.program.getCompilerOptions();
                if (compilerOptions.jsxFactory) {
                    factories.add(compilerOptions.jsxFactory);
                }
                if (compilerOptions.jsxFragmentFactory) {
                    factories.add(compilerOptions.jsxFragmentFactory);
                }
            }
            return factories;
        }
        const ruleListener = {
            ImportDeclaration: (node) => {
                const variables = context.getDeclaredVariables(node);
                for (const variable of variables) {
                    if (!isExcluded(variable) && !isImplicitJsx(variable) && isUnused(variable)) {
                        unusedImports.push({
                            id: variable.identifiers[0],
                            importDecl: node,
                        });
                    }
                }
            },
            'TSTypeReference > Identifier, TSClassImplements > Identifier, TSInterfaceHeritage > Identifier': (node) => {
                saveTypeIdentifier(node);
            },
            "TSQualifiedName[left.type = 'Identifier']": (node) => {
                saveTypeIdentifier(node.left);
            },
            "TSInterfaceHeritage > MemberExpression[object.type = 'Identifier'], TSClassImplements > MemberExpression[object.type = 'Identifier']": (node) => {
                saveTypeIdentifier(node.object);
            },
            'Program:exit': () => {
                const jsxFactories = getJsxFactories();
                const jsxIdentifiers = context
                    .getSourceCode()
                    .ast.tokens.filter(token => token.type === 'JSXIdentifier')
                    .map(token => token.value);
                unusedImports
                    .filter(({ id: unused }) => !jsxIdentifiers.includes(unused.name) &&
                    !tsTypeIdentifiers.has(unused.name) &&
                    !vueIdentifiers.has(unused.name) &&
                    !jsxFactories.has(unused.name))
                    .forEach(unused => context.report({
                    messageId: 'removeUnusedImport',
                    data: {
                        symbol: unused.id.name,
                    },
                    node: unused.id,
                    suggest: [getSuggestion(context, unused)],
                }));
            },
        };
        // @ts-ignore
        if (context.parserServices.defineTemplateBodyVisitor) {
            return context.parserServices.defineTemplateBodyVisitor({
                VElement: (node) => {
                    const { rawName } = node;
                    if (startsWithUpper(rawName)) {
                        vueIdentifiers.add(rawName);
                    }
                    else if (isKebabCase(rawName)) {
                        vueIdentifiers.add(toPascalCase(rawName));
                    }
                },
                Identifier: (node) => {
                    vueIdentifiers.add(node.name);
                },
            }, ruleListener, { templateBodyTriggerSelector: 'Program' });
        }
        return ruleListener;
    },
};
function startsWithUpper(str) {
    return str.charAt(0) === str.charAt(0).toUpperCase();
}
function isKebabCase(str) {
    return str.includes('-');
}
function toPascalCase(str) {
    return str
        .replace(/\w+/g, word => word[0].toUpperCase() + word.slice(1).toLowerCase())
        .replace('-', '');
}
function getSuggestion(context, { id, importDecl }) {
    const variables = context.getDeclaredVariables(importDecl);
    if (variables.length === 1) {
        return {
            messageId: 'suggestRemoveWholeStatement',
            fix: fixer => {
                return removeNodeWithLeadingWhitespaces(context, importDecl, fixer);
            },
        };
    }
    const specifiers = importDecl.specifiers;
    const unusedSpecifier = specifiers.find(specifier => specifier.local === id);
    const code = context.getSourceCode();
    let range;
    switch (unusedSpecifier.type) {
        case 'ImportDefaultSpecifier':
            const tokenAfter = code.getTokenAfter(id);
            // default import is always first
            range = [id.range[0], code.getTokenAfter(tokenAfter).range[0]];
            break;
        case 'ImportNamespaceSpecifier':
            // namespace import is always second
            range = [code.getTokenBefore(unusedSpecifier).range[0], unusedSpecifier.range[1]];
            break;
        case 'ImportSpecifier':
            const simpleSpecifiers = specifiers.filter(specifier => specifier.type === 'ImportSpecifier');
            const index = simpleSpecifiers.findIndex(specifier => specifier === unusedSpecifier);
            if (simpleSpecifiers.length === 1) {
                range = [specifiers[0].range[1], code.getTokenAfter(unusedSpecifier).range[1]];
            }
            else if (index === 0) {
                range = [simpleSpecifiers[0].range[0], simpleSpecifiers[1].range[0]];
            }
            else {
                range = [simpleSpecifiers[index - 1].range[1], simpleSpecifiers[index].range[1]];
            }
    }
    return {
        messageId: 'suggestRemoveOneVariable',
        fix: fixer => {
            return fixer.removeRange(range);
        },
    };
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$e = {
    meta: {
        schema: [
            {
                // internal parameter for rules having secondary locations
                enum: ['sonar-runtime'],
            },
        ],
    },
    create(context) {
        const services = context.parserServices;
        if (!parserServices.isRequiredParserServices(services)) {
            return {};
        }
        const intellisense = new RegexIntelliSense(services, context);
        return {
            'Literal[regex]:exit': (literal) => {
                /* /regex/ */
                intellisense.collectKnowledge(literal);
            },
            'NewExpression:exit': (newExpr) => {
                /* new RegExp(regex) */
                intellisense.collectKnowledge(newExpr);
            },
            'CallExpression:exit': (callExpr) => {
                /* RegExp(regex), implicit regex e.g. str.match('regex') */
                intellisense.collectKnowledge(callExpr);
                /* str.match(pattern) / pattern.exec(str) */
                intellisense.collectPatternMatcher(callExpr);
                /* str.replace(pattern, substr) */
                checkStringReplaceGroupReferences(callExpr, intellisense);
            },
            'MemberExpression:exit': (memberExpr) => {
                if (memberExpr.computed) {
                    /* matcher[index] */
                    checkIndexBasedGroupReference(memberExpr, intellisense);
                }
                else {
                    /* matcher.groups.<name> / matcher.indices.groups.<name> */
                    checkNonExistingGroupReference(memberExpr, intellisense);
                }
            },
            'Program:exit': () => {
                checkUnusedGroups(intellisense);
                checkIndexedGroups(intellisense);
            },
        };
    },
};
function checkStringReplaceGroupReferences(callExpr, intellisense) {
    if (isStringReplaceCall(callExpr, intellisense.services)) {
        const [pattern, substr] = callExpr.arguments;
        const regex = intellisense.findRegex(pattern);
        if (regex) {
            const references = extractReferences(substr);
            const indexes = new Set();
            const names = new Set();
            references.forEach(ref => isNaN(Number(ref.value)) ? names.add(ref.value) : indexes.add(Number(ref.value)));
            regex.groups.forEach(group => {
                group.used || (group.used = names.has(group.name));
                group.used || (group.used = indexes.has(group.index));
            });
            const indexedGroups = regex.groups.filter(group => indexes.has(group.index));
            if (indexedGroups.length > 0) {
                intellisense.context.report({
                    message: toEncodedMessage$1(`Directly use the group names instead of their numbers.`, indexedGroups.map(group => ({
                        loc: getRegexpLocation(regex.node, group.node, intellisense.context),
                    })), indexedGroups.map(group => `Group '${group.name}'`)),
                    node: substr,
                });
            }
        }
    }
}
function checkIndexBasedGroupReference(memberExpr, intellisense) {
    const { object: matcher, property } = memberExpr;
    const regex = intellisense.resolve(matcher);
    if (regex) {
        const maybeIndex = getValueOfExpression(intellisense.context, property, 'Literal');
        if (maybeIndex && typeof maybeIndex.value === 'number') {
            const index = maybeIndex.value;
            const group = regex.groups.find(grp => grp.index === index);
            if (group) {
                group.used = true;
                intellisense.context.report({
                    message: toEncodedMessage$1(`Directly use '${group.name}' instead of its group number.`, [{ loc: getRegexpLocation(regex.node, group.node, intellisense.context) }], [`Group '${group.name}'`]),
                    node: property,
                });
            }
        }
    }
}
function checkNonExistingGroupReference(memberExpr, intellisense) {
    const { object: matcher } = memberExpr;
    const regex = intellisense.resolve(matcher);
    if (regex) {
        /* matcher.groups.<name> / matcher.indices.groups.<name>  */
        const groupNodes = extractGroupNodes(memberExpr, intellisense);
        for (const groupNode of groupNodes) {
            const group = regex.groups.find(grp => grp.name === groupNode.name);
            if (group) {
                group.used = true;
            }
            else {
                intellisense.context.report({
                    message: toEncodedMessage$1(`There is no group named '${groupNode.name}' in the regular expression.`, regex.groups.map(grp => ({
                        loc: getRegexpLocation(regex.node, grp.node, intellisense.context),
                    })), regex.groups.map(grp => `Named group '${grp.name}'`)),
                    node: groupNode,
                });
            }
        }
    }
}
function extractGroupNodes(memberExpr, intellisense) {
    if (isDotNotation(memberExpr)) {
        const { property } = memberExpr;
        const ancestors = intellisense.context.getAncestors();
        let parent = ancestors.pop();
        if (parent) {
            switch (property.name) {
                case 'groups':
                    /* matcher.groups.<name> */
                    return extractNamedOrDestructuredGroupNodes(parent);
                case 'indices':
                    /* matcher.indices.groups.<name> */
                    if (isDotNotation(parent) && parent.property.name === 'groups') {
                        parent = ancestors.pop();
                        if (parent) {
                            return extractNamedOrDestructuredGroupNodes(parent);
                        }
                    }
            }
        }
    }
    return [];
}
function extractNamedOrDestructuredGroupNodes(node) {
    if (isDotNotation(node)) {
        /* matcher.groups.<name> */
        return [node.property];
    }
    else if (isObjectDestructuring(node)) {
        /* { <name1>,..<nameN> } = matcher.groups */
        const destructuredGroups = [];
        const pattern = node.type === 'VariableDeclarator' ? node.id : node.left;
        for (const property of pattern.properties) {
            if (property.type === 'Property' && property.key.type === 'Identifier') {
                destructuredGroups.push(property.key);
            }
        }
        return destructuredGroups;
    }
    else {
        return [];
    }
}
function checkUnusedGroups(intellisense) {
    intellisense.getKnowledge().forEach(regex => {
        if (regex.matched) {
            const unusedGroups = regex.groups.filter(group => !group.used);
            if (unusedGroups.length) {
                intellisense.context.report({
                    message: toEncodedMessage$1('Use the named groups of this regex or remove the names.', unusedGroups.map(grp => ({
                        loc: getRegexpLocation(regex.node, grp.node, intellisense.context),
                    })), unusedGroups.map(grp => `Named group '${grp.name}'`)),
                    node: regex.node,
                });
            }
        }
    });
}
function checkIndexedGroups(intellisense) {
    intellisense.getKnowledge().forEach(regex => {
        regex.groups.forEach(group => group.node.references.forEach(reference => {
            if (typeof reference.ref === 'number') {
                intellisense.context.report({
                    message: toEncodedMessage$1(`Directly use '${group.name}' instead of its group number.`, [{ loc: getRegexpLocation(regex.node, group.node, intellisense.context) }], [`Group '${group.name}'`]),
                    loc: getRegexpLocation(regex.node, reference, intellisense.context),
                });
            }
        }));
    });
}
function makeRegexKnowledge(node, regexp) {
    const capturingGroups = [];
    const backreferences = [];
    regexpp__namespace.visitRegExpAST(regexp, {
        onBackreferenceEnter: reference => reference.resolved.name && backreferences.push(reference),
        onCapturingGroupEnter: group => capturingGroups.push(group),
    });
    const groups = [];
    capturingGroups.forEach((group, index) => group.name && groups.push(makeGroupKnowledge(group, backreferences, index + 1)));
    return { node, regexp, groups, matched: false };
}
function makeGroupKnowledge(node, backreferences, index) {
    const name = node.name;
    const used = backreferences.some(backreference => backreference.resolved === node);
    return { node, name, used, index };
}
class RegexIntelliSense {
    constructor(services, context) {
        this.services = services;
        this.context = context;
        this.knowledge = [];
        this.bindings = new Map();
    }
    getKnowledge() {
        return this.knowledge;
    }
    collectKnowledge(node) {
        let regexNode = node;
        if (node.type === 'CallExpression' && isStringRegexMethodCall(node, this.services)) {
            /* implicit regex */
            regexNode = node.arguments[0];
        }
        const regex = getParsedRegex(regexNode, this.context);
        if (regex !== null) {
            this.knowledge.push(makeRegexKnowledge(regexNode, regex));
        }
    }
    collectPatternMatcher(callExpr) {
        const { callee, arguments: args } = callExpr;
        if (isMethodCall(callExpr) && args.length > 0) {
            const target = callee.object;
            const matcher = getLhsVariable(this.context);
            if (matcher) {
                const method = callee.property;
                if (isString$1(target, this.services) && ['match', 'matchAll'].includes(method.name)) {
                    /* str.match(pattern) */
                    const [pattern] = args;
                    this.bind(pattern, matcher);
                }
                else if (method.name === 'exec' && isString$1(args[0], this.services)) {
                    /* pattern.exec(str) */
                    const pattern = target;
                    this.bind(pattern, matcher);
                }
            }
        }
    }
    resolve(matcher) {
        const variable = this.findVariable(matcher);
        if (variable) {
            return this.bindings.get(variable) || null;
        }
        else {
            return null;
        }
    }
    findRegex(node) {
        return this.findRegexRec(node, new Set());
    }
    findRegexRec(node, visited) {
        if (!visited.has(node)) {
            visited.add(node);
            const variable = this.findVariable(node);
            if (variable) {
                const value = getUniqueWriteUsage(this.context, variable.name);
                if (value) {
                    const regex = this.findRegexRec(value, visited);
                    if (regex) {
                        return regex;
                    }
                }
            }
        }
        return this.knowledge.find(regex => regex.node === node);
    }
    bind(pattern, matcher) {
        const regex = this.findRegex(pattern);
        if (regex) {
            regex.matched = true;
            this.bindings.set(matcher, regex);
        }
    }
    findVariable(node) {
        if (node.type === 'Identifier') {
            return getVariableFromName(this.context, node.name);
        }
        return null;
    }
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$d = {
    meta: {
        schema: [
            {
                // internal parameter for rules having secondary locations
                enum: ['sonar-runtime'],
            },
        ],
    },
    create(context) {
        const MESSAGE = 'Enable server certificate validation on this SSL/TLS connection.';
        const SECONDARY_MESSAGE = 'Set "rejectUnauthorized" to "true".';
        function checkSensitiveArgument(callExpression, sensitiveArgumentIndex) {
            if (callExpression.arguments.length < sensitiveArgumentIndex + 1) {
                return;
            }
            const sensitiveArgument = callExpression.arguments[sensitiveArgumentIndex];
            const secondaryLocations = [];
            const secondaryMessages = [];
            const argumentValue = getValueOfExpression(context, sensitiveArgument, 'ObjectExpression');
            if (!argumentValue) {
                return;
            }
            if (sensitiveArgument !== argumentValue) {
                secondaryLocations.push(argumentValue);
                secondaryMessages.push(undefined);
            }
            const unsafeRejectUnauthorizedConfiguration = getPropertyWithValue(context, argumentValue, 'rejectUnauthorized', false);
            if (unsafeRejectUnauthorizedConfiguration) {
                secondaryLocations.push(unsafeRejectUnauthorizedConfiguration);
                secondaryMessages.push(SECONDARY_MESSAGE);
                context.report({
                    node: callExpression.callee,
                    message: toEncodedMessage$1(MESSAGE, secondaryLocations, secondaryMessages),
                });
            }
        }
        return {
            CallExpression: (node) => {
                const callExpression = node;
                if (isCallToFQN(context, callExpression, 'https', 'request')) {
                    checkSensitiveArgument(callExpression, 0);
                }
                if (isCallToFQN(context, callExpression, 'request', 'get')) {
                    checkSensitiveArgument(callExpression, 0);
                }
                if (isCallToFQN(context, callExpression, 'tls', 'connect')) {
                    checkSensitiveArgument(callExpression, 2);
                }
            },
        };
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$c = {
    meta: {
        schema: [
            {
                // internal parameter for rules having secondary locations
                enum: ['sonar-runtime'],
            },
        ],
    },
    create(context) {
        const MESSAGE = 'Enable server hostname verification on this SSL/TLS connection.';
        const SECONDARY_MESSAGE = 'Set "rejectUnauthorized" to "true".';
        function checkSensitiveArgument(callExpression, sensitiveArgumentIndex) {
            if (callExpression.arguments.length < sensitiveArgumentIndex + 1) {
                return;
            }
            const sensitiveArgument = callExpression.arguments[sensitiveArgumentIndex];
            const secondaryLocations = [];
            const secondaryMessages = [];
            let shouldReport = false;
            const argumentValue = getValueOfExpression(context, sensitiveArgument, 'ObjectExpression');
            if (!argumentValue) {
                return;
            }
            if (sensitiveArgument !== argumentValue) {
                secondaryLocations.push(argumentValue);
                secondaryMessages.push(undefined);
            }
            const unsafeRejectUnauthorizedConfiguration = getPropertyWithValue(context, argumentValue, 'rejectUnauthorized', false);
            if (unsafeRejectUnauthorizedConfiguration) {
                secondaryLocations.push(unsafeRejectUnauthorizedConfiguration);
                secondaryMessages.push(SECONDARY_MESSAGE);
                shouldReport = true;
            }
            const checkServerIdentityProperty = getObjectExpressionProperty(argumentValue, 'checkServerIdentity');
            if (checkServerIdentityProperty &&
                shouldReportOnCheckServerIdentityCallBack(checkServerIdentityProperty)) {
                secondaryLocations.push(checkServerIdentityProperty);
                secondaryMessages.push(undefined);
                shouldReport = true;
            }
            if (shouldReport) {
                context.report({
                    node: callExpression.callee,
                    message: toEncodedMessage$1(MESSAGE, secondaryLocations, secondaryMessages),
                });
            }
        }
        function shouldReportOnCheckServerIdentityCallBack(checkServerIdentityProperty) {
            let baseFunction;
            baseFunction = getValueOfExpression(context, checkServerIdentityProperty.value, 'FunctionExpression');
            if (!baseFunction) {
                baseFunction = getValueOfExpression(context, checkServerIdentityProperty.value, 'ArrowFunctionExpression');
            }
            if ((baseFunction === null || baseFunction === void 0 ? void 0 : baseFunction.body.type) === 'BlockStatement') {
                const returnStatements = ReturnStatementsVisitor.getReturnStatements(baseFunction.body, context);
                if (returnStatements.length === 0 ||
                    returnStatements.every(r => {
                        var _a;
                        return (!r.argument || ((_a = getValueOfExpression(context, r.argument, 'Literal')) === null || _a === void 0 ? void 0 : _a.value) === true);
                    })) {
                    return true;
                }
            }
            return false;
        }
        return {
            CallExpression: (node) => {
                const callExpression = node;
                if (isCallToFQN(context, callExpression, 'https', 'request')) {
                    checkSensitiveArgument(callExpression, 0);
                }
                if (isCallToFQN(context, callExpression, 'request', 'get')) {
                    checkSensitiveArgument(callExpression, 0);
                }
                if (isCallToFQN(context, callExpression, 'tls', 'connect')) {
                    checkSensitiveArgument(callExpression, 2);
                }
            },
        };
    },
};
class ReturnStatementsVisitor {
    constructor() {
        this.returnStatements = [];
    }
    static getReturnStatements(node, context) {
        const visitor = new ReturnStatementsVisitor();
        visitor.visit(node, context);
        return visitor.returnStatements;
    }
    visit(root, context) {
        const visitNode = (node) => {
            switch (node.type) {
                case 'ReturnStatement':
                    this.returnStatements.push(node);
                    break;
                case 'FunctionDeclaration':
                case 'FunctionExpression':
                case 'ArrowFunctionExpression':
                    return;
            }
            childrenOf$1(node, context.getSourceCode().visitorKeys).forEach(visitNode);
        };
        visitNode(root);
    }
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$b = {
    meta: {
        schema: [
            {
                // internal parameter for rules having secondary locations
                enum: ['sonar-runtime'],
            },
        ],
    },
    create(context) {
        return {
            'VariableDeclaration[kind="const"]': (node) => {
                context.getDeclaredVariables(node).forEach(variable => variable.references.filter(isModifyingReference).forEach(reference => context.report({
                    message: toEncodedMessage$1(`Correct this attempt to modify "${reference.identifier.name}" or use "let" in its declaration.`, [node], ['Const declaration']),
                    node: reference.identifier,
                })));
            },
        };
    },
};
function isModifyingReference(reference, index, references) {
    const identifier = reference.identifier;
    const modifyingDifferentIdentifier = index === 0 || references[index - 1].identifier !== identifier;
    return (identifier && reference.init === false && reference.isWrite() && modifyingDifferentIdentifier);
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$a = {
    meta: {
        schema: [
            {
                // internal parameter for rules having secondary locations
                enum: ['sonar-runtime'],
            },
        ],
    },
    create(context) {
        function checkLoop(updateNode, extractCounters, loopBody) {
            const counters = [];
            extractCounters(updateNode, counters);
            counters.forEach(counter => checkCounter(counter, loopBody));
        }
        function checkCounter(counter, block) {
            const variable = getVariableFromName(context, counter.name);
            if (!variable) {
                return;
            }
            variable.references.forEach(ref => {
                if (ref.isWrite() && isUsedInsideBody(ref.identifier, block)) {
                    context.report({
                        node: ref.identifier,
                        message: toEncodedMessage$1(`Remove this assignment of "${counter.name}".`, [counter], ['Counter variable update']),
                    });
                }
            });
        }
        return {
            'ForStatement > BlockStatement': (node) => {
                const forLoop = getParent(context);
                if (forLoop.update) {
                    checkLoop(forLoop.update, collectCountersFor, node);
                }
            },
            'ForInStatement > BlockStatement, ForOfStatement > BlockStatement': (node) => {
                const { left } = getParent(context);
                checkLoop(left, collectCountersForX, node);
            },
        };
    },
};
function collectCountersForX(updateExpression, counters) {
    if (updateExpression.type === 'VariableDeclaration') {
        updateExpression.declarations.forEach(decl => collectCountersForX(decl.id, counters));
    }
    else {
        resolveIdentifiers(updateExpression, true).forEach(id => counters.push(id));
    }
}
function collectCountersFor(updateExpression, counters) {
    let counter = undefined;
    if (updateExpression.type === 'AssignmentExpression') {
        counter = updateExpression.left;
    }
    else if (updateExpression.type === 'UpdateExpression') {
        counter = updateExpression.argument;
    }
    else if (updateExpression.type === 'SequenceExpression') {
        updateExpression.expressions.forEach(e => collectCountersFor(e, counters));
    }
    if (counter && counter.type === 'Identifier') {
        counters.push(counter);
    }
}
function isUsedInsideBody(id, loopBody) {
    const bodyRange = loopBody.range;
    return id.range && bodyRange && id.range[0] > bodyRange[0] && id.range[1] < bodyRange[1];
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const TYPE_THRESHOLD = 2;
const USAGE_THRESHOLD = 2;
const rule$9 = {
    meta: {
        schema: [
            {
                // internal parameter for rules having secondary locations
                enum: ['sonar-runtime'],
            },
        ],
    },
    create(context) {
        let usage;
        return {
            Program: () => (usage = new Map()),
            'Program:exit': () => usage.forEach(nodes => {
                if (nodes.length > USAGE_THRESHOLD) {
                    const [node, ...rest] = nodes;
                    const kind = node.type === 'TSUnionType' ? 'union' : 'intersection';
                    const message = toEncodedMessage$1(`Replace this ${kind} type with a type alias.`, rest, Array(rest.length).fill('Following occurrence.'));
                    context.report({ message, loc: node.loc });
                }
            }),
            'TSUnionType, TSIntersectionType': (node) => {
                const ancestors = context.getAncestors();
                const declaration = ancestors.find(ancestor => ancestor.type === 'TSTypeAliasDeclaration');
                if (!declaration) {
                    const composite = node;
                    if (composite.types.length > TYPE_THRESHOLD) {
                        const text = composite.types
                            .map(typeNode => context.getSourceCode().getText(typeNode))
                            .sort((a, b) => a.localeCompare(b))
                            .join('|');
                        let occurrences = usage.get(text);
                        if (!occurrences) {
                            occurrences = [composite];
                            usage.set(text, occurrences);
                        }
                        else {
                            occurrences.push(composite);
                        }
                    }
                }
            },
        };
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$8 = {
    meta: {
        messages: {
            uselessStringOp: '{{symbol}} is an immutable object; you must either store or return the result of the operation.',
        },
    },
    create(context) {
        const services = context.parserServices;
        if (!parserServices.isRequiredParserServices(services)) {
            return {};
        }
        function isString(node) {
            const type = getTypeFromTreeNode$1(node, services);
            return (type.flags & ts__namespace.TypeFlags.StringLike) !== 0;
        }
        function getVariable(node) {
            let variable = context.getSourceCode().getText(node);
            if (variable.length > 30) {
                variable = 'String';
            }
            return variable;
        }
        return {
            'ExpressionStatement > CallExpression[callee.type="MemberExpression"]': (node) => {
                const { object, property } = node
                    .callee;
                if (isString(object) && property.type === 'Identifier') {
                    context.report({
                        messageId: 'uselessStringOp',
                        data: {
                            symbol: getVariable(object),
                        },
                        node: property,
                    });
                }
            },
        };
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const comparisonOperators = new Set(['>', '<', '>=', '<=']);
const rule$7 = {
    meta: {
        messages: {
            reEvaluateDataFlow: 'Re-evaluate the data flow; this operand of a numeric comparison could be of type {{type}}.',
        },
    },
    create(context) {
        const services = context.parserServices;
        if (!parserServices.isRequiredParserServices(services)) {
            return {};
        }
        return {
            BinaryExpression(node) {
                const { left, operator, right } = node;
                if (!comparisonOperators.has(operator)) {
                    return;
                }
                if (left.type === 'MemberExpression' || right.type === 'MemberExpression') {
                    // avoid FPs on field access
                    return;
                }
                const checker = services.program.getTypeChecker();
                const leftType = getTypeFromTreeNode$1(left, services);
                const rightType = getTypeFromTreeNode$1(right, services);
                if (isStringType$1(leftType) || isStringType$1(rightType)) {
                    return;
                }
                const isLeftConvertibleToNumber = isConvertibleToNumber(leftType, checker);
                const isRightConvertibleToNumber = isConvertibleToNumber(rightType, checker);
                if (!isLeftConvertibleToNumber) {
                    context.report({
                        messageId: 'reEvaluateDataFlow',
                        data: {
                            type: checker.typeToString(leftType),
                        },
                        node: left,
                    });
                }
                if (!isRightConvertibleToNumber) {
                    context.report({
                        messageId: 'reEvaluateDataFlow',
                        data: {
                            type: checker.typeToString(rightType),
                        },
                        node: right,
                    });
                }
            },
        };
    },
};
function isConvertibleToNumber(typ, checker) {
    const flags = typ.getFlags();
    if ((flags & ts__namespace.TypeFlags.BooleanLike) !== 0) {
        return true;
    }
    if ((flags & ts__namespace.TypeFlags.Undefined) !== 0) {
        return false;
    }
    const valueOfSignatures = getValueOfSignatures(typ, checker);
    return (valueOfSignatures.length === 0 ||
        valueOfSignatures.some(signature => isNumberLike(signature.getReturnType())));
}
function getValueOfSignatures(typ, checker) {
    const valueOfSymbol = typ.getProperty('valueOf');
    if (!valueOfSymbol) {
        return [];
    }
    const declarations = valueOfSymbol.getDeclarations() || [];
    return declarations
        .map(declaration => checker.getTypeAtLocation(declaration).getCallSignatures())
        .reduce((result, decl) => result.concat(decl), []);
}
function isNumberLike(typ) {
    return (typ.getFlags() & ts__namespace.TypeFlags.NumberLike) !== 0;
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$6 = {
    meta: {
        messages: {
            renameSymbol: `Rename this {{symbolType}} "{{symbol}}" to match the regular expression {{format}}.`,
        },
    },
    create(context) {
        return {
            VariableDeclaration: (node) => checkVariable(node, context),
            'FunctionDeclaration, FunctionExpression, ArrowFunctionExpression, TSDeclareFunction, TSMethodSignature, TSConstructSignatureDeclaration, TSEmptyBodyFunctionExpression': (node) => checkFunction(node, context),
            PropertyDefinition: (node) => checkProperty(node, context),
            CatchClause: (node) => checkCatch(node, context),
        };
    },
};
function checkVariable(decl, context) {
    if (decl.declare) {
        return;
    }
    decl.declarations.forEach(declaration => resolveIdentifiers(declaration.id).forEach(id => raiseOnInvalidIdentifier(id, 'local variable', context)));
}
function checkFunction(func, context) {
    if (func.declare) {
        return;
    }
    func.params.forEach(param => resolveIdentifiers(param).forEach(id => raiseOnInvalidIdentifier(id, 'parameter', context)));
}
function checkProperty(prop, context) {
    if (prop.key.type === 'Identifier') {
        raiseOnInvalidIdentifier(prop.key, 'property', context);
    }
}
function checkCatch(catchh, context) {
    if (catchh.param) {
        resolveIdentifiers(catchh.param).forEach(id => raiseOnInvalidIdentifier(id, 'parameter', context));
    }
}
function raiseOnInvalidIdentifier(id, idType, context) {
    const [{ format }] = context.options;
    const { name } = id;
    if (!name.match(format)) {
        context.report({
            messageId: 'renameSymbol',
            data: {
                symbol: name,
                symbolType: idType,
                format,
            },
            node: id,
        });
    }
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const rule$5 = {
    meta: {
        messages: {
            removeVoid: 'Remove this use of the "void" operator.',
        },
    },
    create(context) {
        const services = context.parserServices;
        function checkNode(node) {
            const unaryExpression = node;
            if (isVoid0(unaryExpression) || isIIFE(unaryExpression) || isPromiseLike(unaryExpression)) {
                return;
            }
            const operatorToken = context.getSourceCode().getTokenBefore(unaryExpression.argument);
            context.report({
                loc: operatorToken.loc,
                messageId: 'removeVoid',
            });
        }
        function isVoid0(expr) {
            return expr.argument.type === 'Literal' && 0 === expr.argument.value;
        }
        function isIIFE(expr) {
            return (expr.argument.type === 'CallExpression' &&
                ['ArrowFunctionExpression', 'FunctionExpression'].includes(expr.argument.callee.type));
        }
        function isPromiseLike(expr) {
            return parserServices.isRequiredParserServices(services) && isThenable(expr.argument, services);
        }
        return {
            'UnaryExpression[operator="void"]': checkNode,
        };
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const SECURE_PROTOCOL_ALLOWED_VALUES = [
    'TLSv1_2_method',
    'TLSv1_2_client_method',
    'TLSv1_2_server_method',
    'TLS_method',
    'TLS_client_method',
    'TLS_server_method',
];
const rule$4 = {
    meta: {
        messages: {
            useMinimumTLS: "Change '{{option}}' to use at least TLS v1.2.",
            useSecureTLS: "Change '{{option}}' to allow only secure TLS versions.",
        },
    },
    create(context) {
        function getValueOfProperty(objectExpression, propertyName) {
            const unsafeProperty = getObjectExpressionProperty(objectExpression, propertyName);
            if (unsafeProperty) {
                return getValueOfExpression(context, unsafeProperty.value, 'Literal');
            }
            return undefined;
        }
        function checkMinMaxVersion(propertyName, property) {
            if (property && (property.value === 'TLSv1.1' || property.value === 'TLSv1')) {
                context.report({
                    node: property,
                    messageId: 'useMinimumTLS',
                    data: {
                        option: propertyName,
                    },
                });
            }
        }
        function checkSslOptions(optionsNode) {
            var _a, _b;
            const options = getValueOfExpression(context, optionsNode, 'ObjectExpression');
            const minVersion = getValueOfProperty(options, 'minVersion');
            const maxVersion = getValueOfProperty(options, 'maxVersion');
            checkMinMaxVersion('minVersion', minVersion);
            checkMinMaxVersion('maxVersion', maxVersion);
            const secureProtocol = getValueOfProperty(options, 'secureProtocol');
            const secureProtocolValue = (_b = (_a = secureProtocol === null || secureProtocol === void 0 ? void 0 : secureProtocol.value) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : '';
            if (secureProtocol && !SECURE_PROTOCOL_ALLOWED_VALUES.includes(secureProtocolValue)) {
                context.report({
                    node: secureProtocol,
                    messageId: 'useMinimumTLS',
                    data: {
                        option: 'secureProtocol',
                    },
                });
            }
            const secureOptions = getObjectExpressionProperty(options, 'secureOptions');
            if (secureOptions && !isValidSecureOptions(secureOptions.value)) {
                context.report({
                    node: secureOptions,
                    messageId: 'useSecureTLS',
                    data: {
                        option: 'secureOptions',
                    },
                });
            }
        }
        function isValidSecureOptions(options) {
            const flags = [];
            collectIdentifiersFromBinary(options, flags);
            return (flags[0] === null ||
                (flags.includes('SSL_OP_NO_TLSv1') && flags.includes('SSL_OP_NO_TLSv1_1')));
        }
        function collectIdentifiersFromBinary(node, acc) {
            var _a;
            if (node.type === 'BinaryExpression') {
                collectIdentifiersFromBinary(node.left, acc);
                collectIdentifiersFromBinary(node.right, acc);
            }
            else if (node.type === 'MemberExpression' &&
                ((_a = getModuleNameOfNode(context, node.object)) === null || _a === void 0 ? void 0 : _a.value) === 'constants' &&
                node.property.type === 'Identifier') {
                acc.push(node.property.name);
            }
            else {
                // if part of expression is some complex node like function call, we set null on index 0
                acc[0] = null;
            }
        }
        return {
            CallExpression: (node) => {
                const callExpression = node;
                // https://nodejs.org/api/https.html#https_https_get_options_callback
                if (isCallToFQN(context, callExpression, 'https', 'request')) {
                    checkSslOptions(callExpression.arguments[0]);
                    checkSslOptions(callExpression.arguments[1]);
                }
                // https://github.com/request/request#tlsssl-protocol
                if (isCallToFQN(context, callExpression, 'request', 'get')) {
                    checkSslOptions(callExpression.arguments[0]);
                }
                // https://nodejs.org/api/tls.html#tls_tls_connect_options_callback
                if (isCallToFQN(context, callExpression, 'tls', 'connect')) {
                    checkSslOptions(callExpression.arguments[0]);
                    checkSslOptions(callExpression.arguments[1]);
                    checkSslOptions(callExpression.arguments[2]);
                }
                // https://nodejs.org/api/tls.html#tls_tls_createsecurecontext_options
                if (isCallToFQN(context, callExpression, 'tls', 'createSecureContext')) {
                    checkSslOptions(callExpression.arguments[0]);
                }
            },
        };
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const OPEN_DATABASE = 'openDatabase';
const rule$3 = {
    meta: {
        messages: {
            convertWebSQLUse: 'Convert this use of a Web SQL database to another technology.',
        },
    },
    create(context) {
        const services = context.parserServices;
        if (!parserServices.isRequiredParserServices(services)) {
            return {};
        }
        return {
            CallExpression: (node) => {
                const callExpression = node;
                const { callee } = callExpression;
                const symbol = getSymbolAtLocation(callee, services);
                if (!!symbol) {
                    return;
                }
                if (isIdentifier(callee, OPEN_DATABASE)) {
                    context.report({ node: callee, messageId: 'convertWebSQLUse' });
                }
                if (callee.type !== 'MemberExpression' || !isIdentifier(callee.property, OPEN_DATABASE)) {
                    return;
                }
                const typeName = getTypeAsString(callee.object, services);
                if (typeName.match(/window/i) || typeName.match(/globalThis/i)) {
                    context.report({ node: callee, messageId: 'convertWebSQLUse' });
                }
            },
        };
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const HELMET = 'helmet';
const HIDE_POWERED_BY = 'hide-powered-by';
const HEADER_X_POWERED_BY = 'X-Powered-By'.toLowerCase();
const PROTECTING_MIDDLEWARES = [HELMET, HIDE_POWERED_BY];
/** Expected number of arguments in `app.set`. */
const APP_SET_NUM_ARGS = 2;
const rule$2 = {
    meta: {
        messages: {
            disclosingFingerprinting: 'Make sure disclosing the fingerprinting of this web technology is safe here.',
        },
    },
    create(context) {
        let appInstantiation = null;
        let isSafe = false;
        return {
            Program() {
                appInstantiation = null;
                isSafe = false;
            },
            CallExpression: (node) => {
                if (!isSafe && appInstantiation) {
                    const callExpr = node;
                    isSafe =
                        Express.isUsingMiddleware(context, callExpr, appInstantiation, isProtecting(context)) ||
                            isDisabledXPoweredBy(callExpr, appInstantiation) ||
                            isSetFalseXPoweredBy(callExpr, appInstantiation) ||
                            isAppEscaping(callExpr, appInstantiation);
                }
            },
            VariableDeclarator: (node) => {
                if (!isSafe && !appInstantiation) {
                    const varDecl = node;
                    const app = Express.attemptFindAppInstantiation(varDecl, context);
                    if (app) {
                        appInstantiation = app;
                    }
                }
            },
            ReturnStatement: (node) => {
                if (!isSafe && appInstantiation) {
                    const ret = node;
                    isSafe = isAppEscapingThroughReturn(ret, appInstantiation);
                }
            },
            'Program:exit'() {
                if (!isSafe && appInstantiation) {
                    context.report({
                        node: appInstantiation,
                        messageId: 'disclosingFingerprinting',
                    });
                }
            },
        };
    },
};
/**
 * Checks whether node looks like `helmet.hidePoweredBy()`.
 */
function isHidePoweredByFromHelmet(context, n) {
    var _a;
    if (n.type === 'CallExpression') {
        const callee = n.callee;
        return (callee.type === 'MemberExpression' &&
            ((_a = getModuleNameOfNode(context, callee.object)) === null || _a === void 0 ? void 0 : _a.value) === HELMET &&
            callee.property.type === 'Identifier' &&
            callee.property.name === 'hidePoweredBy');
    }
    return false;
}
function isProtecting(context) {
    return (n) => Express.isMiddlewareInstance(context, PROTECTING_MIDDLEWARES, n) ||
        isHidePoweredByFromHelmet(context, n);
}
function isDisabledXPoweredBy(callExpression, app) {
    if (isMethodInvocation(callExpression, app.name, 'disable', 1)) {
        const arg0 = callExpression.arguments[0];
        return arg0.type === 'Literal' && String(arg0.value).toLowerCase() === HEADER_X_POWERED_BY;
    }
    return false;
}
function isSetFalseXPoweredBy(callExpression, app) {
    if (isMethodInvocation(callExpression, app.name, 'set', APP_SET_NUM_ARGS)) {
        const [headerName, onOff] = callExpression.arguments;
        return (headerName.type === 'Literal' &&
            String(headerName.value).toLowerCase() === HEADER_X_POWERED_BY &&
            onOff.type === 'Literal' &&
            onOff.value === false);
    }
    return false;
}
function isAppEscaping(callExpr, app) {
    return Boolean(callExpr.arguments.find(arg => arg.type === 'Identifier' && arg.name === app.name));
}
function isAppEscapingThroughReturn(ret, app) {
    const arg = ret.argument;
    return Boolean(arg && arg.type === 'Identifier' && arg.name === app.name);
}

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const XML_LIBRARY = 'libxmljs';
const XML_PARSERS = ['parseXml', 'parseXmlString'];
const rule$1 = {
    meta: {
        schema: [
            {
                // internal parameter for rules having secondary locations
                enum: ['sonar-runtime'],
            },
        ],
    },
    create(context) {
        function isXmlParserCall(call) {
            return (((call.callee.type === 'Identifier' && XML_PARSERS.includes(call.callee.name)) ||
                (call.callee.type === 'MemberExpression' &&
                    call.callee.property.type === 'Identifier' &&
                    XML_PARSERS.includes(call.callee.property.name))) &&
                call.arguments.length > 1);
        }
        function isXmlLibraryInScope() {
            return isXmlLibraryImported() || isXmlLibraryRequired();
        }
        function isXmlLibraryImported() {
            return getImportDeclarations(context).findIndex(i => i.source.value === XML_LIBRARY) > -1;
        }
        function isXmlLibraryRequired() {
            return (getRequireCalls(context).findIndex(r => r.arguments[0].type === 'Literal' && r.arguments[0].value === XML_LIBRARY) > -1);
        }
        function isNoEntSet(property) {
            return property.value.type === 'Literal' && property.value.raw === 'true';
        }
        return {
            CallExpression: (node) => {
                const call = node;
                if (isXmlParserCall(call) && isXmlLibraryInScope()) {
                    const noent = getObjectExpressionProperty(call.arguments[1], 'noent');
                    if (noent && isNoEntSet(noent)) {
                        context.report({
                            message: toEncodedMessage$1('Disable access to external entities in XML parsing.', [
                                call.callee,
                            ]),
                            node: noent,
                        });
                    }
                }
            },
        };
    },
};

/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2022 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const xpathModule = 'xpath';
const xpathEvalMethods = ['select', 'select1', 'evaluate'];
const ieEvalMethods = ['selectNodes', 'SelectSingleNode'];
const rule = {
    meta: {
        messages: {
            checkXPath: 'Make sure that executing this XPATH expression is safe.',
        },
    },
    create(context) {
        return {
            MemberExpression: (node) => {
                if (isMemberExpression(node, 'document', 'evaluate')) {
                    context.report({ messageId: 'checkXPath', node });
                }
            },
            CallExpression: (node) => checkCallExpression(node, context),
        };
    },
};
function checkCallExpression({ callee, arguments: args }, context) {
    if (args.length > 0 && isLiteral$2(args[0])) {
        return;
    }
    // IE
    if (isMemberWithProperty$1(callee, ...ieEvalMethods) && args.length === 1) {
        context.report({ messageId: 'checkXPath', node: callee });
        return;
    }
    // Document.evaluate
    if (isMemberWithProperty$1(callee, 'evaluate') &&
        !isMemberExpression(callee, 'document', 'evaluate') &&
        args.length >= 4) {
        const resultTypeArgument = args[3];
        const argumentAsText = context.getSourceCode().getText(resultTypeArgument);
        if (argumentAsText.includes('XPathResult')) {
            context.report({ messageId: 'checkXPath', node: callee });
            return;
        }
    }
    // "xpath" module
    const { module, method } = getModuleAndCalledMethod(callee, context);
    if (method &&
        module &&
        module.value === xpathModule &&
        method.type === 'Identifier' &&
        xpathEvalMethods.includes(method.name)) {
        context.report({ messageId: 'checkXPath', node: callee });
    }
}

var _rules = /*#__PURE__*/Object.freeze({
  __proto__: null,
  anchorPrecedence: rule$2$,
  argumentType: rule$2_,
  argumentsOrder: rule$2Z,
  argumentsUsage: rule$2Y,
  arrayCallbackWithoutReturn: rule$2X,
  arrayConstructor: rule$2W,
  arrowFunctionConvention: rule$2V,
  assertionsInTests: rule$2U,
  bitwiseOperators: rule$2T,
  boolParamDefault: rule$2S,
  callArgumentLine: rule$2R,
  certificateTransparency: rule$2Q,
  chaiDeterminateAssertion: rule$2P,
  className: rule$2O,
  classPrototype: rule$2N,
  codeEval: rule$2M,
  commaOrLogicalOrCase: rule$2L,
  commentRegex: rule$2K,
  conciseRegex: rule$2J,
  conditionalIndentation: rule$2I,
  confidentialInformationLogging: rule$2H,
  constructorForSideEffects: rule$2G,
  contentLength: rule$2E,
  contentSecurityPolicy: rule$2D,
  cookieNoHttponly: rule$2C,
  cookies: rule$2B,
  cors: rule$2A,
  csrf: rule$2z,
  cyclomaticComplexity: rule$2y,
  declarationsInGlobalScope: rule$2x,
  deprecation: rule$2w,
  destructuringAssignmentSyntax: rule$2v,
  differentTypesComparison: rule$2u,
  disabledAutoEscaping: rule$2t,
  disabledResourceIntegrity: rule$2s,
  disabledTimeout: rule$2r,
  dnsPrefetching: rule$2q,
  duplicatesInCharacterClass: rule$2p,
  emptyStringRepetition: rule$2o,
  encryptionSecureMode: rule$2n,
  encryption: rule$2m,
  existingGroups: rule$2l,
  expressionComplexity: rule$2k,
  fileHeader: rule$2j,
  fileNameDifferFromClass: rule$2i,
  filePermissions: rule$2h,
  fileUploads: rule$2F,
  fixmeTag: rule$2f,
  forIn: rule$2e,
  forLoopIncrementSign: rule$2d,
  frameAncestors: rule$2c,
  functionInsideLoop: rule$2b,
  functionName: rule$2a,
  functionReturnType: rule$29,
  futureReservedWords: rule$28,
  generatorWithoutYield: rule$27,
  hashing: rule$26,
  hiddenFiles: rule$25,
  inOperatorTypeError: rule$24,
  inconsistentFunctionCall: rule$23,
  indexOfCompareToPositiveNumber: rule$22,
  insecureCookie: rule$21,
  insecureJwtToken: rule$20,
  invertedAssertionArguments: rule$1$,
  labelPosition: rule$1_,
  maxUnionSize: rule$1Z,
  misplacedLoopCounter: rule$1Y,
  nestedControlFlow: rule$1X,
  newOperatorMisuse: rule$1W,
  noAccessorFieldMismatch: rule$1V,
  noAlphabeticalSort: rule$1U,
  noAngularBypassSanitization: rule$1T,
  noArrayDelete: rule$1S,
  noAssociativeArrays: rule$1R,
  noBuiltInOverride: rule$1Q,
  noCaseLabelInSwitch: rule$1P,
  noClearTextProtocols: rule$1O,
  noCodeAfterDone: rule$1N,
  noCommentedCode: rule$1M,
  noDeadStore: rule$1L,
  noDeleteVar: rule$1K,
  noDuplicateInComposite: rule$1J,
  noEmptyAfterReluctant: rule$1I,
  noEmptyAlternatives: rule$1H,
  noEmptyGroup: rule$1G,
  noEqualsInForTermination: rule$1F,
  noForInIterable: rule$1E,
  noFunctionDeclarationInBlock: rule$1D,
  noGlobalThis: rule$1C,
  noGlobalsShadowing: rule$1B,
  noHardcodedCredentials: rule$1A,
  noHardcodedIp: rule$1z,
  noImplicitDependencies: rule$1y,
  noImplicitGlobal: rule$1x,
  noInMisuse: rule$1w,
  noIncompleteAssertions: rule$1v,
  noInconsistentReturns: rule$1u,
  noIncorrectStringConcat: rule$1t,
  noInfiniteLoop: rule$1s,
  noIntrusivePermissions: rule$1r,
  noInvalidAwait: rule$1q,
  noInvariantReturns: rule$1p,
  noIpForward: rule$1o,
  noLabels: rule$1n,
  noMimeSniff: rule$1m,
  noMisleadingArrayReverse: rule$1l,
  noMixedContent: rule$1k,
  noNestedAssignment: rule$1j,
  noNestedConditional: rule$1i,
  noNestedIncdec: rule$1h,
  noNestedTemplateLiterals: rule$1g,
  noNewSymbol: rule$1f,
  noParameterReassignment: rule$1e,
  noPrimitiveWrappers: rule$1d,
  noRedundantAssignments: rule$1c,
  noRedundantOptional: rule$1b,
  noRedundantParentheses: rule$1a,
  noReferenceError: rule$19,
  noReferrerPolicy: rule$18,
  noRequireOrDefine: rule$17,
  noReturnTypeAny: rule$16,
  noSameArgumentAssert: rule$15,
  noTab: rule$14,
  noTryPromise: rule$13,
  noUndefinedArgument: rule$12,
  noUndefinedAssignment: rule$11,
  noUnenclosedMultilineBlock: rule$10,
  noUnsafeUnzip: rule$$,
  noUnthrownError: rule$_,
  noUnusedFunctionArgument: rule$Z,
  noUselessIncrement: rule$Y,
  noUselessIntersection: rule$X,
  noVariableUsageBeforeDeclaration: rule$W,
  noVueBypassSanitization: rule$V,
  noWeakCipher: rule$U,
  noWeakKeys: rule$T,
  noWildcardImport: rule$S,
  nonNumberInArithmeticExpression: rule$R,
  nullDereference: rule$Q,
  operationReturningNan: rule$P,
  osCommand: rule$O,
  postMessage: rule$N,
  preferDefaultLast: rule$M,
  preferPromiseShorthand: rule$L,
  preferTypeGuard: rule$K,
  processArgv: rule$J,
  productionDebug: rule$I,
  pseudoRandom: rule$H,
  publiclyWritableDirectories: rule$G,
  regexComplexity: rule$F,
  regularExpr: rule$E,
  sessionRegeneration: rule$D,
  shorthandPropertyGrouping: rule$C,
  singleCharacterAlternation: rule$B,
  slowRegex: rule$A,
  sockets: rule$z,
  sonarBlockScopedVar: rule$y,
  sonarMaxLinesPerFunction: rule$x,
  sonarMaxLines: rule$w,
  sonarNoControlRegex: rule$v,
  sonarNoFallthrough: rule$u,
  sonarNoInvalidRegexp: rule$t,
  sonarNoMisleadingCharacterClass: rule$s,
  sonarNoRegexSpaces: rule$r,
  sonarNoUnusedVars: rule$q,
  sqlQueries: rule$p,
  standardInput: rule$o,
  statefulRegex: rule$n,
  strictTransportSecurity: rule$m,
  stringsComparison: rule$l,
  superInvocation: rule$k,
  switchWithoutDefault: rule$j,
  testCheckException: rule$i,
  todoTag: rule$2g,
  tooManyBreakOrContinueInLoop: rule$h,
  unicodeAwareRegex: rule$g,
  unusedImport: rule$f,
  unusedNamedGroups: rule$e,
  unverifiedCertificate: rule$d,
  unverifiedHostname: rule$c,
  updatedConstVar: rule$b,
  updatedLoopCounter: rule$a,
  useTypeAlias: rule$9,
  uselessStringOperation: rule$8,
  valuesNotConvertibleToNumbers: rule$7,
  variableName: rule$6,
  voidUse: rule$5,
  weakSsl: rule$4,
  webSqlDatabase: rule$3,
  xPoweredBy: rule$2,
  xmlParserXxe: rule$1,
  xpath: rule
});

const camelCase = (value) => value.replace(/-[a-z]/g, matched => matched[1].toUpperCase());
const kebabCase = (value) => value.replace(/[A-Z]/g, matched => '-' + matched.toLowerCase());
const normalizeModules = (modules) => Object.entries(modules).reduce((acc, [name, module]) => Object.assign(acc, {
    [kebabCase(name)]: module,
}), {});

const configs = normalizeModules(_configs);
const rules = normalizeModules(_rules);

exports.anchorPrecedence = rule$2$;
exports.argumentType = rule$2_;
exports.argumentsOrder = rule$2Z;
exports.argumentsUsage = rule$2Y;
exports.arrayCallbackWithoutReturn = rule$2X;
exports.arrayConstructor = rule$2W;
exports.arrowFunctionConvention = rule$2V;
exports.assertionsInTests = rule$2U;
exports.bitwiseOperators = rule$2T;
exports.boolParamDefault = rule$2S;
exports.callArgumentLine = rule$2R;
exports.camelCase = camelCase;
exports.certificateTransparency = rule$2Q;
exports.chaiDeterminateAssertion = rule$2P;
exports.className = rule$2O;
exports.classPrototype = rule$2N;
exports.codeEval = rule$2M;
exports.commaOrLogicalOrCase = rule$2L;
exports.commentRegex = rule$2K;
exports.conciseRegex = rule$2J;
exports.conditionalIndentation = rule$2I;
exports.confidentialInformationLogging = rule$2H;
exports.configs = configs;
exports.constructorForSideEffects = rule$2G;
exports.contentLength = rule$2E;
exports.contentSecurityPolicy = rule$2D;
exports.cookieNoHttponly = rule$2C;
exports.cookies = rule$2B;
exports.cors = rule$2A;
exports.csrf = rule$2z;
exports.cyclomaticComplexity = rule$2y;
exports.declarationsInGlobalScope = rule$2x;
exports.deprecation = rule$2w;
exports.destructuringAssignmentSyntax = rule$2v;
exports.differentTypesComparison = rule$2u;
exports.disabledAutoEscaping = rule$2t;
exports.disabledResourceIntegrity = rule$2s;
exports.disabledTimeout = rule$2r;
exports.dnsPrefetching = rule$2q;
exports.duplicatesInCharacterClass = rule$2p;
exports.emptyStringRepetition = rule$2o;
exports.encryption = rule$2m;
exports.encryptionSecureMode = rule$2n;
exports.existingGroups = rule$2l;
exports.expressionComplexity = rule$2k;
exports.fileHeader = rule$2j;
exports.fileNameDifferFromClass = rule$2i;
exports.filePermissions = rule$2h;
exports.fileUploads = rule$2F;
exports.fixmeTag = rule$2f;
exports.forIn = rule$2e;
exports.forLoopIncrementSign = rule$2d;
exports.frameAncestors = rule$2c;
exports.functionInsideLoop = rule$2b;
exports.functionName = rule$2a;
exports.functionReturnType = rule$29;
exports.futureReservedWords = rule$28;
exports.generatorWithoutYield = rule$27;
exports.hashing = rule$26;
exports.hiddenFiles = rule$25;
exports.inOperatorTypeError = rule$24;
exports.inconsistentFunctionCall = rule$23;
exports.indexOfCompareToPositiveNumber = rule$22;
exports.insecureCookie = rule$21;
exports.insecureJwtToken = rule$20;
exports.invertedAssertionArguments = rule$1$;
exports.kebabCase = kebabCase;
exports.labelPosition = rule$1_;
exports.maxUnionSize = rule$1Z;
exports.misplacedLoopCounter = rule$1Y;
exports.nestedControlFlow = rule$1X;
exports.newOperatorMisuse = rule$1W;
exports.noAccessorFieldMismatch = rule$1V;
exports.noAlphabeticalSort = rule$1U;
exports.noAngularBypassSanitization = rule$1T;
exports.noArrayDelete = rule$1S;
exports.noAssociativeArrays = rule$1R;
exports.noBuiltInOverride = rule$1Q;
exports.noCaseLabelInSwitch = rule$1P;
exports.noClearTextProtocols = rule$1O;
exports.noCodeAfterDone = rule$1N;
exports.noCommentedCode = rule$1M;
exports.noDeadStore = rule$1L;
exports.noDeleteVar = rule$1K;
exports.noDuplicateInComposite = rule$1J;
exports.noEmptyAfterReluctant = rule$1I;
exports.noEmptyAlternatives = rule$1H;
exports.noEmptyGroup = rule$1G;
exports.noEqualsInForTermination = rule$1F;
exports.noForInIterable = rule$1E;
exports.noFunctionDeclarationInBlock = rule$1D;
exports.noGlobalThis = rule$1C;
exports.noGlobalsShadowing = rule$1B;
exports.noHardcodedCredentials = rule$1A;
exports.noHardcodedIp = rule$1z;
exports.noImplicitDependencies = rule$1y;
exports.noImplicitGlobal = rule$1x;
exports.noInMisuse = rule$1w;
exports.noIncompleteAssertions = rule$1v;
exports.noInconsistentReturns = rule$1u;
exports.noIncorrectStringConcat = rule$1t;
exports.noInfiniteLoop = rule$1s;
exports.noIntrusivePermissions = rule$1r;
exports.noInvalidAwait = rule$1q;
exports.noInvariantReturns = rule$1p;
exports.noIpForward = rule$1o;
exports.noLabels = rule$1n;
exports.noMimeSniff = rule$1m;
exports.noMisleadingArrayReverse = rule$1l;
exports.noMixedContent = rule$1k;
exports.noNestedAssignment = rule$1j;
exports.noNestedConditional = rule$1i;
exports.noNestedIncdec = rule$1h;
exports.noNestedTemplateLiterals = rule$1g;
exports.noNewSymbol = rule$1f;
exports.noParameterReassignment = rule$1e;
exports.noPrimitiveWrappers = rule$1d;
exports.noRedundantAssignments = rule$1c;
exports.noRedundantOptional = rule$1b;
exports.noRedundantParentheses = rule$1a;
exports.noReferenceError = rule$19;
exports.noReferrerPolicy = rule$18;
exports.noRequireOrDefine = rule$17;
exports.noReturnTypeAny = rule$16;
exports.noSameArgumentAssert = rule$15;
exports.noTab = rule$14;
exports.noTryPromise = rule$13;
exports.noUndefinedArgument = rule$12;
exports.noUndefinedAssignment = rule$11;
exports.noUnenclosedMultilineBlock = rule$10;
exports.noUnsafeUnzip = rule$$;
exports.noUnthrownError = rule$_;
exports.noUnusedFunctionArgument = rule$Z;
exports.noUselessIncrement = rule$Y;
exports.noUselessIntersection = rule$X;
exports.noVariableUsageBeforeDeclaration = rule$W;
exports.noVueBypassSanitization = rule$V;
exports.noWeakCipher = rule$U;
exports.noWeakKeys = rule$T;
exports.noWildcardImport = rule$S;
exports.nonNumberInArithmeticExpression = rule$R;
exports.normalizeModules = normalizeModules;
exports.nullDereference = rule$Q;
exports.operationReturningNan = rule$P;
exports.osCommand = rule$O;
exports.postMessage = rule$N;
exports.preferDefaultLast = rule$M;
exports.preferPromiseShorthand = rule$L;
exports.preferTypeGuard = rule$K;
exports.processArgv = rule$J;
exports.productionDebug = rule$I;
exports.pseudoRandom = rule$H;
exports.publiclyWritableDirectories = rule$G;
exports.regexComplexity = rule$F;
exports.regularExpr = rule$E;
exports.rules = rules;
exports.sessionRegeneration = rule$D;
exports.shorthandPropertyGrouping = rule$C;
exports.singleCharacterAlternation = rule$B;
exports.slowRegex = rule$A;
exports.sockets = rule$z;
exports.sonarBlockScopedVar = rule$y;
exports.sonarMaxLines = rule$w;
exports.sonarMaxLinesPerFunction = rule$x;
exports.sonarNoControlRegex = rule$v;
exports.sonarNoFallthrough = rule$u;
exports.sonarNoInvalidRegexp = rule$t;
exports.sonarNoMisleadingCharacterClass = rule$s;
exports.sonarNoRegexSpaces = rule$r;
exports.sonarNoUnusedVars = rule$q;
exports.sqlQueries = rule$p;
exports.standardInput = rule$o;
exports.statefulRegex = rule$n;
exports.strictTransportSecurity = rule$m;
exports.stringsComparison = rule$l;
exports.superInvocation = rule$k;
exports.switchWithoutDefault = rule$j;
exports.testCheckException = rule$i;
exports.todoTag = rule$2g;
exports.tooManyBreakOrContinueInLoop = rule$h;
exports.unicodeAwareRegex = rule$g;
exports.unusedImport = rule$f;
exports.unusedNamedGroups = rule$e;
exports.unverifiedCertificate = rule$d;
exports.unverifiedHostname = rule$c;
exports.updatedConstVar = rule$b;
exports.updatedLoopCounter = rule$a;
exports.useTypeAlias = rule$9;
exports.uselessStringOperation = rule$8;
exports.valuesNotConvertibleToNumbers = rule$7;
exports.variableName = rule$6;
exports.voidUse = rule$5;
exports.weakSsl = rule$4;
exports.webSqlDatabase = rule$3;
exports.xPoweredBy = rule$2;
exports.xmlParserXxe = rule$1;
exports.xpath = rule;
//# sourceMappingURL=index.cjs.map
