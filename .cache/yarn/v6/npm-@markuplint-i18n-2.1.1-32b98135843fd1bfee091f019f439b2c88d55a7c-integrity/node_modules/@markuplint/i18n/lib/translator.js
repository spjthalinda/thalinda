"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.taggedTemplateTranslator = exports.translator = void 0;
const defaultListFormat = {
    quoteStart: '"',
    quoteEnd: '"',
    separator: ', ',
};
function translator(localeSet) {
    return (messageTmpl, ...keywords) => {
        var _a;
        let message = messageTmpl;
        if (Array.isArray(messageTmpl)) {
            const format = (localeSet === null || localeSet === void 0 ? void 0 : localeSet.listFormat) || defaultListFormat;
            return `${format.quoteStart}${messageTmpl
                .map(keyword => translateKeyword(keyword, '', localeSet))
                .join(`${format.quoteEnd}${format.separator}${format.quoteStart}`)}${format.quoteEnd}`;
        }
        if (keywords.length === 0) {
            return translateKeyword(messageTmpl, '', localeSet);
        }
        const noTranslateIndex = Array.from(messageTmpl.matchAll(/(?<=\{)[0-9]+(?=\*\})/g)).map(m => m[0]);
        const key = messageTmpl.replace(/(?<=\{[0-9]+)\*(?=\})/g, '');
        const sentence = (_a = localeSet === null || localeSet === void 0 ? void 0 : localeSet.sentences) === null || _a === void 0 ? void 0 : _a[key];
        messageTmpl = sentence !== null && sentence !== void 0 ? sentence : key;
        message = messageTmpl.replace(/\{([0-9]+)(?::([c]))?\}/g, ($0, number, flag) => {
            const num = parseInt(number);
            if (isNaN(num)) {
                return $0;
            }
            const keyword = keywords[num] != null ? toString(keywords[num], localeSet === null || localeSet === void 0 ? void 0 : localeSet.locale) : '';
            // No translate
            if (noTranslateIndex.includes(number)) {
                return keyword;
            }
            return translateKeyword(keyword, flag, localeSet);
        });
        return message;
    };
}
exports.translator = translator;
/**
 * @experimental
 */
function taggedTemplateTranslator(localeSet) {
    const t = translator(localeSet);
    return (strings, ...keys) => {
        let i = 0;
        const template = strings.raw
            .map((place, index) => {
            if (index === strings.raw.length - 1)
                return place;
            const value = keys[i];
            const cFlag = /^c:/.test(typeof value === 'string' ? value : '') ? ':c' : '';
            return `${place}{${i++}${cFlag}}`;
        })
            .join('');
        return t(template, ...keys);
    };
}
exports.taggedTemplateTranslator = taggedTemplateTranslator;
function translateKeyword(keyword, flag, localeSet) {
    var _a, _b;
    // No translate
    if (/^%[^%]+%$/.test(keyword)) {
        return keyword.replace(/^%|%$/g, '');
    }
    // "%" prefix and suffix escaped
    keyword = keyword.replace(/^%%|%%$/g, '%');
    const key = flag ? `${flag}:${keyword}` : keyword;
    const replacedWord = 
    // finding with flag
    ((_a = localeSet === null || localeSet === void 0 ? void 0 : localeSet.keywords) === null || _a === void 0 ? void 0 : _a[key.toLowerCase()]) ||
        (
        // finding without flag
        (_b = localeSet === null || localeSet === void 0 ? void 0 : localeSet.keywords) === null || _b === void 0 ? void 0 : _b[keyword.toLowerCase()]);
    return replacedWord || keyword;
}
function toString(value, locale = 'en') {
    switch (typeof value) {
        case 'string':
            return value;
        case 'number':
            return toLocaleString(value, locale);
        case 'boolean':
            return `${value}`;
    }
}
function toLocaleString(value, locale) {
    try {
        return value.toLocaleString(locale);
    }
    catch (e) {
        if (e instanceof RangeError) {
            try {
                return value.toLocaleString('en');
            }
            catch (_) {
                // void
            }
        }
    }
    return value.toString(10);
}
