{
  "manifest": {
    "name": "jsonc-parser",
    "version": "3.0.0",
    "description": "Scanner and parser for JSON with comments.",
    "main": "./lib/umd/main.js",
    "typings": "./lib/umd/main",
    "module": "./lib/esm/main.js",
    "author": {
      "name": "Microsoft Corporation"
    },
    "repository": {
      "type": "git",
      "url": "https://github.com/microsoft/node-jsonc-parser"
    },
    "license": "MIT",
    "bugs": {
      "url": "https://github.com/microsoft/node-jsonc-parser/issues"
    },
    "devDependencies": {
      "mocha": "^8.2.1",
      "typescript": "^4.0.5",
      "@types/node": "^10.12.12",
      "@types/mocha": "^5.2.7",
      "@typescript-eslint/eslint-plugin": "^4.7.0",
      "@typescript-eslint/parser": "^4.7.0",
      "eslint": "^7.13.0",
      "rimraf": "^3.0.2"
    },
    "scripts": {
      "prepublishOnly": "npm run clean && npm run compile-esm && npm run test && npm run remove-sourcemap-refs",
      "postpublish": "node ./build/post-publish.js",
      "compile": "tsc -p ./src && npm run lint",
      "compile-esm": "tsc -p ./src/tsconfig.esm.json",
      "remove-sourcemap-refs": "node ./build/remove-sourcemap-refs.js",
      "clean": "rimraf lib",
      "watch": "tsc -w -p ./src",
      "test": "npm run compile && mocha ./lib/umd/test",
      "lint": "eslint src/**/*.ts",
      "preversion": "npm test",
      "postversion": "git push && git push --tags"
    },
    "_registry": "npm",
    "_loc": "/data/data/com.termux/files/home/.cache/yarn/v6/npm-jsonc-parser-3.0.0-abdd785701c7e7eaca8a9ec8cf070ca51a745a22-integrity/node_modules/jsonc-parser/package.json",
    "readmeFilename": "README.md",
    "readme": "# jsonc-parser\nScanner and parser for JSON with comments.\n\n[![npm Package](https://img.shields.io/npm/v/jsonc-parser.svg?style=flat-square)](https://www.npmjs.org/package/jsonc-parser)\n[![NPM Downloads](https://img.shields.io/npm/dm/jsonc-parser.svg)](https://npmjs.org/package/jsonc-parser)\n[![Build Status](https://travis-ci.org/Microsoft/node-jsonc-parser.svg?branch=master)](https://travis-ci.org/Microsoft/node-jsonc-parser)\n\nWhy?\n----\nJSONC is JSON with JavaScript style comments. This node module provides a scanner and fault tolerant parser that can process JSONC but is also useful for standard JSON.\n - the *scanner* tokenizes the input string into tokens and token offsets\n - the *visit* function implements a 'SAX' style parser with callbacks for the encountered properties and values.\n - the *parseTree* function computes a hierarchical DOM with offsets representing the encountered properties and values.\n - the *parse* function evaluates the JavaScript object represented by JSON string in a fault tolerant fashion. \n - the *getLocation* API returns a location object that describes the property or value located at a given offset in a JSON document.\n - the *findNodeAtLocation* API finds the node at a given location path in a JSON DOM.\n - the *format* API computes edits to format a JSON document.\n - the *modify* API computes edits to insert, remove or replace a property or value in a JSON document.\n - the *applyEdits* API applies edits to a document.\n\nInstallation\n------------\n\n    npm install --save jsonc-parser\n    \n    \nAPI\n---\n\n### Scanner:\n```typescript\n\n/**\n * Creates a JSON scanner on the given text.\n * If ignoreTrivia is set, whitespaces or comments are ignored.\n */\nexport function createScanner(text:string, ignoreTrivia:boolean = false):JSONScanner;\n    \n/**\n * The scanner object, representing a JSON scanner at a position in the input string.\n */\nexport interface JSONScanner {\n    /**\n     * Sets the scan position to a new offset. A call to 'scan' is needed to get the first token.\n     */\n    setPosition(pos: number): any;\n    /**\n     * Read the next token. Returns the token code.\n     */\n    scan(): SyntaxKind;\n    /**\n     * Returns the current scan position, which is after the last read token.\n     */\n    getPosition(): number;\n    /**\n     * Returns the last read token.\n     */\n    getToken(): SyntaxKind;\n    /**\n     * Returns the last read token value. The value for strings is the decoded string content. For numbers its of type number, for boolean it's true or false.\n     */\n    getTokenValue(): string;\n    /**\n     * The start offset of the last read token.\n     */\n    getTokenOffset(): number;\n    /**\n     * The length of the last read token.\n     */\n    getTokenLength(): number;\n    /**\n     * The zero-based start line number of the last read token.\n     */\n    getTokenStartLine(): number;\n    /**\n     * The zero-based start character (column) of the last read token.\n     */\n    getTokenStartCharacter(): number;\n    /**\n     * An error code of the last scan.\n     */\n    getTokenError(): ScanError;\n}\n```\n\n### Parser:\n```typescript\n\nexport interface ParseOptions {\n    disallowComments?: boolean;\n}\n/**\n * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n * Therefore always check the errors list to find out if the input was valid.\n */\nexport declare function parse(text: string, errors?: {error: ParseErrorCode;}[], options?: ParseOptions): any;\n\n/**\n * Parses the given text and invokes the visitor functions for each object, array and literal reached.\n */\nexport declare function visit(text: string, visitor: JSONVisitor, options?: ParseOptions): any;\n\nexport interface JSONVisitor {\n    /**\n     * Invoked when an open brace is encountered and an object is started. The offset and length represent the location of the open brace.\n     */\n    onObjectBegin?: (offset: number, length: number, startLine: number, startCharacter: number) => void;\n    /**\n     * Invoked when a property is encountered. The offset and length represent the location of the property name.\n     */\n    onObjectProperty?: (property: string, offset: number, length: number, startLine: number, startCharacter: number) => void;\n    /**\n     * Invoked when a closing brace is encountered and an object is completed. The offset and length represent the location of the closing brace.\n     */\n    onObjectEnd?: (offset: number, length: number, startLine: number, startCharacter: number) => void;\n    /**\n     * Invoked when an open bracket is encountered. The offset and length represent the location of the open bracket.\n     */\n    onArrayBegin?: (offset: number, length: number, startLine: number, startCharacter: number) => void;\n    /**\n     * Invoked when a closing bracket is encountered. The offset and length represent the location of the closing bracket.\n     */\n    onArrayEnd?: (offset: number, length: number, startLine: number, startCharacter: number) => void;\n    /**\n     * Invoked when a literal value is encountered. The offset and length represent the location of the literal value.\n     */\n    onLiteralValue?: (value: any, offset: number, length: number, startLine: number, startCharacter: number) => void;\n    /**\n     * Invoked when a comma or colon separator is encountered. The offset and length represent the location of the separator.\n     */\n    onSeparator?: (character: string, offset: number, length: number, startLine: number, startCharacter: number) => void;\n    /**\n     * When comments are allowed, invoked when a line or block comment is encountered. The offset and length represent the location of the comment.\n     */\n    onComment?: (offset: number, length: number, startLine: number, startCharacter: number) => void;\n    /**\n     * Invoked on an error.\n     */\n    onError?: (error: ParseErrorCode, offset: number, length: number, startLine: number, startCharacter: number) => void;\n}\n\n/**\n * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n */\nexport declare function parseTree(text: string, errors?: ParseError[], options?: ParseOptions): Node | undefined;\n\nexport declare type NodeType = \"object\" | \"array\" | \"property\" | \"string\" | \"number\" | \"boolean\" | \"null\";\nexport interface Node {\n    type: NodeType;\n    value?: any;\n    offset: number;\n    length: number;\n    colonOffset?: number;\n    parent?: Node;\n    children?: Node[];\n}\n\n```\n\n### Utilities:\n```typescript\n/**\n * Takes JSON with JavaScript-style comments and remove\n * them. Optionally replaces every none-newline character\n * of comments with a replaceCharacter\n */\nexport declare function stripComments(text: string, replaceCh?: string): string;\n\n/**\n * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.\n */\nexport declare function getLocation(text: string, position: number): Location;\n\nexport declare type Segment = string | number;\nexport interface Location {\n    /**\n     * The previous property key or literal value (string, number, boolean or null) or undefined.\n     */\n    previousNode?: Node;\n    /**\n     * The path describing the location in the JSON document. The path consists of a sequence strings\n     * representing an object property or numbers for array indices.\n     */\n    path: Segment[];\n    /**\n     * Matches the locations path against a pattern consisting of strings (for properties) and numbers (for array indices).\n     * '*' will match a single segment, of any property name or index.\n     * '**' will match a sequece of segments or no segment, of any property name or index.\n     */\n    matches: (patterns: Segment[]) => boolean;\n    /**\n     * If set, the location's offset is at a property key.\n     */\n    isAtPropertyKey: boolean;\n}\n\n/**\n * Finds the node at the given path in a JSON DOM.\n */\nexport function findNodeAtLocation(root: Node, path: JSONPath): Node | undefined;\n\n/**\n * Finds the most inner node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.\n */\nexport function findNodeAtOffset(root: Node, offset: number, includeRightBound?: boolean) : Node | undefined;\n\n/**\n * Gets the JSON path of the given JSON DOM node\n */\nexport function getNodePath(node: Node) : JSONPath;\n\n/**\n * Evaluates the JavaScript object of the given JSON DOM node \n */\nexport function getNodeValue(node: Node): any;\n\n/**\n * Computes the edits needed to format a JSON document. \n * \n * @param documentText The input text \n * @param range The range to format or `undefined` to format the full content\n * @param options The formatting options\n * @returns A list of edit operations describing the formatting changes to the original document. Edits can be either inserts, replacements or\n * removals of text segments. All offsets refer to the original state of the document. No two edits must change or remove the same range of\n * text in the original document. However, multiple edits can have\n * the same offset, for example multiple inserts, or an insert followed by a remove or replace. The order in the array defines which edit is applied first.\n * To apply edits to an input, you can use `applyEdits`\n */\nexport function format(documentText: string, range: Range, options: FormattingOptions): Edit[];\n\n\n/**\n * Computes the edits needed to modify a value in the JSON document.\n * \n * @param documentText The input text \n * @param path The path of the value to change. The path represents either to the document root, a property or an array item.\n * If the path points to an non-existing property or item, it will be created. \n * @param value The new value for the specified property or item. If the value is undefined,\n * the property or item will be removed.\n * @param options Options\n * @returns A list of edit operations describing the formatting changes to the original document. Edits can be either inserts, replacements or\n * removals of text segments. All offsets refer to the original state of the document. No two edits must change or remove the same range of\n * text in the original document. However, multiple edits can have\n * the same offset, for example multiple inserts, or an insert followed by a remove or replace. The order in the array defines which edit is applied first.\n * To apply edits to an input, you can use `applyEdits`\n */\nexport function modify(text: string, path: JSONPath, value: any, options: ModificationOptions): Edit[];\n\n/**\n * Applies edits to a input string.\n */\nexport function applyEdits(text: string, edits: Edit[]): string;\n\n/**\n * Represents a text modification\n */\nexport interface Edit {\n\t/**\n\t * The start offset of the modification.\n\t */\n\toffset: number;\n\t/**\n\t * The length of the modification. Must not be negative. Empty length represents an *insert*.\n\t */\n\tlength: number;\n\t/**\n\t * The new content. Empty content represents a *remove*.\n\t */\n\tcontent: string;\n}\n\n/**\n * A text range in the document\n*/\nexport interface Range {\n\t/**\n\t * The start offset of the range. \n\t */\n\toffset: number;\n\t/**\n\t * The length of the range. Must not be negative.  \n\t */\n\tlength: number;\n}\n\nexport interface FormattingOptions {\n\t/**\n\t * If indentation is based on spaces (`insertSpaces` = true), then what is the number of spaces that make an indent?\n\t */\n\ttabSize: number;\n\t/**\n\t * Is indentation based on spaces?\n\t */\n\tinsertSpaces: boolean;\n\t/**\n\t * The default 'end of line' character\n\t */\n\teol: string;\n}\n\n```\n\n\nLicense\n-------\n\n(MIT License)\n\nCopyright 2018, Microsoft\n",
    "licenseText": "The MIT License (MIT)\n\nCopyright (c) Microsoft\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/jsonc-parser/-/jsonc-parser-3.0.0.tgz#abdd785701c7e7eaca8a9ec8cf070ca51a745a22",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/jsonc-parser/-/jsonc-parser-3.0.0.tgz",
    "hash": "abdd785701c7e7eaca8a9ec8cf070ca51a745a22",
    "integrity": "sha512-fQzRfAbIBnR0IQvftw9FJveWiHp72Fg20giDrHz6TdfB12UH/uue0D3hm57UB5KgAVuniLMCaS8P1IMj9NR7cA==",
    "registry": "npm",
    "packageName": "jsonc-parser",
    "cacheIntegrity": "sha512-fQzRfAbIBnR0IQvftw9FJveWiHp72Fg20giDrHz6TdfB12UH/uue0D3hm57UB5KgAVuniLMCaS8P1IMj9NR7cA== sha1-q914VwHH5+rKip7IzwcMpRp0WiI="
  },
  "registry": "npm",
  "hash": "abdd785701c7e7eaca8a9ec8cf070ca51a745a22"
}