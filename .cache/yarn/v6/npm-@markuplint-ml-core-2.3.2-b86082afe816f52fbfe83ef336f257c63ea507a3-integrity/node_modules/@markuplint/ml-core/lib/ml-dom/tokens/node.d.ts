import type { Document } from '../';
import type { RuleInfo } from '../../';
import type { AnonymousNode, IMLDOMNode, NodeType } from '../types';
import type { MLDOMElement, MLDOMOmittedElement, MLDOMPreprocessorSpecificBlock } from './';
import type { MLASTAbstructNode } from '@markuplint/ml-ast';
import type { AnyRule, RuleConfigValue } from '@markuplint/ml-config';
import MLDOMToken from './token';
export default abstract class MLDOMNode<T extends RuleConfigValue, O = null, A extends MLASTAbstructNode = MLASTAbstructNode> extends MLDOMToken<A> implements IMLDOMNode {
    #private;
    readonly ELEMENT_NODE = 1;
    readonly ATTRIBUTE_NODE = 2;
    readonly TEXT_NODE = 3;
    readonly CDATA_SECTION_NODE = 4;
    readonly ENTITY_REFERENCE_NODE = 5;
    readonly ENTITY_NODE = 6;
    readonly PROCESSING_INSTRUCTION_NODE = 7;
    readonly COMMENT_NODE = 8;
    readonly DOCUMENT_NODE = 9;
    readonly DOCUMENT_TYPE_NODE = 10;
    readonly DOCUMENT_FRAGMENT_NODE = 11;
    readonly NOTATION_NODE = 12;
    readonly ownerDocument: Document<T, O>;
    readonly type: NodeType;
    readonly rules: Record<string, AnyRule>;
    protected _astToken: A;
    constructor(astNode: A, document: Document<T, O>);
    get childNodes(): AnonymousNode<T, O>[];
    get parentNode(): MLDOMElement<T, O> | MLDOMOmittedElement<T, O> | MLDOMPreprocessorSpecificBlock<T, O> | null;
    get prevNode(): AnonymousNode<T, O> | null;
    get nextNode(): AnonymousNode<T, O> | null;
    get syntaxicalParentNode(): MLDOMElement<T, O> | MLDOMPreprocessorSpecificBlock<T, O> | null;
    get prevToken(): AnonymousNode<T, O> | null;
    get nodeStore(): import("../helper").NodeStore;
    get rule(): RuleInfo<T, O>;
    get textContent(): string | null;
    getParentElement(): MLDOMElement<T, O> | MLDOMOmittedElement<T, O> | null;
    is(type: NodeType): boolean;
    toString(): string;
}
