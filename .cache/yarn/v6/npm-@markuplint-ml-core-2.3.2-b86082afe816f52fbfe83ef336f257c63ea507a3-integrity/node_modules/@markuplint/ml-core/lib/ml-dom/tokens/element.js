"use strict";
var _MLDOMElement_tagOpenChar, _MLDOMElement_tagCloseChar;
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const string_splice_1 = require("../../utils/string-splice");
const helper_1 = require("../helper");
const walkers_1 = require("../helper/walkers");
const abstract_element_1 = tslib_1.__importDefault(require("./abstract-element"));
const attribute_1 = tslib_1.__importDefault(require("./attribute"));
const preprocessor_specific_attribute_1 = tslib_1.__importDefault(require("./preprocessor-specific-attribute"));
const token_1 = tslib_1.__importDefault(require("./token"));
class MLDOMElement extends abstract_element_1.default {
    constructor(astNode, document) {
        super(astNode, document);
        this.type = 'Element';
        _MLDOMElement_tagOpenChar.set(this, void 0);
        _MLDOMElement_tagCloseChar.set(this, void 0);
        this.attributes.push(...astNode.attributes.map(attr => attr.type === 'html-attr' ? new attribute_1.default(attr) : new preprocessor_specific_attribute_1.default(attr)));
        this.hasSpreadAttr = astNode.hasSpreadAttr;
        this.selfClosingSolidus = astNode.selfClosingSolidus ? new token_1.default(astNode.selfClosingSolidus) : null;
        this.endSpace = astNode.endSpace ? new token_1.default(astNode.endSpace) : null;
        this.closeTag = astNode.pearNode ? (0, helper_1.createNode)(astNode.pearNode, document, this) : null;
        tslib_1.__classPrivateFieldSet(this, _MLDOMElement_tagOpenChar, astNode.tagOpenChar, "f");
        tslib_1.__classPrivateFieldSet(this, _MLDOMElement_tagCloseChar, astNode.tagCloseChar, "f");
    }
    get raw() {
        let fixed = this.originRaw;
        let gap = 0;
        if (this.nodeName !== this.fixedNodeName) {
            fixed = (0, string_splice_1.stringSplice)(fixed, tslib_1.__classPrivateFieldGet(this, _MLDOMElement_tagOpenChar, "f").length, this.nodeName.length, this.fixedNodeName);
            gap = gap + this.fixedNodeName.length - this.nodeName.length;
        }
        for (const attr of this.attributes) {
            const startOffset = (attr.attrType === 'html-attr' ? attr.spacesBeforeName.startOffset : attr.startOffset) -
                this.startOffset;
            const fixedAttr = attr.toString();
            if (attr.originRaw !== fixedAttr) {
                fixed = (0, string_splice_1.stringSplice)(fixed, startOffset + gap, attr.originRaw.length, fixedAttr);
                gap = gap + fixedAttr.length - attr.originRaw.length;
            }
        }
        return fixed;
    }
    querySelectorAll(selector) {
        const matchedNodes = [];
        const selecor = (0, helper_1.createSelector)(selector);
        (0, walkers_1.syncWalk)(this.childNodes, node => {
            if (node.type === 'Element' && selecor.match(node, this)) {
                matchedNodes.push(node);
            }
            if (selector === '#text' && node.type === 'Text' && !node.isWhitespace()) {
                matchedNodes.push(node);
            }
        });
        return matchedNodes;
    }
    getNameLocation() {
        return {
            offset: this.startOffset,
            line: this.startLine,
            col: this.startCol + tslib_1.__classPrivateFieldGet(this, _MLDOMElement_tagOpenChar, "f").length,
        };
    }
}
exports.default = MLDOMElement;
_MLDOMElement_tagOpenChar = new WeakMap(), _MLDOMElement_tagCloseChar = new WeakMap();
