"use strict";
var _MLDOMDocument_filename;
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const ml_config_1 = require("@markuplint/ml-config");
const ml_spec_1 = require("@markuplint/ml-spec");
const debug_1 = require("../debug");
const helper_1 = require("./helper");
const debug_2 = require("./helper/debug");
const match_selector_1 = require("./helper/match-selector");
const walkers_1 = require("./helper/walkers");
const rule_mapper_1 = require("./rule-mapper");
const tokens_1 = require("./tokens");
const log = debug_1.log.extend('ml-dom');
const docLog = log.extend('document');
const ruleLog = docLog.extend('rule');
/**
 * markuplint DOM Document
 */
class MLDOMDocument {
    /**
     *
     * @param ast node list of markuplint AST
     * @param ruleset ruleset object
     */
    constructor(ast, ruleset, schemas, options) {
        var _a;
        /**
         *
         */
        this.currentRule = null;
        /**
         *
         */
        this.nodeStore = new helper_1.NodeStore();
        /**
         * Window object for calling the `getComputedStyle` and the `getPropertyValue` that are needed by **Accessible Name and Description Computation**.
         * But it always returns the empty object.
         * (It may improve to possible to compute the name from the `style` attribute in the future.)
         */
        this.defaultView = {
            getComputedStyle(_el) {
                return {
                    getPropertyValue(_propName) {
                        return {};
                    },
                };
            },
        };
        _MLDOMDocument_filename.set(this, void 0);
        this.isFragment = ast.isFragment;
        this.specs = (0, ml_spec_1.getSpec)(schemas);
        this.endTag = (_a = options === null || options === void 0 ? void 0 : options.endTag) !== null && _a !== void 0 ? _a : 'omittable';
        tslib_1.__classPrivateFieldSet(this, _MLDOMDocument_filename, options === null || options === void 0 ? void 0 : options.filename, "f");
        // console.log(ast.nodeList.map((n, i) => `${i}: ${n.uuid} "${n.raw.trim()}"(${n.type})`));
        this.nodeList = Object.freeze(ast.nodeList.map(astNode => {
            if (astNode.type === 'endtag') {
                return this.nodeStore.getNode(astNode);
            }
            return (0, helper_1.createNode)(astNode, this);
        }));
        this._ruleMapping(ruleset, options === null || options === void 0 ? void 0 : options.tagNameCaseSensitive);
    }
    /**
     * It could be used in rule, make sure it is immutable
     */
    get filename() {
        return tslib_1.__classPrivateFieldGet(this, _MLDOMDocument_filename, "f");
    }
    get doctype() {
        for (const node of this.nodeList) {
            if (node instanceof tokens_1.MLDOMDoctype) {
                return node;
            }
        }
        return null;
    }
    get tree() {
        const treeRoots = [];
        let traversalNode = this.nodeList[0];
        while (traversalNode) {
            treeRoots.push(traversalNode);
            traversalNode = traversalNode.nextNode;
        }
        return treeRoots;
    }
    walk(walker) {
        /**
         * The following pattern is used to ensure that all rules run sequentially,
         * no matter it runs asynchronously or synchronously.
         */
        let _resolve;
        let _reject;
        const promise = new Promise((resolve, reject) => {
            _resolve = resolve;
            _reject = reject;
        });
        const loop = (index = 0) => {
            if (index >= this.nodeList.length) {
                _resolve();
                return;
            }
            const node = this.nodeList[index];
            const result = walker(node);
            if (result instanceof Promise) {
                result.then(() => loop(index + 1)).catch(_reject);
            }
            else {
                loop(index + 1);
            }
        };
        loop();
        return promise;
    }
    walkOn(type, walker, skipWhenRuleIsDisabled = true) {
        return this.walk(node => {
            if (node instanceof tokens_1.MLDOMNode) {
                if (skipWhenRuleIsDisabled && node.rule.disabled) {
                    return;
                }
                if (node.is(type)) {
                    return walker(node);
                }
            }
        });
    }
    setRule(rule) {
        this.currentRule = rule;
    }
    matchNodes(query) {
        return this.nodeList.filter((node) => node.type === 'Element' && node.matches(query));
    }
    querySelectorAll(query) {
        return this.matchNodes(query);
    }
    querySelector(query) {
        return this.querySelectorAll(query)[0] || null;
    }
    getElementById(id) {
        return this.querySelector(`#${id}`);
    }
    toString() {
        const html = [];
        for (const node of this.nodeList) {
            html.push(node.raw);
        }
        return html.join('');
    }
    debugMap() {
        return (0, debug_2.nodeListToDebugMaps)(this.nodeList, true);
    }
    _ruleMapping(ruleset, tagNameCaseSensitive) {
        docLog('Rule Mapping');
        const ruleMapper = new rule_mapper_1.RuleMapper(this.nodeList);
        // add rules to node
        for (const node of this.nodeList) {
            if (node.type === 'ElementCloseTag') {
                continue;
            }
            if (docLog.enabled) {
                docLog('Add rules to node <%s>', 'nodeName' in node ? node.nodeName : `#${node.type}`);
            }
            // global rules
            Object.keys(ruleset.rules).forEach(ruleName => {
                const rule = ruleset.rules[ruleName];
                ruleMapper.set(node, ruleName, {
                    from: 'rules',
                    specificity: [0, 0, 0],
                    rule,
                });
            });
            if (node.type !== 'Element' && node.type !== 'OmittedElement' && node.type !== 'Text') {
                continue;
            }
            const selectorTarget = node.type === 'Element' || node.type === 'OmittedElement' ? node : null;
            // node specs and special rules for node by selector
            ruleset.nodeRules.forEach((nodeRule, i) => {
                if (!nodeRule.rules) {
                    return;
                }
                if (!selectorTarget) {
                    return;
                }
                const selector = nodeRule.selector || nodeRule.regexSelector || nodeRule.tagName;
                const matches = 
                /**
                 * Forward v1.x compatibility
                 */
                nodeRule.tagName && /^#text$/i.test(nodeRule.tagName) && node.type === 'Text'
                    ? {
                        matched: true,
                        selector: '#text',
                        specificity: [0, 0, 0],
                    }
                    : /**
                       * v2.0.0 or later
                       */
                        (0, match_selector_1.matchSelector)(selectorTarget, selector, tagNameCaseSensitive);
                if (!matches.matched) {
                    return;
                }
                if (docLog.enabled) {
                    docLog('Matched nodeRule: <%s>(%s)', 'nodeName' in node ? node.nodeName : node.type, matches.selector || '*');
                }
                const ruleList = Object.keys(nodeRule.rules);
                for (const ruleName of ruleList) {
                    const rule = nodeRule.rules[ruleName];
                    const convertedRule = (0, ml_config_1.exchangeValueOnRule)(rule, matches.data || {});
                    if (convertedRule === undefined) {
                        continue;
                    }
                    const globalRule = ruleset.rules[ruleName];
                    const mergedRule = globalRule ? (0, ml_config_1.mergeRule)(globalRule, convertedRule) : convertedRule;
                    ruleLog('↑ nodeRule (%s): %O', ruleName, mergedRule);
                    ruleMapper.set(node, ruleName, {
                        from: 'nodeRules',
                        specificity: matches.specificity,
                        rule: mergedRule,
                    });
                }
            });
            // overwrite rule to child node
            if (selectorTarget && ruleset.childNodeRules.length) {
                const descendants = [];
                (0, walkers_1.syncWalk)(selectorTarget.childNodes, childNode => {
                    descendants.push(childNode);
                    if (childNode.type === 'Element' && childNode.closeTag) {
                        descendants.push(childNode.closeTag);
                    }
                });
                const children = selectorTarget.childNodes;
                ruleset.childNodeRules.forEach((nodeRule, i) => {
                    if (!nodeRule.rules) {
                        return;
                    }
                    const nodeRuleRules = nodeRule.rules;
                    const selector = nodeRule.selector || nodeRule.tagName || nodeRule.regexSelector;
                    if (!selector) {
                        return;
                    }
                    const matches = (0, match_selector_1.matchSelector)(selectorTarget, selector, tagNameCaseSensitive);
                    if (!matches.matched) {
                        return;
                    }
                    if (docLog.enabled) {
                        docLog('Matched childNodeRule: <%s>(%s), inheritance: %o', selectorTarget.nodeName, matches.selector || '*', !!nodeRule.inheritance);
                    }
                    const targetDescendants = nodeRule.inheritance ? descendants : children;
                    Object.keys(nodeRuleRules).forEach(ruleName => {
                        const rule = nodeRuleRules[ruleName];
                        const convertedRule = (0, ml_config_1.exchangeValueOnRule)(rule, matches.data || {});
                        if (convertedRule === undefined) {
                            return;
                        }
                        const globalRule = ruleset.rules[ruleName];
                        const mergedRule = globalRule ? (0, ml_config_1.mergeRule)(globalRule, convertedRule) : convertedRule;
                        ruleLog('↑ childNodeRule (%s): %O', ruleName, mergedRule);
                        targetDescendants.forEach(descendant => {
                            ruleMapper.set(descendant, ruleName, {
                                from: 'childNodeRules',
                                specificity: matches.specificity,
                                rule: mergedRule,
                            });
                        });
                    });
                });
            }
        }
        ruleMapper.apply();
    }
}
exports.default = MLDOMDocument;
_MLDOMDocument_filename = new WeakMap();
