import type { MLRule } from '../';
import type Ruleset from '../ruleset';
import type { Walker } from './helper/walkers';
import type { MLDOMComment, MLDOMElement, MLDOMElementCloseTag, MLDOMText } from './tokens';
import type { AnonymousNode } from './types';
import type { MLASTDocument } from '@markuplint/ml-ast';
import type { RuleConfigValue } from '@markuplint/ml-config';
import type { ExtendedSpec, MLMLSpec } from '@markuplint/ml-spec';
import { NodeStore } from './helper';
import { MLDOMDoctype } from './tokens';
/**
 * markuplint DOM Document
 */
export default class MLDOMDocument<T extends RuleConfigValue, O = null> {
    #private;
    /**
     * An array of markuplint DOM nodes
     */
    nodeList: ReadonlyArray<AnonymousNode<T, O>>;
    /**
     *
     */
    currentRule: MLRule<T, O> | null;
    /**
     *
     */
    isFragment: boolean;
    /**
     *
     */
    specs: Readonly<MLMLSpec>;
    /**
     *
     */
    readonly endTag: 'xml' | 'omittable' | 'never';
    /**
     *
     */
    readonly nodeStore: NodeStore;
    /**
     * Window object for calling the `getComputedStyle` and the `getPropertyValue` that are needed by **Accessible Name and Description Computation**.
     * But it always returns the empty object.
     * (It may improve to possible to compute the name from the `style` attribute in the future.)
     */
    readonly defaultView: {
        getComputedStyle(_el: MLDOMElement<any, any>): {
            getPropertyValue(_propName: string): {};
        };
    };
    /**
     * It could be used in rule, make sure it is immutable
     */
    get filename(): string | undefined;
    /**
     *
     * @param ast node list of markuplint AST
     * @param ruleset ruleset object
     */
    constructor(ast: MLASTDocument, ruleset: Ruleset, schemas: readonly [MLMLSpec, ...ExtendedSpec[]], options?: {
        filename?: string;
        tagNameCaseSensitive?: boolean;
        endTag?: 'xml' | 'omittable' | 'never';
    });
    get doctype(): MLDOMDoctype<T, O> | null;
    get tree(): AnonymousNode<T, O>[];
    walk(walker: Walker<T, O>): Promise<void>;
    /**
     *
     * @param type
     * @param walker
     * @param skipWhenRuleIsDisabled
     */
    walkOn(type: 'Element', walker: Walker<T, O, MLDOMElement<T, O>>, skipWhenRuleIsDisabled?: boolean): Promise<void>;
    walkOn(type: 'Text', walker: Walker<T, O, MLDOMText<T, O>>, skipWhenRuleIsDisabled?: boolean): Promise<void>;
    walkOn(type: 'Comment', walker: Walker<T, O, MLDOMComment<T, O>>, skipWhenRuleIsDisabled?: boolean): Promise<void>;
    walkOn(type: 'ElementCloseTag', walker: Walker<T, O, MLDOMElementCloseTag<T, O>>, skipWhenRuleIsDisabled?: boolean): Promise<void>;
    setRule(rule: MLRule<T, O> | null): void;
    matchNodes(query: string): MLDOMElement<T, O>[];
    querySelectorAll(query: string): MLDOMElement<T, O>[];
    querySelector(query: string): MLDOMElement<T, O>;
    getElementById(id: string): MLDOMElement<T, O>;
    toString(): string;
    debugMap(): string[];
    private _ruleMapping;
}
