"use strict";
var _Selector_ruleset, _Ruleset_selectorGroup, _StructuredSelector_edge, _StructuredSelector_selector, _SelectorTarget_tagNameCaseSensitive, _SelectorTarget_isAdded, _SelectorTarget_combinatedFrom;
Object.defineProperty(exports, "__esModule", { value: true });
exports.compareSpecificity = exports.createSelector = void 0;
const tslib_1 = require("tslib");
const postcss_selector_parser_1 = tslib_1.__importDefault(require("postcss-selector-parser"));
const debug_1 = require("../../debug");
const log = debug_1.log.extend('selector');
const resLog = log.extend('result');
function createSelector(selector, tagNameCaseSensitive) {
    return new Selector(selector, !!tagNameCaseSensitive);
}
exports.createSelector = createSelector;
function compareSpecificity(a, b) {
    if (a[0] < b[0]) {
        return -1;
    }
    else if (a[0] > b[0]) {
        return 1;
    }
    else if (a[1] < b[1]) {
        return -1;
    }
    else if (a[1] > b[1]) {
        return 1;
    }
    else if (a[2] < b[2]) {
        return -1;
    }
    else if (a[2] > b[2]) {
        return 1;
    }
    return 0;
}
exports.compareSpecificity = compareSpecificity;
class Selector {
    constructor(selector, tagNameCaseSensitive) {
        _Selector_ruleset.set(this, void 0);
        tslib_1.__classPrivateFieldSet(this, _Selector_ruleset, Ruleset.parse(selector, tagNameCaseSensitive), "f");
    }
    match(el, caller = el) {
        const results = tslib_1.__classPrivateFieldGet(this, _Selector_ruleset, "f").match(el, caller);
        for (const result of results) {
            if (result.matched) {
                return result.specificity;
            }
        }
        return false;
    }
}
_Selector_ruleset = new WeakMap();
class Ruleset {
    constructor(selectors, tagNameCaseSensitive) {
        _Ruleset_selectorGroup.set(this, []);
        tslib_1.__classPrivateFieldGet(this, _Ruleset_selectorGroup, "f").push(...selectors.map(selector => new StructuredSelector(selector, tagNameCaseSensitive)));
    }
    static parse(selector, tagNameCaseSensitive) {
        const selectors = [];
        (0, postcss_selector_parser_1.default)(root => {
            selectors.push(...root.nodes);
        }).processSync(selector);
        return new Ruleset(selectors, tagNameCaseSensitive);
    }
    match(el, caller) {
        log('%s', el.raw);
        return tslib_1.__classPrivateFieldGet(this, _Ruleset_selectorGroup, "f").map(selector => {
            const res = selector.match(el, caller);
            resLog('%s => %o', selector.selector, res);
            return res;
        });
    }
}
_Ruleset_selectorGroup = new WeakMap();
class StructuredSelector {
    constructor(selector, tagNameCaseSensitive) {
        _StructuredSelector_edge.set(this, void 0);
        _StructuredSelector_selector.set(this, void 0);
        tslib_1.__classPrivateFieldSet(this, _StructuredSelector_selector, selector, "f");
        tslib_1.__classPrivateFieldSet(this, _StructuredSelector_edge, new SelectorTarget(tagNameCaseSensitive), "f");
        tslib_1.__classPrivateFieldGet(this, _StructuredSelector_selector, "f").nodes.forEach(node => {
            switch (node.type) {
                case 'combinator': {
                    const combinatedTarget = new SelectorTarget(tagNameCaseSensitive);
                    combinatedTarget.from(tslib_1.__classPrivateFieldGet(this, _StructuredSelector_edge, "f"), node);
                    tslib_1.__classPrivateFieldSet(this, _StructuredSelector_edge, combinatedTarget, "f");
                    break;
                }
                case 'root':
                case 'string': {
                    throw new Error(`Unsupported selector: ${selector.toString()}`);
                }
                case 'nesting': {
                    throw new Error(`Unsupported nested selector: ${selector.toString()}`);
                }
                case 'comment': {
                    throw new Error(`Unsupported comment in selector: ${selector.toString()}`);
                }
                default: {
                    tslib_1.__classPrivateFieldGet(this, _StructuredSelector_edge, "f").add(node);
                }
            }
        });
    }
    get selector() {
        return tslib_1.__classPrivateFieldGet(this, _StructuredSelector_selector, "f").nodes.join('');
    }
    match(el, caller) {
        return tslib_1.__classPrivateFieldGet(this, _StructuredSelector_edge, "f").match(el, caller);
    }
}
_StructuredSelector_edge = new WeakMap(), _StructuredSelector_selector = new WeakMap();
class SelectorTarget {
    constructor(tagNameCaseSensitive) {
        this.tag = null;
        this.id = [];
        this.class = [];
        this.attr = [];
        this.pseudo = [];
        _SelectorTarget_tagNameCaseSensitive.set(this, void 0);
        _SelectorTarget_isAdded.set(this, false);
        _SelectorTarget_combinatedFrom.set(this, null);
        tslib_1.__classPrivateFieldSet(this, _SelectorTarget_tagNameCaseSensitive, tagNameCaseSensitive, "f");
    }
    match(el, caller) {
        const unitCheck = this._matchWithoutCombinateChecking(el, caller);
        if (!unitCheck.matched) {
            return unitCheck;
        }
        if (!tslib_1.__classPrivateFieldGet(this, _SelectorTarget_combinatedFrom, "f")) {
            return unitCheck;
        }
        const { target, combinator } = tslib_1.__classPrivateFieldGet(this, _SelectorTarget_combinatedFrom, "f");
        switch (combinator.value) {
            // Descendant combinator
            case ' ': {
                let ancestor = el.getParentElement();
                let matched = false;
                let specificity;
                while (ancestor) {
                    const res = target.match(ancestor, caller);
                    if (!specificity) {
                        specificity = [
                            unitCheck.specificity[0] + res.specificity[0],
                            unitCheck.specificity[1] + res.specificity[1],
                            unitCheck.specificity[2] + res.specificity[2],
                        ];
                    }
                    if (res.matched) {
                        matched = true;
                    }
                    ancestor = ancestor.getParentElement();
                }
                if (!specificity) {
                    const res = target.match(el, caller);
                    specificity = [
                        unitCheck.specificity[0] + res.specificity[0],
                        unitCheck.specificity[1] + res.specificity[1],
                        unitCheck.specificity[2] + res.specificity[2],
                    ];
                }
                return {
                    specificity,
                    matched,
                };
            }
            // Child combinator
            case '>': {
                let matched;
                const specificity = unitCheck.specificity;
                const parentNode = el.getParentElement();
                if (parentNode) {
                    const res = target.match(parentNode, caller);
                    specificity[0] += res.specificity[0];
                    specificity[1] += res.specificity[1];
                    specificity[2] += res.specificity[2];
                    matched = res.matched;
                }
                else {
                    const res = target.match(el, caller);
                    specificity[0] += res.specificity[0];
                    specificity[1] += res.specificity[1];
                    specificity[2] += res.specificity[2];
                    matched = false;
                }
                return {
                    specificity,
                    matched,
                };
            }
            // Next-sibling combinator
            case '+': {
                let matched;
                const specificity = unitCheck.specificity;
                if (el.previousElementSibling) {
                    const res = target.match(el.previousElementSibling, caller);
                    specificity[0] += res.specificity[0];
                    specificity[1] += res.specificity[1];
                    specificity[2] += res.specificity[2];
                    matched = res.matched;
                }
                else {
                    const res = target.match(el, caller);
                    specificity[0] += res.specificity[0];
                    specificity[1] += res.specificity[1];
                    specificity[2] += res.specificity[2];
                    matched = false;
                }
                return {
                    specificity,
                    matched,
                };
            }
            // // Subsequent-sibling combinator
            case '~': {
                let prev = el.previousElementSibling;
                let matched = false;
                let specificity;
                while (prev) {
                    const res = target.match(prev, caller);
                    if (!specificity) {
                        specificity = [
                            unitCheck.specificity[0] + res.specificity[0],
                            unitCheck.specificity[1] + res.specificity[1],
                            unitCheck.specificity[2] + res.specificity[2],
                        ];
                    }
                    if (res.matched) {
                        matched = true;
                    }
                    prev = prev.previousElementSibling;
                }
                if (!specificity) {
                    const res = target.match(el, caller);
                    specificity = [
                        unitCheck.specificity[0] + res.specificity[0],
                        unitCheck.specificity[1] + res.specificity[1],
                        unitCheck.specificity[2] + res.specificity[2],
                    ];
                }
                return {
                    specificity,
                    matched,
                };
            }
            // Column combinator
            case '||': {
                throw new Error('Unsupported column combinator yet. If you want it, please request it as the issue (https://github.com/markuplint/markuplint/issues/new).');
            }
            default: {
                throw new Error(`Unsupported ${tslib_1.__classPrivateFieldGet(this, _SelectorTarget_combinatedFrom, "f").combinator.value} combinator in selector`);
            }
        }
    }
    _matchWithoutCombinateChecking(el, caller) {
        const specificity = [0, 0, 0];
        let matched = true;
        if (!tslib_1.__classPrivateFieldGet(this, _SelectorTarget_isAdded, "f") && !isScope(el, caller)) {
            matched = false;
        }
        if (!this.id.every(id => id.value === el.id)) {
            matched = false;
        }
        specificity[0] += this.id.length;
        if (!this.class.every(className => el.classList.includes(className.value))) {
            matched = false;
        }
        specificity[1] += this.class.length;
        if (!this.attr.every(attr => attrMatch(attr, el))) {
            matched = false;
        }
        specificity[1] += this.attr.length;
        for (const pseudo of this.pseudo) {
            const pseudoRes = pseudoMatch(pseudo, el, caller, tslib_1.__classPrivateFieldGet(this, _SelectorTarget_tagNameCaseSensitive, "f"));
            specificity[0] += pseudoRes.specificity[0];
            specificity[1] += pseudoRes.specificity[1];
            specificity[2] += pseudoRes.specificity[2];
            if (!pseudoRes.matched) {
                matched = false;
            }
        }
        if (this.tag && this.tag.type === 'tag') {
            specificity[2] += 1;
            let a = this.tag.value;
            let b = el.nodeName;
            if (!tslib_1.__classPrivateFieldGet(this, _SelectorTarget_tagNameCaseSensitive, "f")) {
                a = a.toLowerCase();
                b = b.toLowerCase();
            }
            if (a !== b) {
                matched = false;
            }
        }
        return {
            specificity,
            matched,
        };
    }
    add(selector) {
        tslib_1.__classPrivateFieldSet(this, _SelectorTarget_isAdded, true, "f");
        switch (selector.type) {
            case 'tag':
            case 'universal': {
                this.tag = selector;
                break;
            }
            case 'id': {
                this.id.push(selector);
                break;
            }
            case 'class': {
                this.class.push(selector);
                break;
            }
            case 'attribute': {
                this.attr.push(selector);
                break;
            }
            case 'pseudo': {
                this.pseudo.push(selector);
                break;
            }
        }
    }
    from(target, combinator) {
        tslib_1.__classPrivateFieldSet(this, _SelectorTarget_combinatedFrom, { target, combinator }, "f");
    }
}
_SelectorTarget_tagNameCaseSensitive = new WeakMap(), _SelectorTarget_isAdded = new WeakMap(), _SelectorTarget_combinatedFrom = new WeakMap();
function attrMatch(attr, el) {
    return el.attributes.some(attrOfEl => {
        if (attr.attribute !== attrOfEl.getName().potential) {
            return false;
        }
        if (attr.value != null) {
            let value = attr.value;
            let valueOfEl = attrOfEl.getValue().potential;
            if (attr.insensitive) {
                value = value.toLowerCase();
                valueOfEl = valueOfEl.toLowerCase();
            }
            switch (attr.operator) {
                case '=': {
                    if (value !== valueOfEl) {
                        return false;
                    }
                    break;
                }
                case '~=': {
                    if (!valueOfEl.split(/\s+/).includes(value)) {
                        return false;
                    }
                    break;
                }
                case '|=': {
                    if (!new RegExp(`^${value}(?:$|-)`).test(valueOfEl)) {
                        return false;
                    }
                    break;
                }
                case '*=': {
                    if (valueOfEl.indexOf(value) === -1) {
                        return false;
                    }
                    break;
                }
                case '^=': {
                    if (valueOfEl.indexOf(value) !== 0) {
                        return false;
                    }
                    break;
                }
                case '$=': {
                    if (valueOfEl.lastIndexOf(value) !== valueOfEl.length - value.length) {
                        return false;
                    }
                    break;
                }
            }
        }
        return true;
    });
}
function pseudoMatch(pseudo, el, caller, tagNameCaseSensitive) {
    switch (pseudo.value) {
        /**
         * Below, markuplint Specific Selector
         */
        case ':closest': {
            const ruleset = new Ruleset(pseudo.nodes, tagNameCaseSensitive);
            const specificity = getSpecificity(ruleset.match(el, caller));
            let parent = el.getParentElement();
            while (parent) {
                if (ruleset.match(parent, caller).some(r => r.matched)) {
                    return {
                        specificity,
                        matched: true,
                    };
                }
                parent = parent.getParentElement();
            }
            return {
                specificity,
                matched: false,
            };
        }
        /**
         * Below, Selector Level 4
         */
        case ':not': {
            const ruleset = new Ruleset(pseudo.nodes, tagNameCaseSensitive);
            const resList = ruleset.match(el, caller);
            const specificity = getSpecificity(resList);
            const matched = resList.every(r => !r.matched);
            return {
                specificity,
                matched,
            };
        }
        case ':is': {
            const ruleset = new Ruleset(pseudo.nodes, tagNameCaseSensitive);
            const resList = ruleset.match(el, caller);
            const specificity = getSpecificity(resList);
            const matched = resList.some(r => r.matched);
            return {
                specificity,
                matched,
            };
        }
        case ':has': {
            const ruleset = new Ruleset(pseudo.nodes, tagNameCaseSensitive);
            const specificity = getSpecificity(ruleset.match(el, caller));
            const descendants = getDescendants(el);
            const matched = descendants.some(desc => ruleset.match(desc, caller).some(m => m.matched));
            return {
                specificity,
                matched,
            };
        }
        case ':where': {
            const ruleset = new Ruleset(pseudo.nodes, tagNameCaseSensitive);
            const resList = ruleset.match(el, caller);
            const matched = resList.some(r => r.matched);
            return {
                specificity: [0, 0, 0],
                matched,
            };
        }
        case ':scope': {
            if (!isScope(el, caller)) {
                return {
                    specificity: [0, 1, 0],
                    matched: false,
                };
            }
            return {
                specificity: [0, 1, 0],
                matched: true,
            };
        }
        case ':root': {
            if (!(!el.isInFragmentDocument && el.parentNode === null)) {
                return {
                    specificity: [0, 1, 0],
                    matched: false,
                };
            }
            return {
                specificity: [0, 1, 0],
                matched: true,
            };
        }
        case ':enable':
        case ':disable':
        case ':read-write':
        case ':read-only':
        case ':placeholder-shown':
        case ':default':
        case ':checked':
        case ':indeterminate':
        case ':valid':
        case ':invalid':
        case ':in-range':
        case ':out-of-range':
        case ':required':
        case ':optional':
        case ':blank':
        case ':user-invalid':
        case ':empty':
        case ':nth-child':
        case ':nth-last-child':
        case ':first-child':
        case ':last-child':
        case ':only-child':
        case ':nth-of-type':
        case ':nth-last-of-type':
        case ':first-of-type':
        case ':last-of-type':
        case ':only-of-type':
        case ':nth-last-col':
        case ':nth-col': {
            throw new Error(`Unsupported pseudo ${pseudo.toString()} selector yet. If you want it, please request it as the issue (https://github.com/markuplint/markuplint/issues/new).`);
        }
        case ':dir':
        case ':lang':
        case ':any-link':
        case ':link':
        case ':visited':
        case ':local-link':
        case ':target':
        case ':target-within':
        case ':current':
        case ':past':
        case ':future':
        case ':active':
        case ':hover':
        case ':focus':
        case ':focus-within':
        case ':focus-visible':
        case '::before':
        case '::after':
        default: {
            throw new Error(`Unsupported pseudo ${pseudo.toString()} selector.`);
        }
    }
}
function isScope(el, caller) {
    return el.uuid === (caller === null || caller === void 0 ? void 0 : caller.uuid) || (!el.isInFragmentDocument && el.parentNode === null);
}
function getDescendants(el, includeSelf = false) {
    return [...el.children.map(child => getDescendants(child, true)).flat(), ...(includeSelf ? [el] : [])];
}
function getSpecificity(result) {
    let specificity;
    for (const res of result) {
        if (specificity) {
            const order = compareSpecificity(specificity, res.specificity);
            if (order === -1) {
                specificity = res.specificity;
            }
        }
        else {
            specificity = res.specificity;
        }
    }
    if (!specificity) {
        throw new Error('Result is empty');
    }
    return specificity;
}
