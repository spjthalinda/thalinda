"use strict";
var _MLDOMIndentation_node, _MLDOMIndentation_parent, _MLDOMIndentation_fixed;
Object.defineProperty(exports, "__esModule", { value: true });
exports.getIndent = void 0;
const tslib_1 = require("tslib");
/**
 *
 * @deprecated
 * @param node
 */
function getIndent(node) {
    const prevToken = node.prevToken;
    if (!prevToken) {
        return null;
    }
    if (node.type === 'Text') {
        if (node.isRawText) {
            return null;
        }
        const matched = node.raw.match(/^(\s*(?:\r?\n)+\s*)(?:[^\s]+)/);
        if (matched) {
            const spaces = matched[1];
            if (spaces) {
                const spaceLines = spaces.split(/\r?\n/);
                const line = spaceLines.length + node.startLine - 1;
                const lastSpace = spaceLines.pop();
                if (lastSpace != null) {
                    return new MLDOMIndentation(node, lastSpace, line, node);
                }
            }
        }
        return null;
    }
    if (prevToken.type !== 'Text') {
        return null;
    }
    // One or more newlines and zero or more spaces or tabs.
    // Or, If textNode is first token and that is filled spaces, tabs and newlines only.
    const matched = isFirstToken(prevToken)
        ? prevToken.raw.match(/^(?:[ \t]*\r?\n)*([ \t]*)$/)
        : prevToken.raw.match(/\r?\n([ \t]*)$/);
    // console.log({ [`${this}`]: matched, _: prevToken.raw, f: prevToken._isFirstToken() });
    if (matched) {
        // Spaces will include empty string.
        const spaces = matched[1];
        if (spaces != null) {
            return new MLDOMIndentation(prevToken, spaces, node.startLine, node);
        }
    }
    return null;
}
exports.getIndent = getIndent;
class MLDOMIndentation {
    constructor(originTextNode, raw, line, parentNode) {
        _MLDOMIndentation_node.set(this, void 0);
        _MLDOMIndentation_parent.set(this, void 0);
        _MLDOMIndentation_fixed.set(this, void 0);
        this.line = line;
        tslib_1.__classPrivateFieldSet(this, _MLDOMIndentation_node, originTextNode, "f");
        tslib_1.__classPrivateFieldSet(this, _MLDOMIndentation_parent, parentNode, "f");
        tslib_1.__classPrivateFieldSet(this, _MLDOMIndentation_fixed, raw, "f");
    }
    get type() {
        if (tslib_1.__classPrivateFieldGet(this, _MLDOMIndentation_parent, "f").type !== 'Text' && this.line !== tslib_1.__classPrivateFieldGet(this, _MLDOMIndentation_node, "f").endLine) {
            return 'none';
        }
        const raw = tslib_1.__classPrivateFieldGet(this, _MLDOMIndentation_fixed, "f");
        return raw === '' ? 'none' : /^\t+$/.test(raw) ? 'tab' : /^[^\t]+$/.test(raw) ? 'space' : 'mixed';
    }
    get width() {
        if (tslib_1.__classPrivateFieldGet(this, _MLDOMIndentation_parent, "f").type !== 'Text' && this.line !== tslib_1.__classPrivateFieldGet(this, _MLDOMIndentation_node, "f").endLine) {
            return 0;
        }
        return tslib_1.__classPrivateFieldGet(this, _MLDOMIndentation_fixed, "f").length;
    }
    get raw() {
        if (tslib_1.__classPrivateFieldGet(this, _MLDOMIndentation_parent, "f").type !== 'Text' && this.line !== tslib_1.__classPrivateFieldGet(this, _MLDOMIndentation_node, "f").endLine) {
            return '';
        }
        return tslib_1.__classPrivateFieldGet(this, _MLDOMIndentation_fixed, "f");
    }
    fix(raw) {
        const current = tslib_1.__classPrivateFieldGet(this, _MLDOMIndentation_fixed, "f");
        tslib_1.__classPrivateFieldSet(this, _MLDOMIndentation_fixed, raw, "f");
        if (tslib_1.__classPrivateFieldGet(this, _MLDOMIndentation_node, "f")) {
            const node = tslib_1.__classPrivateFieldGet(this, _MLDOMIndentation_node, "f");
            const line = node.startLine;
            const lines = node.raw.split(/\r?\n/);
            const index = this.line - line;
            if (lines[index] != null) {
                lines[index] = lines[index].replace(current, tslib_1.__classPrivateFieldGet(this, _MLDOMIndentation_fixed, "f"));
            }
            node.fix(lines.join('\n'));
        }
    }
}
_MLDOMIndentation_node = new WeakMap(), _MLDOMIndentation_parent = new WeakMap(), _MLDOMIndentation_fixed = new WeakMap();
function isFirstToken(node) {
    return !node.prevToken;
}
