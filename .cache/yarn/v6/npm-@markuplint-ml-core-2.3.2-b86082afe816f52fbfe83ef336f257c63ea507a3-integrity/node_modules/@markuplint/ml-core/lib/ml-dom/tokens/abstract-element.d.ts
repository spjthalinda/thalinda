import type { Document } from '../';
import type { MLDOMAttribute, MLDOMElement, MLDOMOmittedElement, MLDOMText } from './';
import type MLDOMPreprocessorSpecificAttribute from './preprocessor-specific-attribute';
import type { MLASTElement, MLASTOmittedElement } from '@markuplint/ml-ast';
import type { RuleConfigValue } from '@markuplint/ml-config';
import type { ContentModel } from '@markuplint/ml-spec';
import MLDOMNode from './node';
export default abstract class MLDOMAbstractElement<T extends RuleConfigValue, O = null, E extends MLASTElement | MLASTOmittedElement = MLASTElement | MLASTOmittedElement> extends MLDOMNode<T, O, E> {
    #private;
    readonly nodeType = 1;
    readonly nodeName: string;
    readonly attributes: (MLDOMAttribute | MLDOMPreprocessorSpecificAttribute)[];
    readonly hasSpreadAttr: boolean;
    readonly namespaceURI: string;
    readonly isForeignElement: boolean;
    readonly ownModels: Set<ContentModel>;
    readonly childModels: Set<ContentModel>;
    readonly descendantModels: Set<ContentModel>;
    readonly isCustomElement: boolean;
    readonly isInFragmentDocument: boolean;
    constructor(astNode: E, document: Document<T, O>);
    get tagName(): string;
    get children(): (MLDOMElement<T, O> | MLDOMOmittedElement<T, O>)[];
    get nextElementSibling(): MLDOMElement<T, O> | MLDOMOmittedElement<T, O> | null;
    get previousElementSibling(): MLDOMElement<T, O> | MLDOMOmittedElement<T, O> | null;
    get ns(): string;
    get nameWithNS(): string;
    get classList(): string[];
    get id(): string;
    get fixedNodeName(): string;
    get textContent(): string;
    querySelectorAll(selector: string): (MLDOMElement<T, O> | MLDOMText<T, O>)[];
    closest(selector: string): MLDOMAbstractElement<T, O> | null;
    getAttributeToken(attrName: string): (MLDOMAttribute | MLDOMPreprocessorSpecificAttribute)[];
    getAttributeNode(attrName: string): MLDOMAttribute | MLDOMPreprocessorSpecificAttribute;
    getAttribute(attrName: string): string | null;
    hasAttribute(attrName: string): boolean;
    matches(selector: string): boolean;
    fixNodeName(name: string): void;
    getChildElementsAndTextNodeWithoutWhitespaces(): (MLDOMElement<T, O> | MLDOMText<T, O>)[];
    /**
     * This element has "Preprocessor Specific Block". In other words, Its children are potentially mutable.
     */
    hasMutableChildren(attr?: boolean): boolean;
    hasMutableAttributes(): boolean;
    isDescendantByUUIDList(uuidList: string[]): boolean;
    getAccessibleName(): string;
    toNormalizeString(): string;
}
