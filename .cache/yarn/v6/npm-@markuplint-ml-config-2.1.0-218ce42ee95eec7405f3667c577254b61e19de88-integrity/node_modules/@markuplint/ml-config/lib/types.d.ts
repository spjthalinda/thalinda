export interface Config {
    $schema?: string;
    extends?: string | string[];
    plugins?: (PluginConfig | string)[];
    parser?: ParserConfig;
    parserOptions?: ParserOptions;
    specs?: SpecConfig | SpecConfig_v1;
    excludeFiles?: string[];
    rules?: Rules;
    nodeRules?: NodeRule[];
    childNodeRules?: ChildNodeRule[];
    overrides?: Record<string, Omit<Config, '$schema' | 'extends' | 'overrides'>>;
}
export declare type PluginConfig = {
    name: string;
    settings: Record<string, any>;
};
export interface ParserConfig {
    [extensionPattern: string]: string;
}
export declare type ParserOptions = {
    ignoreFrontMatter?: boolean;
};
export declare type SpecConfig = {
    [extensionPattern: string]: string;
};
/**
 * @deprecated
 */
export declare type SpecConfig_v1 = string | string[];
export declare type Rule<T extends RuleConfigValue, O = void> = RuleConfig<T, O> | T | boolean;
export declare type AnyRule = Rule<RuleConfigValue, unknown>;
export interface Rules {
    [ruleName: string]: AnyRule;
}
export declare type RuleConfig<T extends RuleConfigValue, O = void> = {
    severity?: Severity;
    value?: T;
    option?: O;
    reason?: string;
};
export declare type Severity = 'error' | 'warning' | 'info';
export declare type RuleConfigValue = string | number | boolean | any[] | null;
export interface NodeRule {
    /**
     * @deprecated
     */
    tagName?: string;
    selector?: string;
    regexSelector?: RegexSelector;
    categories?: string[];
    roles?: string[];
    obsolete?: boolean;
    rules?: Rules;
}
export interface ChildNodeRule {
    /**
     * @deprecated
     */
    tagName?: string;
    selector?: string;
    regexSelector?: RegexSelector;
    inheritance?: boolean;
    rules?: Rules;
}
export declare type RegexSelector = RegexSelectorWithoutCompination & {
    combination?: {
        combinator: RegexSelectorCombinator;
    } & RegexSelector;
};
export declare type RegexSelectorCombinator = ' ' | '>' | '+' | '~' | ':has(+)' | ':has(~)';
export declare type RegexSelectorWithoutCompination = {
    nodeName?: string;
    attrName?: string;
    attrValue?: string;
};
export declare type Report<T extends RuleConfigValue, O = null> = Report1<T, O> | Report2 | (Report1<T, O> & Report2);
export declare type Report1<T extends RuleConfigValue, O = null> = {
    message: string;
    scope: Scope<T, O>;
};
export declare type Report2 = {
    message: string;
    line: number;
    col: number;
    raw: string;
};
export declare type Scope<T extends RuleConfigValue, O = null> = {
    rule: RuleInfo<T, O>;
    startLine: number;
    startCol: number;
    raw: string;
};
export interface Violation {
    ruleId: string;
    severity: Severity;
    message: string;
    reason?: string;
    line: number;
    col: number;
    raw: string;
}
export interface RuleInfo<T extends RuleConfigValue, O = null> {
    disabled: boolean;
    severity: Severity;
    value: T;
    option: O;
    reason?: string;
}
export declare type GlobalRuleInfo<T extends RuleConfigValue, O = null> = RuleInfo<T, O> & {
    nodeRules: RuleInfo<T, O>[];
    childNodeRules: RuleInfo<T, O>[];
};
export declare type Nullable<T> = T | null | undefined;
