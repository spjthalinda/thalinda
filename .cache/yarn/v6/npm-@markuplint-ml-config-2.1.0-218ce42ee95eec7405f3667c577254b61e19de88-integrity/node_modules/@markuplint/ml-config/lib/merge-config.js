"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeRule = exports.mergeConfig = void 0;
const tslib_1 = require("tslib");
const deepmerge_1 = tslib_1.__importDefault(require("deepmerge"));
const is_plain_object_1 = require("is-plain-object");
function mergeConfig(a, b) {
    const config = {
        ...a,
        ...b,
        plugins: concatArray(a.plugins, b.plugins, true, 'name'),
        parser: mergeObject(a.parser, b.parser),
        parserOptions: mergeObject(a.parserOptions, b.parserOptions),
        specs: 
        // v3
        // mergeObject(a.specs, b.specs),
        // v2
        mergeSpecs(a.specs, b.specs),
        excludeFiles: concatArray(a.excludeFiles, b.excludeFiles, true),
        rules: mergeRules(
        // TODO: Deep merge
        a.rules, b.rules),
        nodeRules: concatArray(a.nodeRules, b.nodeRules),
        childNodeRules: concatArray(a.childNodeRules, b.childNodeRules),
        overrides: mergeObject(a.overrides, b.overrides),
        // delete all
        extends: undefined,
    };
    deleteUndefProp(config);
    return config;
}
exports.mergeConfig = mergeConfig;
function mergeRule(a, b) {
    // Particular behavior:
    //
    // If the right-side value is false, return false.
    // In short; The `false` makes the rule to be disabled absolutely.
    if (b === false || (!isRuleConfigValue(b) && b.value === false)) {
        return false;
    }
    if (a === undefined) {
        return b;
    }
    if (isRuleConfigValue(b)) {
        if (isRuleConfigValue(a)) {
            if (Array.isArray(a) && Array.isArray(b)) {
                return [...a, ...b];
            }
            return b;
        }
        const value = Array.isArray(a.value) && Array.isArray(b) ? [...a.value, b] : b;
        const res = {
            ...a,
            value,
        };
        deleteUndefProp(res);
        return res;
    }
    const severity = b.severity || (!isRuleConfigValue(a) ? a.severity : undefined);
    const value = b.value || (isRuleConfigValue(a) ? a : a.value);
    const option = mergeObject(!isRuleConfigValue(a) ? a.option : undefined, b.option);
    const reason = b.reason || (!isRuleConfigValue(a) ? a.reason : undefined);
    const res = {
        severity,
        value,
        option,
        reason,
    };
    deleteUndefProp(res);
    return res;
}
exports.mergeRule = mergeRule;
function mergeObject(a, b) {
    if (a == null) {
        return b || undefined;
    }
    if (b == null) {
        return a || undefined;
    }
    const res = (0, deepmerge_1.default)(a, b);
    deleteUndefProp(res);
    return res;
}
function concatArray(a, b, uniquely = false, comparePropName) {
    const newArray = [];
    function concat(item) {
        if (!uniquely) {
            newArray.push(item);
            return;
        }
        if (newArray.includes(item)) {
            return;
        }
        if (!comparePropName) {
            newArray.push(item);
            return;
        }
        const name = getName(item, comparePropName);
        if (!name) {
            newArray.push(item);
            return;
        }
        const existedIndex = newArray.findIndex(e => getName(e, comparePropName) === name);
        if (existedIndex === -1) {
            newArray.push(item);
            return;
        }
        if (typeof item === 'string') {
            return;
        }
        const existed = newArray[existedIndex];
        const merged = mergeObject(existed, item);
        if (!merged) {
            newArray.push(item);
            return;
        }
        newArray.splice(existedIndex, 1, merged);
    }
    a === null || a === void 0 ? void 0 : a.forEach(concat);
    b === null || b === void 0 ? void 0 : b.forEach(concat);
    return newArray.length === 0 ? undefined : newArray;
}
function getName(item, comparePropName) {
    if (item == null) {
        return null;
    }
    if (typeof item === 'string') {
        return item;
    }
    if (typeof item === 'object' && item && comparePropName in item && typeof item[comparePropName] === 'string') {
        return item[comparePropName];
    }
    return null;
}
function mergeRules(a, b) {
    if (a == null) {
        return b || undefined;
    }
    if (b == null) {
        return a || undefined;
    }
    const res = { ...a };
    for (const [key, rule] of Object.entries(b)) {
        const merged = mergeRule(res[key], rule);
        if (merged != null) {
            res[key] = merged;
        }
    }
    deleteUndefProp(res);
    return res;
}
function isRuleConfigValue(v) {
    switch (typeof v) {
        case 'string':
        case 'number':
        case 'boolean': {
            return true;
        }
    }
    if (v === null) {
        return true;
    }
    return Array.isArray(v);
}
function deleteUndefProp(obj) {
    if (!(0, is_plain_object_1.isPlainObject)(obj)) {
        return;
    }
    for (const key in obj) {
        if (obj[key] === undefined) {
            delete obj[key];
        }
    }
}
/**
 * @deprecated
 * @param a
 * @param b
 * @returns
 */
function mergeSpecs(a, b) {
    return mergeObject(convertSpec_v1_to_v2(a), convertSpec_v1_to_v2(b));
}
/**
 * @deprecated
 * @param spec
 * @returns
 */
function convertSpec_v1_to_v2(spec) {
    if (spec == null) {
        return;
    }
    if (typeof spec === 'string') {
        return { '/.+/': spec };
    }
    if (Array.isArray(spec)) {
        if (spec.length === 0) {
            return {};
        }
        else if (spec.length === 1) {
            return { '/.+/': spec[0] };
        }
        const res = {};
        for (const item of spec) {
            switch (item) {
                case '@markuplint/vue-spec': {
                    res['/\\.vue$/i'] = item;
                    break;
                }
                case '@markuplint/react-spec': {
                    res['/\\.[jt]sx?$/i'] = item;
                    break;
                }
                default: {
                    res['/.+/'] = item;
                }
            }
        }
        deleteUndefProp(res);
        return res;
    }
    return spec;
}
