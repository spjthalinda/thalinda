"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.exchangeValueOnRule = exports.provideValue = exports.regexSelectorMatches = exports.toRegxp = void 0;
const tslib_1 = require("tslib");
const mustache_1 = tslib_1.__importDefault(require("mustache"));
function toRegxp(pattern) {
    const matched = pattern.match(/^\/(.+)\/([ig]*)$/i);
    if (matched) {
        return new RegExp(matched[1], matched[2]);
    }
    return pattern;
}
exports.toRegxp = toRegxp;
function regexSelectorMatches(reg, raw) {
    const res = {};
    const pattern = toRegxp(reg);
    const regex = pattern instanceof RegExp ? pattern : new RegExp(`^${pattern.trim()}$`);
    const matched = regex.exec(raw);
    if (!matched) {
        return null;
    }
    matched.forEach((val, i) => (res[`$${i}`] = val));
    return {
        ...res,
        ...matched.groups,
    };
}
exports.regexSelectorMatches = regexSelectorMatches;
/**
 * Return undefined if the template doesn't include the variable that is set as a property in data.
 * But return template string without changes if it doesn't have a variable.
 *
 * @param template Mustache template string
 * @param data Captured string for replacement
 */
function provideValue(template, data) {
    const ast = mustache_1.default.parse(template);
    if (ast.length === 1 && ast[0][0] === 'text') {
        // It doesn't have a variable
        return template;
    }
    const noDataResult = mustache_1.default.render(template, {});
    const result = mustache_1.default.render(template, data);
    // Assume variables are empty in the template if it matched.
    if (noDataResult === result) {
        return;
    }
    return result;
}
exports.provideValue = provideValue;
function exchangeValueOnRule(rule, data) {
    if (rule != null && typeof rule === 'object' && !Array.isArray(rule)) {
        if (rule.value != null) {
            rule = {
                ...rule,
                value: exchangeValue(rule.value, data),
            };
        }
        if (rule.option) {
            rule = {
                ...rule,
                option: exchangeOption(rule.option, data),
            };
        }
        if (rule.reason != null) {
            const exchangedValue = exchangeValue(rule.reason, data);
            rule = {
                ...rule,
                reason: exchangedValue ? `${exchangedValue}` : undefined,
            };
        }
        return rule;
    }
    return exchangeValue(rule, data);
}
exports.exchangeValueOnRule = exchangeValueOnRule;
function exchangeValue(rule, data) {
    if (rule == null) {
        return rule;
    }
    if (typeof rule === 'string') {
        return provideValue(rule, data);
    }
    if (Array.isArray(rule)) {
        const ruleArray = rule
            .map(val => {
            if (typeof val === 'string') {
                return provideValue(val, data);
            }
            return val;
        })
            .filter(item => item !== undefined);
        return ruleArray.length ? ruleArray : undefined;
    }
    return rule;
}
function exchangeOption(optionValue, data) {
    if (optionValue == null) {
        return optionValue;
    }
    if (typeof optionValue === 'boolean' || typeof optionValue === 'number') {
        return optionValue;
    }
    if (typeof optionValue === 'string') {
        return provideValue(optionValue, data);
    }
    if (Array.isArray(optionValue)) {
        return optionValue.map(v => exchangeOption(v, data));
    }
    const result = {};
    Object.keys(optionValue).forEach(key => {
        result[key] = exchangeOption(optionValue[key], data);
    });
    return result;
}
