import type { UnmatchedResult } from '..';
import type { Expect, Result, List } from '../types';
import { Token } from './token';
declare type TokenCollectionOptions = Partial<Omit<List, 'token'> & {
    speificSeparator: string | string[];
}>;
export declare type TokenEachCheck = (head: Token | null, tail: TokenCollection) => Result | void;
export declare class TokenCollection extends Array<Token> {
    private static _new;
    static fromPatterns(value: Token | string, patterns: RegExp[], typeOptions?: Omit<TokenCollectionOptions, 'speificSeparator'> & {
        repeat?: boolean;
    }): TokenCollection;
    static get [Symbol.species](): ArrayConstructor;
    readonly disallowToSurroundBySpaces: NonNullable<List['disallowToSurroundBySpaces']>;
    readonly allowEmpty: NonNullable<List['allowEmpty']>;
    readonly ordered: NonNullable<List['ordered']>;
    readonly unique: NonNullable<List['unique']>;
    readonly caseInsensitive: NonNullable<List['caseInsensitive']>;
    readonly number: List['number'];
    readonly separator: NonNullable<List['separator']>;
    constructor(value?: string, typeOptions?: TokenCollectionOptions);
    constructor(value?: number);
    get value(): string;
    filter(callback: (value: Token, index: number, array: Token[]) => boolean): TokenCollection;
    headAndTail(): {
        head: Token | null;
        tail: TokenCollection;
    };
    getIdentTokens(): TokenCollection;
    compareTokens(callback: (prev: Token, current: Token) => Token | null | void): Token | null | undefined;
    /**
     *
     * @param value The token value or the token type or its list
     */
    has(value: string | RegExp | number | (string | RegExp | number)[]): boolean;
    /**
     *
     * @param value The token value or the token type or its list
     */
    search(value: string | RegExp | number | (string | RegExp | number)[]): Token | null;
    check(options?: {
        expects?: Expect[];
        ref?: string;
        cache?: boolean;
    }): import("..").MatchedResult | UnmatchedResult;
    getConsecutiveToken(tokenType: number): Token | null;
    takeTurns(tokenNumbers: ReadonlyArray<number>, lastTokenNumber?: number): {
        unexpectedLastToken: boolean;
        expectedTokenNumber: number;
        token: Token;
    } | null;
    eachCheck(...callbacks: TokenEachCheck[]): Result;
    getDuplicated(): Token | null;
    divide(position: number): readonly [TokenCollection, TokenCollection];
    chunk(split: number): TokenCollection[];
    toJSON(): {
        type: number;
        value: string;
        offset: number;
    }[];
}
export {};
