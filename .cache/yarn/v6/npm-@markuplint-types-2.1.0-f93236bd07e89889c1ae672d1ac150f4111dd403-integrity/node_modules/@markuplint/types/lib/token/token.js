"use strict";
var _Token_originalValue;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Token = void 0;
const tslib_1 = require("tslib");
class Token {
    constructor(value, offset, originalValue, separators) {
        _Token_originalValue.set(this, void 0);
        this.type = Token.getType(value, separators);
        this.value = value;
        this.offset = offset;
        tslib_1.__classPrivateFieldSet(this, _Token_originalValue, originalValue, "f");
    }
    static getType(value, separators) {
        if (Token.whitespace.includes(value[0])) {
            return Token.WhiteSpace;
        }
        if (separators === null || separators === void 0 ? void 0 : separators.includes(value[0])) {
            switch (value[0]) {
                case ',':
                    return Token.Comma;
            }
        }
        return Token.Ident;
    }
    static getLine(value, offset) {
        return value.slice(0, offset).split(/\n/g).length;
    }
    static getCol(value, offset) {
        const lines = value.slice(0, offset).split(/\n/g);
        return lines[lines.length - 1].length + 1;
    }
    static shiftLocation(token, offset) {
        const shifted = token.offset + offset;
        return {
            offset: shifted,
            line: Token.getLine(tslib_1.__classPrivateFieldGet(token, _Token_originalValue, "f"), shifted),
            column: Token.getCol(tslib_1.__classPrivateFieldGet(token, _Token_originalValue, "f"), shifted),
        };
    }
    get length() {
        return this.value.length;
    }
    get origin() {
        return tslib_1.__classPrivateFieldGet(this, _Token_originalValue, "f");
    }
    unmatched(options) {
        var _a;
        return {
            ...options,
            matched: false,
            ref: (options === null || options === void 0 ? void 0 : options.ref) || null,
            raw: this.value,
            offset: this.offset,
            length: this.value.length,
            line: Token.getLine(tslib_1.__classPrivateFieldGet(this, _Token_originalValue, "f"), this.offset),
            column: Token.getCol(tslib_1.__classPrivateFieldGet(this, _Token_originalValue, "f"), this.offset),
            reason: (_a = options === null || options === void 0 ? void 0 : options.reason) !== null && _a !== void 0 ? _a : 'syntax-error',
        };
    }
    /**
     *
     * @param value The token value or the token type or its list
     */
    match(value, caseInsensitive) {
        if (Array.isArray(value)) {
            return value.some(v => this.match(v));
        }
        if (typeof value === 'string') {
            const a = caseInsensitive ? this.value.toLowerCase() : this.value;
            const b = caseInsensitive ? value.toLowerCase() : value;
            return a === b;
        }
        if (value instanceof RegExp) {
            const pattern = new RegExp(value, caseInsensitive ? 'i' : '');
            return pattern.test(this.value);
        }
        return this.type === value;
    }
    /**
     *
     * @param value The token value or the token type or its list
     */
    includes(value, caseInsensitive) {
        if (Array.isArray(value)) {
            return value.some(v => this.includes(v));
        }
        if (typeof value === 'string') {
            const a = caseInsensitive ? this.value.toLowerCase() : this.value;
            const b = caseInsensitive ? value.toLowerCase() : value;
            return a.indexOf(b) !== -1;
        }
        if (value instanceof RegExp) {
            const pattern = new RegExp(value, caseInsensitive ? 'i' : '');
            return pattern.test(this.value);
        }
        return this.type === value;
    }
    toNumber() {
        return parseFloat(this.value);
    }
    toJSON() {
        return {
            type: this.type,
            value: this.value,
            offset: this.offset,
        };
    }
}
exports.Token = Token;
_Token_originalValue = new WeakMap();
/**
 * ASCII whitespace is
 * - U+0009 TAB
 * - U+000A LF
 * - U+000C FF
 * - U+000D CR
 * - U+0020 SPACE.
 *
 * @see https://infra.spec.whatwg.org/#ascii-whitespace
 */
Token.whitespace = ['\u0009', '\u000A', '\u000C', '\u000D', '\u0020'];
/**
 * @see https://github.com/csstree/csstree/blob/master/lib/tokenizer/types.js
 */
Token.Ident = 1;
Token.WhiteSpace = 13;
Token.Comma = 18;
