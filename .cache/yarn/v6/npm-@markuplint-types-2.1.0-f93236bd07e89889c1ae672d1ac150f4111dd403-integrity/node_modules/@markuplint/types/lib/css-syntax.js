"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cssSyntaxMatch = void 0;
const tslib_1 = require("tslib");
// @ts-ignore
const css_tree_1 = tslib_1.__importDefault(require("css-tree"));
// @ts-ignore
const error_js_1 = require("css-tree/lib/lexer/error.js");
// @ts-ignore
const match_js_1 = require("css-tree/lib/lexer/match.js");
// @ts-ignore
const prepare_tokens_js_1 = tslib_1.__importDefault(require("css-tree/lib/lexer/prepare-tokens.js"));
const debug_1 = require("./debug");
const defs_1 = require("./defs");
const match_result_1 = require("./match-result");
function cssSyntaxMatch(value, type) {
    (0, debug_1.log)('Search CSS Syntax: "%s"', type);
    const origin = value;
    let defName;
    const typesExtended = {};
    const typesCheckers = {};
    let propsExtended;
    let ref = undefined;
    let caseSensitive = false;
    let ebnf = null;
    if (typeof type === 'string') {
        defName = type;
        propsExtended = {};
    }
    else {
        defName = type.syntax.apply;
        ebnf = type.syntax.ebnf || null;
        if (ebnf) {
            // Work in progress
            return (0, match_result_1.matched)();
        }
        const types = {
            ...defs_1.tokenizers,
            ...type.syntax.def,
        };
        Object.keys(types).forEach(key => {
            const valueOrChecker = types[key];
            if (typeof valueOrChecker === 'string') {
                typesExtended[key] = valueOrChecker;
            }
            else {
                typesCheckers[key] = valueOrChecker;
            }
        });
        propsExtended = { ...type.syntax.properties };
        if (type.caseSensitive) {
            caseSensitive = true;
            Object.keys(typesExtended).forEach(key => eachMimicCases(key, typesExtended));
            Object.keys(propsExtended).forEach(key => eachMimicCases(key, propsExtended));
            value = mimicCases(value);
        }
        ref = type.ref;
    }
    // @ts-ignore
    const lexer = css_tree_1.default.fork({
        types: typesExtended,
        properties: propsExtended,
    }).lexer;
    Object.keys(typesCheckers).forEach(key => {
        const checker = typesCheckers[key];
        lexer.addType_(key, (token, getNextToken) => checker(token, getNextToken, cssSyntaxMatch));
    });
    const { isProp, name, matcher } = defToMatcher(lexer, defName);
    const refParam = isProp ? 'Property' : 'Type';
    ref = ref || `https://csstree.github.io/docs/syntax/#${refParam}:${name}`;
    // eslint-disable-next-line no-console
    const _w = console.warn;
    if (debug_1.log.enabled) {
        // eslint-disable-next-line no-console
        console.warn = warn => (0, debug_1.log)('WARNING: %s (by %s => %s)', warn, value, type);
    }
    const tokens = (0, prepare_tokens_js_1.default)(value, lexer.syntax);
    const result = (0, match_js_1.matchAsTree)(tokens, matcher.match, lexer);
    if (caseSensitive) {
        if (result.tokens && Array.isArray(result.tokens)) {
            let reducer = 0;
            result.tokens = result.tokens.map((token) => {
                const value = token.value;
                const originValue = deMimicCases(value || '');
                const isMimiced = value !== originValue;
                reducer += isMimiced ? 'mimiccases------mimiccases'.length : 0;
                token.value = originValue;
                token.balance = token.balance - reducer;
                return token;
            });
        }
    }
    (0, debug_1.log)('css-tree/result: %O', result);
    // eslint-disable-next-line no-console
    console.warn = _w;
    if (result.match) {
        if (debug_1.log.enabled) {
            (0, debug_1.log)('css-tree/result.match: %s', JSON.stringify(result.match, null, 2));
        }
        return (0, match_result_1.matched)();
    }
    const error = new error_js_1.SyntaxMatchError(result.reason, matcher.syntax, value, result);
    if (caseSensitive) {
        error.message = deMimicCases(error.message);
        error.syntax = deMimicCases(error.syntax);
    }
    (0, debug_1.log)('css-tree/SyntaxMatchError: %O', error);
    return {
        matched: false,
        ref,
        raw: origin.slice(error.mismatchOffset, error.mismatchOffset + error.mismatchLength),
        offset: error.mismatchOffset,
        length: error.mismatchLength,
        line: error.line,
        column: error.column,
        expects: [
            {
                type: 'syntax',
                value: error.syntax,
            },
        ],
        partName: error.mismatchOffset === 0 ? undefined : 'value',
        reason: 'syntax-error',
    };
}
exports.cssSyntaxMatch = cssSyntaxMatch;
function defToMatcher(lexer, def) {
    const isProp = def.search("<'") === 0;
    const name = def.replace(/^<'?|'?>$/g, '');
    const matcher = isProp ? lexer.properties[name] : lexer.types[name];
    if (!matcher) {
        (0, debug_1.log)('"%s" CSS syntax not found', def);
        throw new Error('MARKUPLINT_TYPE_NO_EXIST');
    }
    return {
        isProp,
        name,
        matcher,
    };
}
function eachMimicCases(key, obj) {
    const value = obj[key];
    obj[key] = mimicCases(value);
}
function mimicCases(value) {
    return value.replace(/[A-Z]/g, $0 => `mimiccases---${$0}---mimiccases`);
}
function deMimicCases(value) {
    return value.replace(/mimiccases---([A-Z])---mimiccases/g, (_, $1) => $1);
}
