"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkKeywordType = void 0;
const check_1 = require("./check");
const css_syntax_1 = require("./css-syntax");
const debug_1 = require("./debug");
const defs_1 = require("./defs");
const match_result_1 = require("./match-result");
const resultCache = new Map();
const CACHE_KEY_PREFIX = '@markuplint/types/checkKeywordType/cache:::';
function checkKeywordType(value, type, cache = true) {
    const key = `${CACHE_KEY_PREFIX}${value}${type}`;
    if (cache) {
        const cachedResult = resultCache.get(key);
        if (cachedResult) {
            (0, debug_1.log)('Restore cache: %s / %s', value, type);
            return cachedResult;
        }
    }
    const result = _checkKeywordType(value, type);
    if (cache) {
        resultCache.set(key, result);
        if (debug_1.log.enabled) {
            (0, debug_1.log)('Cache checking: %O', {
                input: value,
                type,
                key,
                result: result,
            });
        }
    }
    return result;
}
exports.checkKeywordType = checkKeywordType;
function _checkKeywordType(value, type) {
    const def = defs_1.types[type];
    if (!def) {
        (0, debug_1.log)('The "%s" type is not defined in custom type identifier markuplint specified', type);
        try {
            return (0, css_syntax_1.cssSyntaxMatch)(value, type);
        }
        catch (e) {
            if (e instanceof Error && e.message === 'MARKUPLINT_TYPE_NO_EXIST') {
                (0, debug_1.log)("Allow all of any value because the type doesn't exist");
                return (0, match_result_1.matched)();
            }
            throw e;
        }
    }
    const matches = (0, check_1.isCSSSyntax)(def) ? (0, css_syntax_1.cssSyntaxMatch)(value, def) : def.is(value);
    if (!matches.matched) {
        return {
            ...matches,
            ref: matches.ref || def.ref,
            expects: matches.expects || def.expects,
        };
    }
    return matches;
}
