"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkNormalizedLocalDateAndTimeString = exports.checkLocalDateAndTimeString = void 0;
const debug_1 = require("../../debug");
const token_1 = require("../../token");
const datetime_tokens_1 = require("./datetime-tokens");
/**
 * @see https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#valid-local-date-and-time-string
 */
const checkLocalDateAndTimeString = () => function checkLocalDateAndTimeString(value) {
    (0, debug_1.log)('CHECK: local-date-and-time-string');
    const tokens = token_1.TokenCollection.fromPatterns(value, [
        // YYYY
        /[^-]*/,
        // -
        /[^0-9]?/,
        // MM
        /[^-]*/,
        // -
        /[^0-9]?/,
        // DD
        /[^T\s]*/,
        // T
        /[^0-9]?/,
        // hh
        /[^:]*/,
        // :
        /[^0-9]?/,
        // mm
        /[^:]*/,
        // :
        /[^0-9]?/,
        // ss
        /[^.]*/,
        // .
        /[^0-9]?/,
        // sss
        /.[0-9]*/,
    ]);
    (0, debug_1.log)('Local Date and Time: "%s" => %O', tokens.value, tokens);
    const res = tokens.eachCheck(datetime_tokens_1.datetimeTokenCheck.year, datetime_tokens_1.datetimeTokenCheck.hyphen, datetime_tokens_1.datetimeTokenCheck.month, datetime_tokens_1.datetimeTokenCheck.hyphen, datetime_tokens_1.datetimeTokenCheck.date, datetime_tokens_1.datetimeTokenCheck.localDateTimeSeparator, datetime_tokens_1.datetimeTokenCheck.hour, datetime_tokens_1.datetimeTokenCheck.coron, datetime_tokens_1.datetimeTokenCheck.minute, datetime_tokens_1.datetimeTokenCheck.coronOrEnd, datetime_tokens_1.datetimeTokenCheck.second, datetime_tokens_1.datetimeTokenCheck.decimalPointOrEnd, datetime_tokens_1.datetimeTokenCheck.secondFractionalPart, datetime_tokens_1.datetimeTokenCheck.extra);
    if (!res.matched) {
        (0, debug_1.log)('Failed: %O', res);
    }
    return res;
};
exports.checkLocalDateAndTimeString = checkLocalDateAndTimeString;
/**
 * @see https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#valid-normalised-local-date-and-time-string
 */
const checkNormalizedLocalDateAndTimeString = () => function checkNormalizedLocalDateAndTimeString(value) {
    (0, debug_1.log)('CHECK: normalized-local-date-and-time-string');
    const tokens = token_1.TokenCollection.fromPatterns(value, [
        // YYYY
        /[^-]*/,
        // -
        /[^0-9]?/,
        // MM
        /[^-]*/,
        // -
        /[^0-9]?/,
        // DD
        /[^T]*/,
        // T
        /[^0-9]?/,
        // hh
        /[^:]*/,
        // :
        /[^0-9]?/,
        // mm
        /[^:]*/,
        // :
        /[^0-9]?/,
        // ss
        /[^.]*/,
        // .
        /[^0-9]?/,
        // sss
        /.[0-9]*/,
    ]);
    (0, debug_1.log)('Normalized Local Date and Time: "%s" => %O', tokens.value, tokens);
    const res = tokens.eachCheck(datetime_tokens_1.datetimeTokenCheck.year, datetime_tokens_1.datetimeTokenCheck.hyphen, datetime_tokens_1.datetimeTokenCheck.month, datetime_tokens_1.datetimeTokenCheck.hyphen, datetime_tokens_1.datetimeTokenCheck.date, datetime_tokens_1.datetimeTokenCheck.normalizedlocalDateTimeSeparator, datetime_tokens_1.datetimeTokenCheck.hour, datetime_tokens_1.datetimeTokenCheck.coron, datetime_tokens_1.datetimeTokenCheck.minute, datetime_tokens_1.datetimeTokenCheck.coronOrEnd, datetime_tokens_1.datetimeTokenCheck.second, datetime_tokens_1.datetimeTokenCheck.decimalPointOrEnd, datetime_tokens_1.datetimeTokenCheck.secondFractionalPart, datetime_tokens_1.datetimeTokenCheck.extra);
    if (!res.matched) {
        (0, debug_1.log)('Failed: %O', res);
        return res;
    }
    /**
     * > A valid time string representing the time,
     * > expressed as the shortest possible string for the given time
     * > (e.g. omitting the seconds component entirely
     * > if the given time is zero seconds past the minute)
     */
    const [, , , , , , , , , , second, , fp] = tokens;
    const _second = second.toNumber() || 0;
    const _fp = fp.toNumber() || 0;
    (0, debug_1.log)('Omitting the seconds component: "%s.%s" => %d, %d', second === null || second === void 0 ? void 0 : second.value, fp === null || fp === void 0 ? void 0 : fp.value, _second, _fp);
    if (second.value && _second === 0 && (!fp.value || (fp.value && _fp === 0))) {
        const res = second.unmatched({
            partName: 'second',
            reason: 'extra-token',
        });
        (0, debug_1.log)('Failed: %O', res);
        return res;
    }
    if (fp.value && _fp === 0) {
        const res = fp.unmatched({
            partName: 'fractional part',
            reason: 'extra-token',
        });
        (0, debug_1.log)('Failed: %O', res);
        return res;
    }
    (0, debug_1.log)('Failed: %O', res);
    return res;
};
exports.checkNormalizedLocalDateAndTimeString = checkNormalizedLocalDateAndTimeString;
