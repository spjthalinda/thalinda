{
  "manifest": {
    "name": "@noble/curves",
    "version": "1.2.0",
    "description": "Audited & minimal JS implementation of elliptic curve cryptography",
    "files": [
      "abstract",
      "esm",
      "src",
      "*.js",
      "*.js.map",
      "*.d.ts",
      "*.d.ts.map"
    ],
    "scripts": {
      "bench": "cd benchmark; node secp256k1.js; node curves.js; node ecdh.js; node hash-to-curve.js; node modular.js; node bls.js; node ristretto255.js; node decaf448.js",
      "build": "tsc && tsc -p tsconfig.esm.json",
      "build:release": "rollup -c rollup.config.js",
      "build:clean": "rm *.{js,d.ts,d.ts.map,js.map} esm/*.{js,d.ts,d.ts.map,js.map} 2> /dev/null",
      "lint": "prettier --check 'src/**/*.{js,ts}' 'test/*.js'",
      "format": "prettier --write 'src/**/*.{js,ts}' 'test/*.js'",
      "test": "node test/index.test.js"
    },
    "author": {
      "name": "Paul Miller",
      "url": "https://paulmillr.com"
    },
    "homepage": "https://paulmillr.com/noble/",
    "repository": {
      "type": "git",
      "url": "https://github.com/paulmillr/noble-curves.git"
    },
    "license": "MIT",
    "dependencies": {
      "@noble/hashes": "1.3.2"
    },
    "devDependencies": {
      "fast-check": "3.0.0",
      "micro-bmark": "0.3.1",
      "micro-should": "0.4.0",
      "prettier": "2.8.4",
      "typescript": "5.0.2"
    },
    "sideEffects": false,
    "main": "index.js",
    "exports": {
      ".": {
        "types": "./index.d.ts",
        "import": "./esm/index.js",
        "default": "./index.js"
      },
      "./abstract/edwards": {
        "types": "./abstract/edwards.d.ts",
        "import": "./esm/abstract/edwards.js",
        "default": "./abstract/edwards.js"
      },
      "./abstract/modular": {
        "types": "./abstract/modular.d.ts",
        "import": "./esm/abstract/modular.js",
        "default": "./abstract/modular.js"
      },
      "./abstract/montgomery": {
        "types": "./abstract/montgomery.d.ts",
        "import": "./esm/abstract/montgomery.js",
        "default": "./abstract/montgomery.js"
      },
      "./abstract/weierstrass": {
        "types": "./abstract/weierstrass.d.ts",
        "import": "./esm/abstract/weierstrass.js",
        "default": "./abstract/weierstrass.js"
      },
      "./abstract/bls": {
        "types": "./abstract/bls.d.ts",
        "import": "./esm/abstract/bls.js",
        "default": "./abstract/bls.js"
      },
      "./abstract/hash-to-curve": {
        "types": "./abstract/hash-to-curve.d.ts",
        "import": "./esm/abstract/hash-to-curve.js",
        "default": "./abstract/hash-to-curve.js"
      },
      "./abstract/curve": {
        "types": "./abstract/curve.d.ts",
        "import": "./esm/abstract/curve.js",
        "default": "./abstract/curve.js"
      },
      "./abstract/utils": {
        "types": "./abstract/utils.d.ts",
        "import": "./esm/abstract/utils.js",
        "default": "./abstract/utils.js"
      },
      "./abstract/poseidon": {
        "types": "./abstract/poseidon.d.ts",
        "import": "./esm/abstract/poseidon.js",
        "default": "./abstract/poseidon.js"
      },
      "./_shortw_utils": {
        "types": "./_shortw_utils.d.ts",
        "import": "./esm/_shortw_utils.js",
        "default": "./_shortw_utils.js"
      },
      "./bls12-381": {
        "types": "./bls12-381.d.ts",
        "import": "./esm/bls12-381.js",
        "default": "./bls12-381.js"
      },
      "./bn254": {
        "types": "./bn254.d.ts",
        "import": "./esm/bn254.js",
        "default": "./bn254.js"
      },
      "./ed25519": {
        "types": "./ed25519.d.ts",
        "import": "./esm/ed25519.js",
        "default": "./ed25519.js"
      },
      "./ed448": {
        "types": "./ed448.d.ts",
        "import": "./esm/ed448.js",
        "default": "./ed448.js"
      },
      "./index": {
        "types": "./index.d.ts",
        "import": "./esm/index.js",
        "default": "./index.js"
      },
      "./jubjub": {
        "types": "./jubjub.d.ts",
        "import": "./esm/jubjub.js",
        "default": "./jubjub.js"
      },
      "./p256": {
        "types": "./p256.d.ts",
        "import": "./esm/p256.js",
        "default": "./p256.js"
      },
      "./p384": {
        "types": "./p384.d.ts",
        "import": "./esm/p384.js",
        "default": "./p384.js"
      },
      "./p521": {
        "types": "./p521.d.ts",
        "import": "./esm/p521.js",
        "default": "./p521.js"
      },
      "./pasta": {
        "types": "./pasta.d.ts",
        "import": "./esm/pasta.js",
        "default": "./pasta.js"
      },
      "./secp256k1": {
        "types": "./secp256k1.d.ts",
        "import": "./esm/secp256k1.js",
        "default": "./secp256k1.js"
      }
    },
    "keywords": [
      "elliptic",
      "curve",
      "cryptography",
      "weierstrass",
      "montgomery",
      "edwards",
      "p256",
      "p384",
      "p521",
      "secp256r1",
      "secp256k1",
      "ed25519",
      "ed448",
      "x25519",
      "ed25519",
      "bls12-381",
      "bn254",
      "pasta",
      "bls",
      "noble",
      "ecc",
      "ecdsa",
      "eddsa",
      "schnorr"
    ],
    "funding": "https://paulmillr.com/funding/",
    "_registry": "npm",
    "_loc": "/data/data/com.termux/files/home/.cache/yarn/v6/npm-@noble-curves-1.2.0-92d7e12e4e49b23105a2555c6984d41733d65c35-integrity/node_modules/@noble/curves/package.json",
    "readmeFilename": "README.md",
    "readme": "# noble-curves\n\nAudited & minimal JS implementation of elliptic curve cryptography.\n\n- ðŸ”’ [**Audited**](#security) by an independent security firm\n- ðŸ”» Tree-shaking-friendly: use only what's necessary, other code won't be included\n- ðŸŽ Ultra-fast, hand-optimized for caveats of JS engines\n- ðŸ” Unique tests ensure correctness: property-based, cross-library and Wycheproof vectors, fuzzing\n- âž° Short Weierstrass, Edwards, Montgomery curves\n- âœï¸ ECDSA, EdDSA, Schnorr, BLS signature schemes, ECDH key agreement\n- ðŸ”– SUF-CMA and SBS (non-repudiation) for ed25519, ed448 and others\n- #ï¸âƒ£ hash-to-curve for encoding or hashing an arbitrary string to an elliptic curve point\n- ðŸ§œâ€â™‚ï¸ Poseidon ZK-friendly hash\n\n### This library belongs to _noble_ crypto\n\n> **noble-crypto** â€” high-security, easily auditable set of contained cryptographic libraries and tools.\n\n- No dependencies, protection against supply chain attacks\n- Auditable TypeScript / JS code\n- Supported on all major platforms\n- Releases are signed with PGP keys and built transparently with NPM provenance\n- Check out [homepage](https://paulmillr.com/noble/) & all libraries:\n  [ciphers](https://github.com/paulmillr/noble-ciphers),\n  [curves](https://github.com/paulmillr/noble-curves),\n  [hashes](https://github.com/paulmillr/noble-hashes),\n  4kb [secp256k1](https://github.com/paulmillr/noble-secp256k1) /\n  [ed25519](https://github.com/paulmillr/noble-ed25519)\n\n## Usage\n\n> npm install @noble/curves\n\nWe support all major platforms and runtimes.\nFor [Deno](https://deno.land), ensure to use [npm specifier](https://deno.land/manual@v1.28.0/node/npm_specifiers).\nFor React Native, you may need a [polyfill for crypto.getRandomValues](https://github.com/LinusU/react-native-get-random-values).\nIf you don't like NPM, a standalone [noble-curves.js](https://github.com/paulmillr/noble-curves/releases) is also available.\n\n- [Implementations](#implementations)\n  - [ECDSA signature scheme](#ecdsa-signature-scheme)\n  - [ECDSA public key recovery & extra entropy](#ecdsa-public-key-recovery--extra-entropy)\n  - [ECDH (Elliptic Curve Diffie-Hellman)](#ecdh-elliptic-curve-diffie-hellman)\n  - [Schnorr signatures over secp256k1, BIP340](#schnorr-signatures-over-secp256k1-bip340)\n  - [ed25519, X25519, ristretto255](#ed25519-x25519-ristretto255)\n  - [ed448, X448, decaf448](#ed448-x448-decaf448)\n  - [bls12-381](#bls12-381)\n  - [All available imports](#all-available-imports)\n  - [Accessing a curve's variables](#accessing-a-curves-variables)\n- [Abstract API](#abstract-api)\n  - [abstract/weierstrass: Short Weierstrass curve](#abstractweierstrass-short-weierstrass-curve)\n  - [abstract/edwards: Twisted Edwards curve](#abstractedwards-twisted-edwards-curve)\n  - [abstract/montgomery: Montgomery curve](#abstractmontgomery-montgomery-curve)\n  - [abstract/bls: Barreto-Lynn-Scott curves](#abstractbls-barreto-lynn-scott-curves)\n  - [abstract/hash-to-curve: Hashing strings to curve points](#abstracthash-to-curve-hashing-strings-to-curve-points)\n  - [abstract/poseidon: Poseidon hash](#abstractposeidon-poseidon-hash)\n  - [abstract/modular: Modular arithmetics utilities](#abstractmodular-modular-arithmetics-utilities)\n    - [Creating private keys from hashes](#creating-private-keys-from-hashes)\n  - [abstract/utils: Useful utilities](#abstractutils-useful-utilities)\n- [Security](#security)\n- [Speed](#speed)\n- [Contributing & testing](#contributing--testing)\n- [Upgrading](#upgrading)\n- [Resources](#resources)\n  - [Demos](#demos)\n  - [Projects using curves](#projects-using-curves)\n- [License](#license)\n\n### Implementations\n\nImplementations are utilizing [noble-hashes](https://github.com/paulmillr/noble-hashes).\n[Abstract API](#abstract-api) doesn't depend on them: you can use a different hashing library.\n\n#### ECDSA signature scheme\n\nGeneric example that works for all curves, shown for secp256k1:\n\n```ts\n// import * from '@noble/curves'; // Error: use sub-imports, to ensure small app size\nimport { secp256k1 } from '@noble/curves/secp256k1'; // ESM and Common.js\n// import { secp256k1 } from 'npm:@noble/curves@1.2.0/secp256k1'; // Deno\nconst priv = secp256k1.utils.randomPrivateKey();\nconst pub = secp256k1.getPublicKey(priv);\nconst msg = new Uint8Array(32).fill(1); // message hash (not message) in ecdsa\nconst sig = secp256k1.sign(msg, priv); // `{prehash: true}` option is available\nconst isValid = secp256k1.verify(sig, msg, pub) === true;\n\n// hex strings are also supported besides Uint8Arrays:\nconst privHex = '46c930bc7bb4db7f55da20798697421b98c4175a52c630294d75a84b9c126236';\nconst pub2 = secp256k1.getPublicKey(privHex);\n```\n\n#### ECDSA public key recovery & extra entropy\n\n```ts\nsig.recoverPublicKey(msg).toRawBytes(); // === pub; // public key recovery\n\n// extraEntropy https://moderncrypto.org/mail-archive/curves/2017/000925.html\nconst sigImprovedSecurity = secp256k1.sign(msg, priv, { extraEntropy: true });\n```\n\n#### ECDH (Elliptic Curve Diffie-Hellman)\n\n```ts\n// 1. The output includes parity byte. Strip it using shared.slice(1)\n// 2. The output is not hashed. More secure way is sha256(shared) or hkdf(shared)\nconst someonesPub = secp256k1.getPublicKey(secp256k1.utils.randomPrivateKey());\nconst shared = secp256k1.getSharedSecret(priv, someonesPub);\n```\n\n#### Schnorr signatures over secp256k1 (BIP340)\n\n```ts\nimport { schnorr } from '@noble/curves/secp256k1';\nconst priv = schnorr.utils.randomPrivateKey();\nconst pub = schnorr.getPublicKey(priv);\nconst msg = new TextEncoder().encode('hello');\nconst sig = schnorr.sign(msg, priv);\nconst isValid = schnorr.verify(sig, msg, pub);\n```\n\n#### ed25519, X25519, ristretto255\n\n```ts\nimport { ed25519 } from '@noble/curves/ed25519';\nconst priv = ed25519.utils.randomPrivateKey();\nconst pub = ed25519.getPublicKey(priv);\nconst msg = new TextEncoder().encode('hello');\nconst sig = ed25519.sign(msg, priv);\ned25519.verify(sig, msg, pub); // Default mode: follows ZIP215\ned25519.verify(sig, msg, pub, { zip215: false }); // RFC8032 / FIPS 186-5\n```\n\nDefault `verify` behavior follows [ZIP215](https://zips.z.cash/zip-0215) and\n[can be used in consensus-critical applications](https://hdevalence.ca/blog/2020-10-04-its-25519am).\nIt has SUF-CMA (strong unforgeability under chosen message attacks).\n`zip215: false` option switches verification criteria to strict\n[RFC8032](https://www.rfc-editor.org/rfc/rfc8032) / [FIPS 186-5](https://csrc.nist.gov/publications/detail/fips/186/5/final)\nand additionally provides non-repudiation with SBS [(Strongly Binding Signatures)](https://eprint.iacr.org/2020/1244).\n\nX25519 follows [RFC7748](https://www.rfc-editor.org/rfc/rfc7748).\n\n```ts\n// Variants from RFC8032: with context, prehashed\nimport { ed25519ctx, ed25519ph } from '@noble/curves/ed25519';\n\n// ECDH using curve25519 aka x25519\nimport { x25519 } from '@noble/curves/ed25519';\nconst priv = 'a546e36bf0527c9d3b16154b82465edd62144c0ac1fc5a18506a2244ba449ac4';\nconst pub = 'e6db6867583030db3594c1a424b15f7c726624ec26b3353b10a903a6d0ab1c4c';\nx25519.getSharedSecret(priv, pub) === x25519.scalarMult(priv, pub); // aliases\nx25519.getPublicKey(priv) === x25519.scalarMultBase(priv);\nx25519.getPublicKey(x25519.utils.randomPrivateKey());\n\n// ed25519 => x25519 conversion\nimport { edwardsToMontgomeryPub, edwardsToMontgomeryPriv } from '@noble/curves/ed25519';\nedwardsToMontgomeryPub(ed25519.getPublicKey(ed25519.utils.randomPrivateKey()));\nedwardsToMontgomeryPriv(ed25519.utils.randomPrivateKey());\n```\n\nristretto255 follows [irtf draft](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-ristretto255-decaf448).\n\n```ts\n// hash-to-curve, ristretto255\nimport { utf8ToBytes } from '@noble/hashes/utils';\nimport { sha512 } from '@noble/hashes/sha512';\nimport {\n  hashToCurve,\n  encodeToCurve,\n  RistrettoPoint,\n  hashToRistretto255,\n} from '@noble/curves/ed25519';\n\nconst msg = utf8ToBytes('Ristretto is traditionally a short shot of espresso coffee');\nhashToCurve(msg);\n\nconst rp = RistrettoPoint.fromHex(\n  '6a493210f7499cd17fecb510ae0cea23a110e8d5b901f8acadd3095c73a3b919'\n);\nRistrettoPoint.BASE.multiply(2n).add(rp).subtract(RistrettoPoint.BASE).toRawBytes();\nRistrettoPoint.ZERO.equals(dp) === false;\n// pre-hashed hash-to-curve\nRistrettoPoint.hashToCurve(sha512(msg));\n// full hash-to-curve including domain separation tag\nhashToRistretto255(msg, { DST: 'ristretto255_XMD:SHA-512_R255MAP_RO_' });\n```\n\n#### ed448, X448, decaf448\n\n```ts\nimport { ed448 } from '@noble/curves/ed448';\nconst priv = ed448.utils.randomPrivateKey();\nconst pub = ed448.getPublicKey(priv);\nconst msg = new TextEncoder().encode('whatsup');\nconst sig = ed448.sign(msg, priv);\ned448.verify(sig, msg, pub);\n\n// Variants from RFC8032: prehashed\nimport { ed448ph } from '@noble/curves/ed448';\n```\n\nECDH using Curve448 aka X448, follows [RFC7748](https://www.rfc-editor.org/rfc/rfc7748).\n\n```ts\nimport { x448 } from '@noble/curves/ed448';\nx448.getSharedSecret(priv, pub) === x448.scalarMult(priv, pub); // aliases\nx448.getPublicKey(priv) === x448.scalarMultBase(priv);\n\n// ed448 => x448 conversion\nimport { edwardsToMontgomeryPub } from '@noble/curves/ed448';\nedwardsToMontgomeryPub(ed448.getPublicKey(ed448.utils.randomPrivateKey()));\n```\n\ndecaf448 follows [irtf draft](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-ristretto255-decaf448).\n\n```ts\nimport { utf8ToBytes } from '@noble/hashes/utils';\nimport { shake256 } from '@noble/hashes/sha3';\nimport { hashToCurve, encodeToCurve, DecafPoint, hashToDecaf448 } from '@noble/curves/ed448';\n\nconst msg = utf8ToBytes('Ristretto is traditionally a short shot of espresso coffee');\nhashToCurve(msg);\n\nconst dp = DecafPoint.fromHex(\n  'c898eb4f87f97c564c6fd61fc7e49689314a1f818ec85eeb3bd5514ac816d38778f69ef347a89fca817e66defdedce178c7cc709b2116e75'\n);\nDecafPoint.BASE.multiply(2n).add(dp).subtract(DecafPoint.BASE).toRawBytes();\nDecafPoint.ZERO.equals(dp) === false;\n// pre-hashed hash-to-curve\nDecafPoint.hashToCurve(shake256(msg, { dkLen: 112 }));\n// full hash-to-curve including domain separation tag\nhashToDecaf448(msg, { DST: 'decaf448_XOF:SHAKE256_D448MAP_RO_' });\n```\n\nSame RFC7748 / RFC8032 / IRTF draft are followed.\n\n#### bls12-381\n\nSee [abstract/bls](#abstractbls-barreto-lynn-scott-curves).\n\n#### All available imports\n\n```typescript\nimport { secp256k1, schnorr } from '@noble/curves/secp256k1';\nimport { ed25519, ed25519ph, ed25519ctx, x25519, RistrettoPoint } from '@noble/curves/ed25519';\nimport { ed448, ed448ph, ed448ctx, x448 } from '@noble/curves/ed448';\nimport { p256 } from '@noble/curves/p256';\nimport { p384 } from '@noble/curves/p384';\nimport { p521 } from '@noble/curves/p521';\nimport { pallas, vesta } from '@noble/curves/pasta';\nimport { bls12_381 } from '@noble/curves/bls12-381';\nimport { bn254 } from '@noble/curves/bn254'; // also known as alt_bn128\nimport { jubjub } from '@noble/curves/jubjub';\nimport { bytesToHex, hexToBytes, concatBytes, utf8ToBytes } from '@noble/curves/abstract/utils';\n```\n\n#### Accessing a curve's variables\n\n```ts\nimport { secp256k1 } from '@noble/curves/secp256k1';\n// Every curve has `CURVE` object that contains its parameters, field, and others\nconsole.log(secp256k1.CURVE.p); // field modulus\nconsole.log(secp256k1.CURVE.n); // curve order\nconsole.log(secp256k1.CURVE.a, secp256k1.CURVE.b); // equation params\nconsole.log(secp256k1.CURVE.Gx, secp256k1.CURVE.Gy); // base point coordinates\n```\n\n## Abstract API\n\nAbstract API allows to define custom curves. All arithmetics is done with JS\nbigints over finite fields, which is defined from `modular` sub-module. For\nscalar multiplication, we use\n[precomputed tables with w-ary non-adjacent form (wNAF)](https://paulmillr.com/posts/noble-secp256k1-fast-ecc/).\nPrecomputes are enabled for weierstrass and edwards BASE points of a curve. You\ncould precompute any other point (e.g. for ECDH) using `utils.precompute()`\nmethod: check out examples.\n\n### abstract/weierstrass: Short Weierstrass curve\n\n```ts\nimport { weierstrass } from '@noble/curves/abstract/weierstrass';\nimport { Field } from '@noble/curves/abstract/modular'; // finite field for mod arithmetics\nimport { sha256 } from '@noble/hashes/sha256'; // 3rd-party sha256() of type utils.CHash\nimport { hmac } from '@noble/hashes/hmac'; // 3rd-party hmac() that will accept sha256()\nimport { concatBytes, randomBytes } from '@noble/hashes/utils'; // 3rd-party utilities\nconst secq256k1 = weierstrass({\n  // secq256k1: cycle of secp256k1 with Fp/N flipped.\n  // https://personaelabs.org/posts/spartan-ecdsa\n  // https://zcash.github.io/halo2/background/curves.html#cycles-of-curves\n  a: 0n,\n  b: 7n,\n  Fp: Field(2n ** 256n - 432420386565659656852420866394968145599n),\n  n: 2n ** 256n - 2n ** 32n - 2n ** 9n - 2n ** 8n - 2n ** 7n - 2n ** 6n - 2n ** 4n - 1n,\n  Gx: 55066263022277343669578718895168534326250603453777594175500187360389116729240n,\n  Gy: 32670510020758816978083085130507043184471273380659243275938904335757337482424n,\n  hash: sha256,\n  hmac: (key: Uint8Array, ...msgs: Uint8Array[]) => hmac(sha256, key, concatBytes(...msgs)),\n  randomBytes,\n});\n\n// Replace weierstrass() with weierstrassPoints() if you don't need ECDSA, hash, hmac, randomBytes\n```\n\nShort Weierstrass curve's formula is `yÂ² = xÂ³ + ax + b`. `weierstrass`\nexpects arguments `a`, `b`, field `Fp`, curve order `n`, cofactor `h`\nand coordinates `Gx`, `Gy` of generator point.\n\n**`k` generation** is done deterministically, following\n[RFC6979](https://www.rfc-editor.org/rfc/rfc6979). For this you will need\n`hmac` & `hash`, which in our implementations is provided by noble-hashes. If\nyou're using different hashing library, make sure to wrap it in the following interface:\n\n```ts\ntype CHash = {\n  (message: Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create(): any;\n};\n```\n\n**Message hash** is expected instead of message itself:\n\n- `sign(msgHash, privKey)` is default behavior, assuming you pre-hash msg with sha2, or other hash\n- `sign(msg, privKey, {prehash: true})` option can be used if you want to pass the message itself\n\n**Weierstrass points:**\n\n1. Exported as `ProjectivePoint`\n2. Represented in projective (homogeneous) coordinates: (x, y, z) âˆ‹ (x=x/z, y=y/z)\n3. Use complete exception-free formulas for addition and doubling\n4. Can be decoded/encoded from/to Uint8Array / hex strings using\n   `ProjectivePoint.fromHex` and `ProjectivePoint#toRawBytes()`\n5. Have `assertValidity()` which checks for being on-curve\n6. Have `toAffine()` and `x` / `y` getters which convert to 2d xy affine coordinates\n\n```ts\n// `weierstrassPoints()` returns `CURVE` and `ProjectivePoint`\n// `weierstrass()` returns `CurveFn`\ntype SignOpts = { lowS?: boolean; prehash?: boolean; extraEntropy: boolean | Uint8Array };\ntype CurveFn = {\n  CURVE: ReturnType<typeof validateOpts>;\n  getPublicKey: (privateKey: PrivKey, isCompressed?: boolean) => Uint8Array;\n  getSharedSecret: (privateA: PrivKey, publicB: Hex, isCompressed?: boolean) => Uint8Array;\n  sign: (msgHash: Hex, privKey: PrivKey, opts?: SignOpts) => SignatureType;\n  verify: (\n    signature: Hex | SignatureType,\n    msgHash: Hex,\n    publicKey: Hex,\n    opts?: { lowS?: boolean; prehash?: boolean }\n  ) => boolean;\n  ProjectivePoint: ProjectivePointConstructor;\n  Signature: SignatureConstructor;\n  utils: {\n    normPrivateKeyToScalar: (key: PrivKey) => bigint;\n    isValidPrivateKey(key: PrivKey): boolean;\n    randomPrivateKey: () => Uint8Array;\n    precompute: (windowSize?: number, point?: ProjPointType<bigint>) => ProjPointType<bigint>;\n  };\n};\n\n// T is usually bigint, but can be something else like complex numbers in BLS curves\ninterface ProjPointType<T> extends Group<ProjPointType<T>> {\n  readonly px: T;\n  readonly py: T;\n  readonly pz: T;\n  get x(): bigint;\n  get y(): bigint;\n  multiply(scalar: bigint): ProjPointType<T>;\n  multiplyUnsafe(scalar: bigint): ProjPointType<T>;\n  multiplyAndAddUnsafe(Q: ProjPointType<T>, a: bigint, b: bigint): ProjPointType<T> | undefined;\n  toAffine(iz?: T): AffinePoint<T>;\n  isTorsionFree(): boolean;\n  clearCofactor(): ProjPointType<T>;\n  assertValidity(): void;\n  hasEvenY(): boolean;\n  toRawBytes(isCompressed?: boolean): Uint8Array;\n  toHex(isCompressed?: boolean): string;\n}\n// Static methods for 3d XYZ points\ninterface ProjConstructor<T> extends GroupConstructor<ProjPointType<T>> {\n  new (x: T, y: T, z: T): ProjPointType<T>;\n  fromAffine(p: AffinePoint<T>): ProjPointType<T>;\n  fromHex(hex: Hex): ProjPointType<T>;\n  fromPrivateKey(privateKey: PrivKey): ProjPointType<T>;\n}\n```\n\n**ECDSA signatures** are represented by `Signature` instances and can be\ndescribed by the interface:\n\n```ts\ninterface SignatureType {\n  readonly r: bigint;\n  readonly s: bigint;\n  readonly recovery?: number;\n  assertValidity(): void;\n  addRecoveryBit(recovery: number): SignatureType;\n  hasHighS(): boolean;\n  normalizeS(): SignatureType;\n  recoverPublicKey(msgHash: Hex): ProjPointType<bigint>;\n  toCompactRawBytes(): Uint8Array;\n  toCompactHex(): string;\n  // DER-encoded\n  toDERRawBytes(): Uint8Array;\n  toDERHex(): string;\n}\ntype SignatureConstructor = {\n  new (r: bigint, s: bigint): SignatureType;\n  fromCompact(hex: Hex): SignatureType;\n  fromDER(hex: Hex): SignatureType;\n};\n```\n\nMore examples:\n\n```typescript\n// All curves expose same generic interface.\nconst priv = secq256k1.utils.randomPrivateKey();\nsecq256k1.getPublicKey(priv); // Convert private key to public.\nconst sig = secq256k1.sign(msg, priv); // Sign msg with private key.\nconst sig2 = secq256k1.sign(msg, priv, { prehash: true }); // hash(msg)\nsecq256k1.verify(sig, msg, priv); // Verify if sig is correct.\n\nconst Point = secq256k1.ProjectivePoint;\nconst point = Point.BASE; // Elliptic curve Point class and BASE point static var.\npoint.add(point).equals(point.double()); // add(), equals(), double() methods\npoint.subtract(point).equals(Point.ZERO); // subtract() method, ZERO static var\npoint.negate(); // Flips point over x/y coordinate.\npoint.multiply(31415n); // Multiplication of Point by scalar.\n\npoint.assertValidity(); // Checks for being on-curve\npoint.toAffine(); // Converts to 2d affine xy coordinates\n\nsecq256k1.CURVE.n;\nsecq256k1.CURVE.p;\nsecq256k1.CURVE.Fp.mod();\nsecq256k1.CURVE.hash();\n\n// precomputes\nconst fast = secq256k1.utils.precompute(8, Point.fromHex(someonesPubKey));\nfast.multiply(privKey); // much faster ECDH now\n```\n\n### abstract/edwards: Twisted Edwards curve\n\n```ts\nimport { twistedEdwards } from '@noble/curves/abstract/edwards';\nimport { Field } from '@noble/curves/abstract/modular';\nimport { sha512 } from '@noble/hashes/sha512';\nimport { randomBytes } from '@noble/hashes/utils';\n\nconst Fp = Field(2n ** 255n - 19n);\nconst ed25519 = twistedEdwards({\n  a: Fp.create(-1n),\n  d: Fp.div(-121665n, 121666n), // -121665n/121666n mod p\n  Fp: Fp,\n  n: 2n ** 252n + 27742317777372353535851937790883648493n,\n  h: 8n,\n  Gx: 15112221349535400772501151409588531511454012693041857206046113283949847762202n,\n  Gy: 46316835694926478169428394003475163141307993866256225615783033603165251855960n,\n  hash: sha512,\n  randomBytes,\n  adjustScalarBytes(bytes) {\n    // optional; but mandatory in ed25519\n    bytes[0] &= 248;\n    bytes[31] &= 127;\n    bytes[31] |= 64;\n    return bytes;\n  },\n} as const);\n```\n\nTwisted Edwards curve's formula is `axÂ² + yÂ² = 1 + dxÂ²yÂ²`. You must specify `a`, `d`, field `Fp`, order `n`, cofactor `h`\nand coordinates `Gx`, `Gy` of generator point.\n\nFor EdDSA signatures, `hash` param required. `adjustScalarBytes` which instructs how to change private scalars could be specified.\n\n**Edwards points:**\n\n1. Exported as `ExtendedPoint`\n2. Represented in extended coordinates: (x, y, z, t) âˆ‹ (x=x/z, y=y/z)\n3. Use complete exception-free formulas for addition and doubling\n4. Can be decoded/encoded from/to Uint8Array / hex strings using `ExtendedPoint.fromHex` and `ExtendedPoint#toRawBytes()`\n5. Have `assertValidity()` which checks for being on-curve\n6. Have `toAffine()` and `x` / `y` getters which convert to 2d xy affine coordinates\n7. Have `isTorsionFree()`, `clearCofactor()` and `isSmallOrder()` utilities to handle torsions\n\n```ts\n// `twistedEdwards()` returns `CurveFn` of following type:\ntype CurveFn = {\n  CURVE: ReturnType<typeof validateOpts>;\n  getPublicKey: (privateKey: Hex) => Uint8Array;\n  sign: (message: Hex, privateKey: Hex, context?: Hex) => Uint8Array;\n  verify: (sig: SigType, message: Hex, publicKey: Hex, context?: Hex) => boolean;\n  ExtendedPoint: ExtPointConstructor;\n  utils: {\n    randomPrivateKey: () => Uint8Array;\n    getExtendedPublicKey: (key: PrivKey) => {\n      head: Uint8Array;\n      prefix: Uint8Array;\n      scalar: bigint;\n      point: PointType;\n      pointBytes: Uint8Array;\n    };\n  };\n};\n\ninterface ExtPointType extends Group<ExtPointType> {\n  readonly ex: bigint;\n  readonly ey: bigint;\n  readonly ez: bigint;\n  readonly et: bigint;\n  get x(): bigint;\n  get y(): bigint;\n  assertValidity(): void;\n  multiply(scalar: bigint): ExtPointType;\n  multiplyUnsafe(scalar: bigint): ExtPointType;\n  isSmallOrder(): boolean;\n  isTorsionFree(): boolean;\n  clearCofactor(): ExtPointType;\n  toAffine(iz?: bigint): AffinePoint<bigint>;\n  toRawBytes(isCompressed?: boolean): Uint8Array;\n  toHex(isCompressed?: boolean): string;\n}\n// Static methods of Extended Point with coordinates in X, Y, Z, T\ninterface ExtPointConstructor extends GroupConstructor<ExtPointType> {\n  new (x: bigint, y: bigint, z: bigint, t: bigint): ExtPointType;\n  fromAffine(p: AffinePoint<bigint>): ExtPointType;\n  fromHex(hex: Hex): ExtPointType;\n  fromPrivateKey(privateKey: Hex): ExtPointType;\n}\n```\n\n### abstract/montgomery: Montgomery curve\n\n```typescript\nimport { montgomery } from '@noble/curves/abstract/montgomery';\nimport { Field } from '@noble/curves/abstract/modular';\n\nconst x25519 = montgomery({\n  a: 486662n,\n  Gu: 9n,\n  Fp: Field(2n ** 255n - 19n),\n  montgomeryBits: 255,\n  nByteLength: 32,\n  // Optional param\n  adjustScalarBytes(bytes) {\n    bytes[0] &= 248;\n    bytes[31] &= 127;\n    bytes[31] |= 64;\n    return bytes;\n  },\n});\n```\n\nThe module contains methods for x-only ECDH on Curve25519 / Curve448 from RFC7748.\nProper Elliptic Curve Points are not implemented yet.\n\nYou must specify curve params `Fp`, `a`, `Gu` coordinate of u, `montgomeryBits` and `nByteLength`.\n\n### abstract/bls: Barreto-Lynn-Scott curves\n\nThe module abstracts BLS (Barreto-Lynn-Scott) pairing-friendly elliptic curve construction.\nThey allow to construct [zk-SNARKs](https://z.cash/technology/zksnarks/) and\nuse aggregated, batch-verifiable\n[threshold signatures](https://medium.com/snigirev.stepan/bls-signatures-better-than-schnorr-5a7fe30ea716),\nusing Boneh-Lynn-Shacham signature scheme.\n\nThe module doesn't expose `CURVE` property: use `G1.CURVE`, `G2.CURVE` instead.\n\nMain methods and properties are:\n\n- `getPublicKey(privateKey)`\n- `sign(message, privateKey)`\n- `verify(signature, message, publicKey)`\n- `aggregatePublicKeys(publicKeys)`\n- `aggregateSignatures(signatures)`\n- `G1` and `G2` curves containing `CURVE` and `ProjectivePoint`\n- `Signature` property with `fromHex`, `toHex` methods\n- `fields` containing `Fp`, `Fp2`, `Fp6`, `Fp12`, `Fr`\n\nRight now we only implement BLS12-381 (compatible with ETH and others),\nbut in theory defining BLS12-377, BLS24 should be straightforward. An example:\n\n```ts\nimport { bls12_381 as bls } from '@noble/curves/bls12-381';\nconst privateKey = '67d53f170b908cabb9eb326c3c337762d59289a8fec79f7bc9254b584b73265c';\nconst message = '64726e3da8';\nconst publicKey = bls.getPublicKey(privateKey);\nconst signature = bls.sign(message, privateKey);\nconst isValid = bls.verify(signature, message, publicKey);\nconsole.log({ publicKey, signature, isValid });\n\n// Sign 1 msg with 3 keys\nconst privateKeys = [\n  '18f020b98eb798752a50ed0563b079c125b0db5dd0b1060d1c1b47d4a193e1e4',\n  'ed69a8c50cf8c9836be3b67c7eeff416612d45ba39a5c099d48fa668bf558c9c',\n  '16ae669f3be7a2121e17d0c68c05a8f3d6bef21ec0f2315f1d7aec12484e4cf5',\n];\nconst messages = ['d2', '0d98', '05caf3'];\nconst publicKeys = privateKeys.map(bls.getPublicKey);\nconst signatures2 = privateKeys.map((p) => bls.sign(message, p));\nconst aggPubKey2 = bls.aggregatePublicKeys(publicKeys);\nconst aggSignature2 = bls.aggregateSignatures(signatures2);\nconst isValid2 = bls.verify(aggSignature2, message, aggPubKey2);\nconsole.log({ signatures2, aggSignature2, isValid2 });\n\n// Sign 3 msgs with 3 keys\nconst signatures3 = privateKeys.map((p, i) => bls.sign(messages[i], p));\nconst aggSignature3 = bls.aggregateSignatures(signatures3);\nconst isValid3 = bls.verifyBatch(aggSignature3, messages, publicKeys);\nconsole.log({ publicKeys, signatures3, aggSignature3, isValid3 });\n\n// Pairings, with and without final exponentiation\n// bls.pairing(PointG1, PointG2);\n// bls.pairing(PointG1, PointG2, false);\n// bls.fields.Fp12.finalExponentiate(bls.fields.Fp12.mul(eGS, ePHm));\n\n// Others\n// bls.G1.ProjectivePoint.BASE, bls.G2.ProjectivePoint.BASE\n// bls.fields.Fp, bls.fields.Fp2, bls.fields.Fp12, bls.fields.Fr\n\n// hash-to-curve examples can be seen below\n```\n\nFull types:\n\n```ts\ngetPublicKey: (privateKey: PrivKey) => Uint8Array;\nsign: {\n  (message: Hex, privateKey: PrivKey): Uint8Array;\n  (message: ProjPointType<Fp2>, privateKey: PrivKey): ProjPointType<Fp2>;\n};\nverify: (\n  signature: Hex | ProjPointType<Fp2>,\n  message: Hex | ProjPointType<Fp2>,\n  publicKey: Hex | ProjPointType<Fp>\n) => boolean;\nverifyBatch: (\n  signature: Hex | ProjPointType<Fp2>,\n  messages: (Hex | ProjPointType<Fp2>)[],\n  publicKeys: (Hex | ProjPointType<Fp>)[]\n) => boolean;\naggregatePublicKeys: {\n  (publicKeys: Hex[]): Uint8Array;\n  (publicKeys: ProjPointType<Fp>[]): ProjPointType<Fp>;\n};\naggregateSignatures: {\n  (signatures: Hex[]): Uint8Array;\n  (signatures: ProjPointType<Fp2>[]): ProjPointType<Fp2>;\n};\nmillerLoop: (ell: [Fp2, Fp2, Fp2][], g1: [Fp, Fp]) => Fp12;\npairing: (P: ProjPointType<Fp>, Q: ProjPointType<Fp2>, withFinalExponent?: boolean) => Fp12;\nG1: CurvePointsRes<Fp> & ReturnType<typeof htf.createHasher<Fp>>;\nG2: CurvePointsRes<Fp2> & ReturnType<typeof htf.createHasher<Fp2>>;\nSignature: SignatureCoder<Fp2>;\nparams: {\n  x: bigint;\n  r: bigint;\n  G1b: bigint;\n  G2b: Fp2;\n};\nfields: {\n  Fp: IField<Fp>;\n  Fp2: IField<Fp2>;\n  Fp6: IField<Fp6>;\n  Fp12: IField<Fp12>;\n  Fr: IField<bigint>;\n};\nutils: {\n  randomPrivateKey: () => Uint8Array;\n  calcPairingPrecomputes: (p: AffinePoint<Fp2>) => [Fp2, Fp2, Fp2][];\n};\n```\n\n### abstract/hash-to-curve: Hashing strings to curve points\n\nThe module allows to hash arbitrary strings to elliptic curve points. Implements [RFC 9380](https://www.rfc-editor.org/rfc/rfc9380).\n\nEvery curve has exported `hashToCurve` and `encodeToCurve` methods. You should always prefer `hashToCurve` for security:\n\n```ts\nimport { hashToCurve, encodeToCurve } from '@noble/curves/secp256k1';\nimport { randomBytes } from '@noble/hashes/utils';\nhashToCurve('0102abcd');\nconsole.log(hashToCurve(randomBytes()));\nconsole.log(encodeToCurve(randomBytes()));\n\nimport { bls12_381 } from '@noble/curves/bls12-381';\nbls12_381.G1.hashToCurve(randomBytes(), { DST: 'another' });\nbls12_381.G2.hashToCurve(randomBytes(), { DST: 'custom' });\n```\n\nLow-level methods from the spec:\n\n```ts\n// produces a uniformly random byte string using a cryptographic hash function H that outputs b bits.\nfunction expand_message_xmd(\n  msg: Uint8Array,\n  DST: Uint8Array,\n  lenInBytes: number,\n  H: CHash // For CHash see abstract/weierstrass docs section\n): Uint8Array;\n// produces a uniformly random byte string using an extendable-output function (XOF) H.\nfunction expand_message_xof(\n  msg: Uint8Array,\n  DST: Uint8Array,\n  lenInBytes: number,\n  k: number,\n  H: CHash\n): Uint8Array;\n// Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F\nfunction hash_to_field(msg: Uint8Array, count: number, options: Opts): bigint[][];\n\n/**\n * * `DST` is a domain separation tag, defined in section 2.2.5\n * * `p` characteristic of F, where F is a finite field of characteristic p and order q = p^m\n * * `m` is extension degree (1 for prime fields)\n * * `k` is the target security target in bits (e.g. 128), from section 5.1\n * * `expand` is `xmd` (SHA2, SHA3, BLAKE) or `xof` (SHAKE, BLAKE-XOF)\n * * `hash` conforming to `utils.CHash` interface, with `outputLen` / `blockLen` props\n */\ntype UnicodeOrBytes = string | Uint8Array;\ntype Opts = {\n  DST: UnicodeOrBytes;\n  p: bigint;\n  m: number;\n  k: number;\n  expand?: 'xmd' | 'xof';\n  hash: CHash;\n};\n```\n\n### abstract/poseidon: Poseidon hash\n\nImplements [Poseidon](https://www.poseidon-hash.info) ZK-friendly hash.\n\nThere are many poseidon variants with different constants.\nWe don't provide them: you should construct them manually.\nCheck out [micro-starknet](https://github.com/paulmillr/micro-starknet) package for a proper example.\n\n```ts\nimport { poseidon } from '@noble/curves/abstract/poseidon';\n\ntype PoseidonOpts = {\n  Fp: Field<bigint>;\n  t: number;\n  roundsFull: number;\n  roundsPartial: number;\n  sboxPower?: number;\n  reversePartialPowIdx?: boolean;\n  mds: bigint[][];\n  roundConstants: bigint[][];\n};\nconst instance = poseidon(opts: PoseidonOpts);\n```\n\n### abstract/modular: Modular arithmetics utilities\n\n```ts\nimport * as mod from '@noble/curves/abstract/modular';\nconst fp = mod.Field(2n ** 255n - 19n); // Finite field over 2^255-19\nfp.mul(591n, 932n); // multiplication\nfp.pow(481n, 11024858120n); // exponentiation\nfp.div(5n, 17n); // division: 5/17 mod 2^255-19 == 5 * invert(17)\nfp.sqrt(21n); // square root\n\n// Generic non-FP utils are also available\nmod.mod(21n, 10n); // 21 mod 10 == 1n; fixed version of 21 % 10\nmod.invert(17n, 10n); // invert(17) mod 10; modular multiplicative inverse\nmod.invertBatch([1n, 2n, 4n], 21n); // => [1n, 11n, 16n] in one inversion\n```\n\nField operations are not constant-time: they are using JS bigints, see [security](#security).\nThe fact is mostly irrelevant, but the important method to keep in mind is `pow`,\nwhich may leak exponent bits, when used naÃ¯vely.\n\n`mod.Field` is always **field over prime**. Non-prime fields aren't supported for now.\nWe don't test for prime-ness for speed and because algorithms are probabilistic anyway.\nInitializing a non-prime field could make your app suspectible to\nDoS (infilite loop) on Tonelli-Shanks square root calculation.\n\nUnlike `mod.invert`, `mod.invertBatch` won't throw on `0`: make sure to throw an error yourself.\n\n#### Creating private keys from hashes\n\nYou can't simply make a 32-byte private key from a 32-byte hash.\nDoing so will make the key [biased](https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/).\n\nTo make the bias negligible, we follow [FIPS 186-5 A.2](https://csrc.nist.gov/publications/detail/fips/186/5/final)\nand [RFC 9380](https://www.rfc-editor.org/rfc/rfc9380#section-5.2).\nThis means, for 32-byte key, we would need 48-byte hash to get 2^-128 bias, which matches curve security level.\n\n`hashToPrivateScalar()` that hashes to **private key** was created for this purpose.\nUse [abstract/hash-to-curve](#abstracthash-to-curve-hashing-strings-to-curve-points)\nif you need to hash to **public key**.\n\n```ts\nimport { p256 } from '@noble/curves/p256';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { hkdf } from '@noble/hashes/hkdf';\nconst someKey = new Uint8Array(32).fill(2); // Needs to actually be random, not .fill(2)\nconst derived = hkdf(sha256, someKey, undefined, 'application', 48); // 48 bytes for 32-byte priv\nconst validPrivateKey = mod.hashToPrivateScalar(derived, p256.CURVE.n);\n```\n\n### abstract/utils: Useful utilities\n\n```ts\nimport * as utils from '@noble/curves/abstract/utils';\n\nutils.bytesToHex(Uint8Array.from([0xde, 0xad, 0xbe, 0xef]));\nutils.hexToBytes('deadbeef');\nutils.numberToHexUnpadded(123n);\nutils.hexToNumber();\n\nutils.bytesToNumberBE(Uint8Array.from([0xde, 0xad, 0xbe, 0xef]));\nutils.bytesToNumberLE(Uint8Array.from([0xde, 0xad, 0xbe, 0xef]));\nutils.numberToBytesBE(123n, 32);\nutils.numberToBytesLE(123n, 64);\n\nutils.concatBytes(Uint8Array.from([0xde, 0xad]), Uint8Array.from([0xbe, 0xef]));\nutils.nLength(255n);\nutils.equalBytes(Uint8Array.from([0xde]), Uint8Array.from([0xde]));\n```\n\n## Security\n\n1. The library has been independently audited:\n\n- in Feb 2023 by [Trail of Bits](https://www.trailofbits.com):\n  [PDF](https://github.com/trailofbits/publications/blob/master/reviews/2023-01-ryanshea-noblecurveslibrary-securityreview.pdf).\n  The audit has been funded by [Ryan Shea](https://www.shea.io).\n  Audit scope was abstract modules `curve`, `hash-to-curve`, `modular`, `poseidon`, `utils`, `weierstrass`,\n  and top-level modules `_shortw_utils` and `secp256k1`.\n  See [changes since v0.7.3 audit](https://github.com/paulmillr/noble-curves/compare/0.7.3..main).\n\n2. The library has been fuzzed by [Guido Vranken's cryptofuzz](https://github.com/guidovranken/cryptofuzz).\n   You can run the fuzzer by yourself to check it.\n3. [Timing attack](https://en.wikipedia.org/wiki/Timing_attack) considerations:\n   _JIT-compiler_ and _Garbage Collector_ make \"constant time\" extremely hard to\n   achieve in a scripting language. Which means _any other JS library can't have\n   constant-timeness_. Even statically typed Rust, a language without GC,\n   [makes it harder to achieve constant-time](https://www.chosenplaintext.ca/open-source/rust-timing-shield/security)\n   for some cases. If your goal is absolute security, don't use any JS lib â€” including bindings to native ones.\n   Use low-level libraries & languages. Nonetheless we're targetting algorithmic constant time.\n\nWe consider infrastructure attacks like rogue NPM modules very important;\nthat's why it's crucial to minimize the amount of 3rd-party dependencies & native bindings.\nIf your app uses 500 dependencies, any dep could get hacked and you'll be\ndownloading malware with every `npm install`. Our goal is to minimize this attack vector.\nAs for devDependencies used by the library:\n\n- `@scure` base, bip32, bip39 (used in tests), micro-bmark (benchmark), micro-should (testing)\n  are developed by us and follow the same practices such as: minimal library size, auditability,\n  signed releases\n- prettier (linter), fast-check (property-based testing), typescript versions\n  are locked and rarely updated. Every update is checked with `npm-diff`.\n  The packages are big, which makes it hard to audit their source code thoroughly and fully.\n- They are only used if you clone the git repo and want to add some feature to it. End-users won't use them.\n\nAs for key generation, we're deferring to built-in\n[crypto.getRandomValues](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues)\nwhich is considered cryptographically secure (CSPRNG).\n\n## Speed\n\nBenchmark results on Apple M2 with node v20:\n\n```\nsecp256k1\ninit x 68 ops/sec @ 14ms/op\ngetPublicKey x 6,750 ops/sec @ 148Î¼s/op\nsign x 5,206 ops/sec @ 192Î¼s/op\nverify x 880 ops/sec @ 1ms/op\ngetSharedSecret x 536 ops/sec @ 1ms/op\nrecoverPublicKey x 852 ops/sec @ 1ms/op\nschnorr.sign x 685 ops/sec @ 1ms/op\nschnorr.verify x 908 ops/sec @ 1ms/op\n\np256\ninit x 38 ops/sec @ 26ms/op\ngetPublicKey x 6,530 ops/sec @ 153Î¼s/op\nsign x 5,074 ops/sec @ 197Î¼s/op\nverify x 626 ops/sec @ 1ms/op\n\np384\ninit x 17 ops/sec @ 57ms/op\ngetPublicKey x 2,883 ops/sec @ 346Î¼s/op\nsign x 2,358 ops/sec @ 424Î¼s/op\nverify x 245 ops/sec @ 4ms/op\n\np521\ninit x 9 ops/sec @ 109ms/op\ngetPublicKey x 1,516 ops/sec @ 659Î¼s/op\nsign x 1,271 ops/sec @ 786Î¼s/op\nverify x 123 ops/sec @ 8ms/op\n\ned25519\ninit x 54 ops/sec @ 18ms/op\ngetPublicKey x 10,269 ops/sec @ 97Î¼s/op\nsign x 5,110 ops/sec @ 195Î¼s/op\nverify x 1,049 ops/sec @ 952Î¼s/op\n\ned448\ninit x 19 ops/sec @ 51ms/op\ngetPublicKey x 3,775 ops/sec @ 264Î¼s/op\nsign x 1,771 ops/sec @ 564Î¼s/op\nverify x 351 ops/sec @ 2ms/op\n\necdh\nâ”œâ”€x25519 x 1,466 ops/sec @ 682Î¼s/op\nâ”œâ”€secp256k1 x 539 ops/sec @ 1ms/op\nâ”œâ”€p256 x 511 ops/sec @ 1ms/op\nâ”œâ”€p384 x 199 ops/sec @ 5ms/op\nâ”œâ”€p521 x 103 ops/sec @ 9ms/op\nâ””â”€x448 x 548 ops/sec @ 1ms/op\n\nbls12-381\ninit x 36 ops/sec @ 27ms/op\ngetPublicKey 1-bit x 973 ops/sec @ 1ms/op\ngetPublicKey x 970 ops/sec @ 1ms/op\nsign x 55 ops/sec @ 17ms/op\nverify x 39 ops/sec @ 25ms/op\npairing x 106 ops/sec @ 9ms/op\naggregatePublicKeys/8 x 129 ops/sec @ 7ms/op\naggregatePublicKeys/32 x 34 ops/sec @ 28ms/op\naggregatePublicKeys/128 x 8 ops/sec @ 112ms/op\naggregatePublicKeys/512 x 2 ops/sec @ 446ms/op\naggregatePublicKeys/2048 x 0 ops/sec @ 1778ms/op\naggregateSignatures/8 x 50 ops/sec @ 19ms/op\naggregateSignatures/32 x 13 ops/sec @ 74ms/op\naggregateSignatures/128 x 3 ops/sec @ 296ms/op\naggregateSignatures/512 x 0 ops/sec @ 1180ms/op\naggregateSignatures/2048 x 0 ops/sec @ 4715ms/op\n\nhash-to-curve\nhash_to_field x 91,600 ops/sec @ 10Î¼s/op\nsecp256k1 x 2,373 ops/sec @ 421Î¼s/op\np256 x 4,310 ops/sec @ 231Î¼s/op\np384 x 1,664 ops/sec @ 600Î¼s/op\np521 x 807 ops/sec @ 1ms/op\ned25519 x 3,088 ops/sec @ 323Î¼s/op\ned448 x 1,247 ops/sec @ 801Î¼s/op\n```\n\n## Contributing & testing\n\n1. Clone the repository\n2. `npm install` to install build dependencies like TypeScript\n3. `npm run build` to compile TypeScript code\n4. `npm run test` will execute all main tests\n\n## Upgrading\n\nPreviously, the library was split into single-feature packages\n[noble-secp256k1](https://github.com/paulmillr/noble-secp256k1),\n[noble-ed25519](https://github.com/paulmillr/noble-ed25519) and\n[noble-bls12-381](https://github.com/paulmillr/noble-bls12-381).\n\nCurves continue their original work. The single-feature packages changed their\ndirection towards providing minimal 4kb implementations of cryptography,\nwhich means they have less features.\n\nUpgrading from noble-secp256k1 2.0 or noble-ed25519 2.0: no changes, libraries are compatible.\n\nUpgrading from noble-secp256k1 1.7:\n\n- `getPublicKey`\n  - now produce 33-byte compressed signatures by default\n  - to use old behavior, which produced 65-byte uncompressed keys, set\n    argument `isCompressed` to `false`: `getPublicKey(priv, false)`\n- `sign`\n  - is now sync; use `signAsync` for async version\n  - now returns `Signature` instance with `{ r, s, recovery }` properties\n  - `canonical` option was renamed to `lowS`\n  - `recovered` option has been removed because recovery bit is always returned now\n  - `der` option has been removed. There are 2 options:\n    1. Use compact encoding: `fromCompact`, `toCompactRawBytes`, `toCompactHex`.\n       Compact encoding is simply a concatenation of 32-byte r and 32-byte s.\n    2. If you must use DER encoding, switch to noble-curves (see above).\n- `verify`\n  - `strict` option was renamed to `lowS`\n- `getSharedSecret`\n  - now produce 33-byte compressed signatures by default\n  - to use old behavior, which produced 65-byte uncompressed keys, set\n    argument `isCompressed` to `false`: `getSharedSecret(a, b, false)`\n- `recoverPublicKey(msg, sig, rec)` was changed to `sig.recoverPublicKey(msg)`\n- `number` type for private keys have been removed: use `bigint` instead\n- `Point` (2d xy) has been changed to `ProjectivePoint` (3d xyz)\n- `utils` were split into `utils` (same api as in noble-curves) and\n  `etc` (`hmacSha256Sync` and others)\n\nUpgrading from [@noble/ed25519](https://github.com/paulmillr/noble-ed25519) 1.7:\n\n- Methods are now sync by default\n- `bigint` is no longer allowed in `getPublicKey`, `sign`, `verify`. Reason: ed25519 is LE, can lead to bugs\n- `Point` (2d xy) has been changed to `ExtendedPoint` (xyzt)\n- `Signature` was removed: just use raw bytes or hex now\n- `utils` were split into `utils` (same api as in noble-curves) and\n  `etc` (`sha512Sync` and others)\n- `getSharedSecret` was moved to `x25519` module\n- `toX25519` has been moved to `edwardsToMontgomeryPub` and `edwardsToMontgomeryPriv` methods\n\nUpgrading from [@noble/bls12-381](https://github.com/paulmillr/noble-bls12-381):\n\n- Methods and classes were renamed:\n  - PointG1 -> G1.Point, PointG2 -> G2.Point\n  - PointG2.fromSignature -> Signature.decode, PointG2.toSignature -> Signature.encode\n- Fp2 ORDER was corrected\n\n## Resources\n\n- [Learning fast elliptic-curve cryptography](https://paulmillr.com/posts/noble-secp256k1-fast-ecc/)\n- EdDSA\n  - [A Deep dive into Ed25519 Signatures](https://cendyne.dev/posts/2022-03-06-ed25519-signatures.html)\n  - [Ed25519 Deep Dive Addendum](https://cendyne.dev/posts/2022-09-11-ed25519-deep-dive-addendum.html)\n  - [Itâ€™s 255:19AM. Do you know what your validation criteria are?](https://hdevalence.ca/blog/2020-10-04-its-25519am)\n  - [Taming the many EdDSAs](https://csrc.nist.gov/csrc/media/Presentations/2023/crclub-2023-03-08/images-media/20230308-crypto-club-slides--taming-the-many-EdDSAs.pdf)\n    that describes concepts of Strong UnForgeability under Chosen Message Attacks and Strongly Binding Signatures\n  - [Cofactor Explained: Clearing Elliptic Curvesâ€™ dirty little secret](https://loup-vaillant.fr/tutorials/cofactor)\n  - [Surrounded by Elligators](https://loup-vaillant.fr/articles/implementing-elligator)\n- Pairings and BLS\n  - [BLS signatures for busy people](https://gist.github.com/paulmillr/18b802ad219b1aee34d773d08ec26ca2)\n  - [BLS12-381 for the rest of us](https://hackmd.io/@benjaminion/bls12-381)\n  - [Key concepts of pairings](https://medium.com/@alonmuroch_65570/bls-signatures-part-2-key-concepts-of-pairings-27a8a9533d0c)\n  - Pairing over bls12-381:\n    [fields](https://research.nccgroup.com/2020/07/06/pairing-over-bls12-381-part-1-fields/),\n    [curves](https://research.nccgroup.com/2020/07/13/pairing-over-bls12-381-part-2-curves/),\n    [pairings](https://research.nccgroup.com/2020/08/13/pairing-over-bls12-381-part-3-pairing/)\n  - [Estimating the bit security of pairing-friendly curves](https://research.nccgroup.com/2022/02/03/estimating-the-bit-security-of-pairing-friendly-curves/)\n\n### Demos\n\n- [Elliptic Curve Calculator](https://paulmillr.com/noble): add / multiply points, sign messages\n- [BLS threshold signatures](https://genthresh.com)\n\n### Projects using curves\n\n- HDkey libraries: [scure-bip32](https://github.com/paulmillr/scure-bip32), [bip32](https://github.com/bitcoinjs/bip32)\n- Social networks: [nostr](https://github.com/nbd-wtf/nostr-tools), [bluesky](https://github.com/bluesky-social/atproto)\n- Ethereum libraries:\n  - [ethereum-cryptography](https://github.com/ethereum/js-ethereum-cryptography)\n  - [micro-eth-signer](https://github.com/paulmillr/micro-eth-signer),\n    [ethers](https://github.com/ethers-io/ethers.js) (old noble),\n    [viem.sh](https://viem.sh),\n    [@ethereumjs](https://github.com/ethereumjs/ethereumjs-monorepo)\n  - [metamask's eth-sig-util](https://github.com/MetaMask/eth-sig-util)\n  - [gridplus lattice sdk](https://github.com/GridPlus/lattice-eth2-utils)\n- Bitcoin libraries:\n  - [scure-btc-signer](https://github.com/paulmillr/scure-btc-signer)\n  - [tapscript](https://github.com/cmdruid/tapscript)\n- Solana libraries: [micro-sol-signer](https://github.com/paulmillr/micro-sol-signer), [solana-web3.js](https://github.com/solana-labs/solana-web3.js)\n- Other web3 stuff:\n  - [scure-starknet](https://github.com/paulmillr/scure-starknet)\n  - [aztec](https://github.com/AztecProtocol/aztec-packages)\n  - [polkadot.js](https://github.com/polkadot-js/common), [drand-client](https://github.com/drand/drand-client), [moneroj](https://github.com/beritani/moneroj), [tronlib](https://github.com/CoinSpace/tronlib)\n- [protonmail](https://github.com/ProtonMail/WebClients) (old noble for now)\n- [did-jwt](https://github.com/decentralized-identity/did-jwt), [hpke-js](https://github.com/dajiaji/hpke-js),\n  [js-libp2p-noise](https://github.com/ChainSafe/js-libp2p-noise)\n- [ed25519-keygen](https://github.com/paulmillr/ed25519-keygen) SSH, PGP, TOR key generation\n- [secp256k1 compatibility layer](https://github.com/ethereum/js-ethereum-cryptography/blob/2.0.0/src/secp256k1-compat.ts)\n  for users who want to switch from secp256k1-node or tiny-secp256k1. Allows to see which methods map to corresponding noble code.\n- [BLS BBS signatures](https://github.com/Wind4Greg/BBS-Draft-Checks) following [draft-irtf-cfrg-bbs-signatures-latest](https://identity.foundation/bbs-signature/draft-irtf-cfrg-bbs-signatures.html)\n- [KZG trusted setup ceremony](https://github.com/dsrvlabs/czg-keremony)\n- See [full list of projects on GitHub](https://github.com/paulmillr/noble-curves/network/dependents).\n\n## License\n\nThe MIT License (MIT)\n\nCopyright (c) 2022 Paul Miller [(https://paulmillr.com)](https://paulmillr.com)\n\nSee LICENSE file.\n",
    "licenseText": "The MIT License (MIT)\n\nCopyright (c) 2022 Paul Miller (https://paulmillr.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the â€œSoftwareâ€), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED â€œAS ISâ€, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE."
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/@noble/curves/-/curves-1.2.0.tgz#92d7e12e4e49b23105a2555c6984d41733d65c35",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/@noble/curves/-/curves-1.2.0.tgz",
    "hash": "92d7e12e4e49b23105a2555c6984d41733d65c35",
    "integrity": "sha512-oYclrNgRaM9SsBUBVbb8M6DTV7ZHRTKugureoYEncY5c65HOmRzvSiTE3y5CYaPYJA/GVkrhXEoF0M3Ya9PMnw==",
    "registry": "npm",
    "packageName": "@noble/curves",
    "cacheIntegrity": "sha512-oYclrNgRaM9SsBUBVbb8M6DTV7ZHRTKugureoYEncY5c65HOmRzvSiTE3y5CYaPYJA/GVkrhXEoF0M3Ya9PMnw== sha1-ktfhLk5JsjEFolVcaYTUFzPWXDU="
  },
  "registry": "npm",
  "hash": "92d7e12e4e49b23105a2555c6984d41733d65c35"
}