{
  "manifest": {
    "name": "jsox",
    "version": "1.2.113",
    "description": "Java Script Object eXchange.",
    "keywords": [
      "jsox",
      "json",
      "macro",
      "template",
      "class",
      "recursive",
      "circular",
      "cyclic"
    ],
    "author": {
      "name": "d3x0r",
      "email": "d3x0r@github.com"
    },
    "contributors": [],
    "@std/esm": "cjs",
    "module": "lib/jsox.mjs",
    "main": "lib/jsox.js",
    "browser": "lib/jsox.es6.js.gz",
    "exports": {
      "import": "./lib/jsox.mjs",
      "require": "./lib/jsox.js",
      "browser": "./lib/jsox.es6.js.gz"
    },
    "bin": {
      "jsox": "lib/cli.js"
    },
    "files": [
      "lib/jsox.js",
      "lib/jsox.mjs",
      "lib/jsox.es6.js.gz",
      "lib/cli.js",
      "lib/require.js"
    ],
    "dependencies": {},
    "devDependencies": {
      "core-js": "latest",
      "rollup": "latest",
      "eslint": "latest",
      "nyc": "latest",
      "mocha": "latest",
      "chai": "latest",
      "acorn": "latest",
      "lint-staged": "latest",
      "@rollup/plugin-buble": "latest",
      "@rollup/plugin-commonjs": "latest",
      "@rollup/plugin-node-resolve": "latest",
      "@rollup/plugin-strip": "latest",
      "rollup-plugin-terser": "latest"
    },
    "nyc": {
      "ignore-class-method": [
        "log"
      ],
      "reporter": [
        "lcov",
        "text"
      ]
    },
    "scripts": {
      "xprepack": "npm run test-lite",
      "lint": "eslint --cache .",
      "mocha-lite": "mocha --experimental-loader=./lib/import.mjs --require ./lib/require.js --require test/bootstrap/node",
      "mocha": "mocha  --experimental-loader=./lib/import.mjs --require ./lib/require.js --require test/bootstrap/node --recursive",
      "nyc-lite": "nyc npm run mocha-lite",
      "nyc": "nyc npm run mocha-lite",
      "test-lite": "npm run lint && npm run build && npm run nyc-lite",
      "test": "npm run lint && npm run build && npm run nyc",
      "build": "node ./lib/cli.js -c package.jsox && rollup -c"
    },
    "homepage": "http://npmjs.org/package/jsox/",
    "license": "MIT",
    "repository": {
      "type": "git",
      "url": "https://github.com/d3x0r/jsox"
    },
    "arrayBuffer": {
      "0": 1963,
      "1": 47019,
      "2": 41515
    },
    "_registry": "npm",
    "_loc": "/data/data/com.termux/files/home/.cache/yarn/v6/npm-jsox-1.2.113-c5335ef27a18828da10ccde6b13c0a47081bd208-integrity/node_modules/jsox/package.json",
    "readmeFilename": "README.md",
    "readme": "# JSOX – JavaScript Object eXchange format.\n\n[![Build Status](https://travis-ci.com/d3x0r/JSOX.svg?branch=master)](https://travis-ci.com/d3x0r/JSOX)\n\n100% Compatible reader for JSON.  JSOX.stringify cannot generate JSON\ncompatible output; it would lose all the features anyway; use existing\n`JSON.stringify()` if required, all JSON(JSON3/JSON5/JSON6) is valid JSOX.\n\nJSOX adds Map, BigInt, Date, and TypeArray transport support, cyclic\nobjects, and includes keywords (5)'Infinity', (5)'NaN', (6)'undefined'.\n\nJSOX adds optional processing of `typed` data.  Type names can be applied\nto Objects, Arrays and Strings.  Type names are defined and provided with\nto/from JSOX handlers by users of this library.   The data, decoded as\nthe object '{}', array '[]', or string '\"\"' is passed to the fromJSOX \nhandler, and the resulting value returned as the decoded object.\n \nTyped-objects may also be emitted as a class-defintition and then class-references.\nA class-defintition defines the fields in the object, and a class-reference would\nprovide the values for each field respectively.\n\nA typed-object example: `v{ x, y } { a : v{1,2} }`, which decodes as `{ a : {x:1,y:2} }`.\nIt defines a template/class of object that has fields 'x', and 'y'.  Then\ndefines an object with a field A what is a object of type 'v', with values\n(1), and (2).  This example does not gain any visible savings; savings \ncomes when you have a lot of the same sort of record with the same field\nnames repeated often.\n\n\n * adds macro/class support for object field names.\n * adds support for bigint numbers; indicated with an 'n' suffix.\n * adds support for Date parsing and stringification; ISO dates as used are a sub-type of Number.\n * adds support for circular references.\n * typed-strings, typed-arrays, and typed-objects, for user defined types and to and from JSOX methods. [more](#jsox-typed-objects-typed-arrays-and-typed-strings)\n * C style commants; `//` and `/* */`.\n * string continuations using \\ at the end of the line removes the newline; Otherwise strings continue until the next quote.\n * `\"`, `'`, ` `` `, are all valid quote pairings, with no differnce in meaning, other than the quotes they contain.\n * adds optional underscores in numbers, allowing user formatting of log numbers.\n * fields are canonically ordered, so all objects that have the same field names will have their names in the same order.  Keys in Map()s are not ordered.\n * trailing commas are allowed, and silently ignored; however empty comma pairs in arrays will generate empty elements; and (throw an error in objects?).\n * and of course `o === JSOX.parse(JSON.stringify(o))` should always be exactly true.\n\n\n### Example Encoding\n\n```\nr = JSOX.stringify( o = { \n\ta: \"simple object\"\n\t, b:3\n\t, c:new Date()\n\t, d:123n\n\t, e:null\n\t, f:undefined\n\t, g:NaN\n\t, h:Infinity\n\t, i:-Infinity\n\t, j:-0.302 \n\t, k:new Uint8Array(9)}, null, 3 );\ncnsole.log( \"pretty:\", o, \"=\\n\", r );\n\n// -- output --\npretty:\n{\n      a: \"simple object\",\n      b: 3,\n      c: 2018-09-14T02:55:27-07:00,\n      d: 123n,\n      e: null,\n      g: NaN,\n      h: Infinity,\n      i: -Infinity,\n      j: -0.302,\n      k: u8[AAAAAAAAAAA=]\n}\n```\n\n**JSOX is a proposed replacement to JSON** that aims to make it easier for\n*humans to write and maintain* by hand, while also transporting the correct\ntype of the data.  Humans, for example, wouldn't hand-code a base64 encoding \nfor a TypedArray; however sending a mesh from a server to a client already \nprocessed as a typed buffer ready for WebGL consumption may be of use. \n\nThe class/tag support is entirely optional, and while it's goal is to reduce redundancy,\nwhich for large datasets of similar records can benefit, it has been argued\nthat gzip could just be used to reduce the size; However, this also reduces\nthe size of the data to be parsed on input, which gzip does not do.\n\nJSOX is a **(super-sub)set of JavaScript**, although adds **no new data types**,\nand **works with all existing JSON content**. Some features allowed in JSOX\nare not directly supported by Javascript; although all javascript parsable\nfeatures can be used in JSOX, except functions or any other code construct, \ntransporting only data save as JSON.  Most ES6 structure can be parsed, \nwith the extension of classes/macro-tags the reverse is not true.  It was true for\nJSON6.\n\nJSOX is a proprosal for an official successor to JSON, and JSOX stringified \ncontent *will not* work with existing JSON parsers. For this reason, JSOX \nfiles use a new .jsox extension. *(TODO: new MIME type needed too.)*\n\nThe code is a **reference JavaScript implementation** for both Node.js\nand all browsers. The code is derrived from JSON-6 sources.\n\n## Why\n\nBeyond the existing reasons for JSON5/JSON6 for their modifications; this\naddresses the biggest shortcoming of JSON, which is the repetitive and redundant\nspecification of field names; especially when lots of the same sort of object\nis represented.\n\nThis also aims to provide support for BigInt and Date format for less work\nat the application layer.  **A method for handling typed array object members\nshould also be impelemented**\n\n(Historic Why below)\n\nJSON isn’t the friendliest to *write*. Keys need to be quoted, objects and\narrays can’t have trailing commas, and comments aren’t allowed — even though\nnone of these are the case with regular JavaScript today.\n\nThat was fine when JSON’s goal was to be a great data format, but JSON’s usage\nhas expanded beyond *machines*. JSON is now used for writing [configs][ex1],\n[manifests][ex2], even [tests][ex3] — all by *humans*.\n\n[ex1]: http://plovr.com/docs.html\n[ex2]: https://www.npmjs.org/doc/files/package.json.html\n[ex3]: http://code.google.com/p/fuzztester/wiki/JSONFileFormat\n\nThere are other formats that are human-friendlier, like YAML, but changing\nfrom JSON to a completely different format is undesirable in many cases.\nJSON6’s aim is to remain close to JSON and JavaScript.\n\n\n## Features\n\nThe following is the exact list of additions to JSON’s syntax introduced by\nJSOX. **All of these are optional**.\n\n - Concise representation of dates and times including as much information as is\navailable for the timestamp(timezone).  \n\n - Supports encode and decode of BigInt numbers with no application overhead. \n - reduces overhead from none-requires quotes for identifiers.\n - can further reduce overall output size by using macro tags.\n\n## Caveats\n\nJSOX.stringify will produce output that JSON.parse cannot handle; JSOX.parse\ncan always handle JSON.stringify.\n\n### Summary of Changes from JSON6\n\n  - BigInt encoding\n  - ISO date/time Encoding/decoding (as part of Number format)\n  - Adds classes(revive user types) and macro tags to reduce redundant information.\n\n### Summary of Changes from JSON6/JSON\n\n  - Keyword undefined\n  - Objects/Strings back-tick quoted strings (no template support, just quotes); Object key names can be unquoted.\n  - Strings - generous multiline string definition; all javascript character escapes work. \\(\\x##, \\0###, \\u####, \\u\\{\\} \\)\n  - Numbers - underscore digit separation in numbers, octal and binary formats; all javascript number notations.\nAddtionally support leading 0 to interpret as octal as C, C++ and other languages support.\n  - Arrays - empty members\n  - Streaming reader interface\n  - (Twice the speed of JSON5; subjective)\n  - interprets non-breaking space as a space.\n\n\n## Additional support above JSON base\n\nAll items listed below are JSON5 additions if not specifed as JSON6.\n\n### \n\n### ArrayBuffer/TypedArray\n\n- (**JSOX**) Support transporting ArrayBuffer and TypedArray fields. This is implemented with constants as class user types applied prefixing and opening brace '\\[' and encoding the binary data as a base64 string(without quotes) before the closing ']'.\n  - these are prefix tags that can be applied.  u8, u16, cu8, u32, s8,s16, s32, f32, f64, ab; the array is a base64 string without quotes.\n  - Base64 is as dense as is feasible; it's a 33% loss; where utf8 encoding of random bytes is 50% loss.  Something like base127 would be 7 bytes to 8 encoded bytes; and potential length penalty of 5 bytes.\n\n### Objects\n\n- Object keys can be unquoted if they do not have ':', ']', '[', '{', '}', ',', any quote or whitespace (including non-breaking space, which on the human side of things looks the same), and do not begin like a number.\n\n- Object keys can be single-quoted, (**JSON6**) or back-tick quoted; any valid string \n\n- Object keys can be double-quoted (original JSON).\n\n- Objects can have a single trailing comma. Excessive commas in objects will cause an exception. '{ a:123,,b:456 }' is invalid.\n\n\n[mdn_variables]: https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide/Core_Language_Features#Variables\n\n### Arrays\n\n- Arrays can have trailing commas. If more than 1 is found, additional empty elements will be added.\n\n- (**JSON6**) Arrays can have comma ( ['test',,,'one'] ), which will result with empty values in the empty places.\n\n### Strings\n\n- Strings can be double-quoted (as per original JSON).\n\n- Strings can be single-quoted.\n\n- Strings can be back-tick (\\`) ([grave accent](https://en.wikipedia.org/wiki/Grave_accent)) -quoted.\n\n- Strings can be split across multiple lines; just prefix each newline with a\n  backslash. [ES5 [§7.8.4](http://es5.github.com/#x7.8.4)]\n\n- (**JSON6**) all strings will continue keeping every character between the start and end, this allows multi-line strings \n  and keep the newlines in the string; if you do not want the newlines they can be escaped as previously mentioned.\n\n### Numbers\n\n- (**JSOX**) BitInt numbers are stringified with suffix of 'n' as in ES(?), and implemented in V8(google/chrome/node) 2018/09/12.  BigInt number parsed with 'n' suffix.\n\n- (**JSON6**) Numbers can have underscores separating digits '_' these are treated as zero-width-non-breaking-space. ([Proposal](https://github.com/tc39/proposal-numeric-separator) with the exception that _ can preceed or follow . and may be trailing.)\n\n- Numbers can be hexadecimal (base 16).  ( 0x prefix )\n\n- (**JSON6**) Numbers can be binary (base 2).  (0b prefix)\n\n- (**JSON6**) Numbers can be octal (base 8).  (0o prefix)\n\n- (**JSON6**) Decimal numbers can have leading zeros.  (0 prefix followed by more numbers, without a decimal)\n\n- Numbers can begin or end with a (leading or trailing) decimal point.\n\n- Numbers can include `Infinity`, `-Infinity`, `NaN`. \n\n- Numbers can begin with an explicit plus sign.\n\n- Numbers can begin with multiple minus signs. For example '----123' === 123.\n\n### Dates\n\n- (**JSOX**) Encodes date time with local timestamp information to recover as much information as the original date contained.  Is treated as a subtype of Number parsing; and are stored without quotes.\n\n### Keyword Values\n\n- (**JSON6**) supports 'undefined' in addition to 'true', 'false', 'null'.\n\n### Comments\n\n- Both inline (single-line using '//' (todo:or '#'?) ) and block (multi-line using \\/\\* \\*\\/ ) comments are allowed.\n- (**JSOX**) single line comments using '#'; imposes required quoting for '#' as a field name.\n\n\n```\n// simple example, array buffer with 8 bytes\nvar ab = new ArrayBuffer([0,1,2,3,4,5,6,7]);\nconsole.log( JSOX.stringify( {ab:new Float32Array(ab)} ) );\n\n// example output\n{ab:f32[AAECAwQFBgc=]}\n```\n\n#### Base64 Character Set\n\nThe following defines the characters used for base64 encoding and decoding.\n\n```\n\tconst encodings = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789$_'\n   // previous to 1.2.106\n\t//const encodings = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n\tconst decodings = { '~':-1\n\t\t,'=':-1\n\t\t,'$':62\n\t\t,'_':63\n\t\t,'+':62\n\t\t,'-':62\n\t\t,'.':62\n\t\t,'/':63\n\t\t,',':63\n\t};\n\n```\n\nThe high value characters have multiple possible variations based on evaluation of what was used in wikipedia; forming the most inclusive subset.\n`~` or `=` may be used for string termination, or early string length.\n\n\n#### Base64 vs UTF-8 Encoding\n\nUTF-8, for character 0-127 requires 1 byte; 128-255 requires 2 bytes.  For random data 0-255, 1.5 bytes will, on average, bt used\nto represent the string.  So this is 150% larger than the original string.  Even if like a base 2^40 bits, which would encode 5 bytes \ninto a single (very extended) utf8 encoding, each byte has the prefix of 2 bits `10xx xxxx`, which gives 6 bits per byte used.\n\nBase64 is 6 bits per byte used, so instead of having a complex encoder, base64 is the optimal of 3:4 byte expasion (133%) which is \nthe ideal that extra-long UTF8 encoding coule reach.\n\nAn alternative might be a base128 encoding, which would be close to utf-8, but would actually require 129 characters, one to indicate\nthe bytes that are unused.  7 bytes expand to 8, gathering the top bit of each of the 7 bytes of each one into one more byte; it could\nbe an optimal encoding using code points 0-128 (128 being the end terminator like '=' in base64).  But, this also mean that up to 5\nbytes of waste may be included.  That is incomplete values at the end of the string have to be marked as unused.\n\n## Pretty Images\n\nImage produced by [EBNF Visualizer (Windows)](http://dotnet.jku.at/applications/Visualizer/#Down)\nfrom [jsox.ebnf](jsox.ebnf)\n![JSOX Value BNF](JSOX-Value.GIF \"JSOX Values\")\n![JSOX Value BNF](Val.GIF \"JSOX Values\")\n![JSOX Parser BNF](parser.GIF \"JSOX Parser\")\n  \n\n## Example conversion\n\nThe following is a contrived example, but it illustrates most of the features:\n\n```js\n{\n    foo: 'bar',\n    while: true,\n    nothing : undefined, // why not?\n\n    this: 'is a \\\nmulti-line string',\n\n    thisAlso: 'is a\nmulti-line string; but keeps newline',\n\n    // this is an inline comment\n    here: 'is another', // inline comment\n\n    /* this is a block comment\n       that continues on another line */\n\n    hex: 0xDEAD_beef,\n    binary: 0b0110_1001,\n    decimal: 123_456_789,\n    octal: 0o123,\n    decimal: 001234, // with lead 0\n    half: .5,\n    delta: +10,\n    negative : ---123,\n    to: Infinity,   // and beyond!\n\n    ,,,,,,  // some empty fields...\n\n    finally: 'a trailing comma',\n    oh: [\n        \"we shouldn't forget\",\n        'arrays can have',\n        'trailing commas too',\n    ],\n}\n```\n\nThis implementation’s own [package.jsox](package.jsox) is more realistic:\n\n```js\n// This file is written in JSOX syntax, naturally, but npm needs a regular\n// JSON file, so compile via `npm run build`. Be sure to keep both in sync!\n\n{\n    name: 'JSOX',\n    version: '0.1.105',\n    description: 'JSON for the ES6 era.',\n    keywords: ['json', 'es6'],\n    author: 'd3x0r <d3x0r@github.com>',\n    contributors: [\n        // TODO: Should we remove this section in favor of GitHub's list?\n        // https://github.com/d3x0r/JSOX/contributors\n    ],\n    main: 'lib/JSOX.js',\n    bin: 'lib/cli.js',\n    files: [\"lib/\"],\n    dependencies: {},\n    devDependencies: {\n        gulp: \"^3.9.1\",\n        'gulp-jshint': \"^2.0.0\",\n        jshint: \"^2.9.1\",\n        'jshint-stylish': \"^2.1.0\",\n        mocha: \"^2.4.5\"\n    },\n    scripts: {\n        build: 'node ./lib/cli.js -c package.JSOX',\n        test: 'mocha --ui exports --reporter spec',\n            // TODO: Would it be better to define these in a mocha.opts file?\n    },\n    homepage: 'http://github.com/d3x0r/JSOX/',\n    license: 'MIT',\n    repository: {\n        type: 'git',\n        url: 'https://github.com/d3x0r/JSOX',\n    },\n}\n```\n\n\n## Community\n\nJoin the [Google Group](http://groups.google.com/group/JSOX) if you’re\ninterested in JSOX news, updates, and general discussion.\nDon’t worry, it’s very low-traffic.\n\nThe [GitHub wiki](https://github.com/d3x0r/JSOX/wiki) (will be) a good place to track\nJSOX support and usage. Contribute freely there!\n\n[GitHub Issues](https://github.com/d3x0r/JSOX/issues) is the place to\nformally propose feature requests and report bugs. Questions and general\nfeedback are better directed at the Google Group.\n\n\n## Usage\n\nThis JavaScript implementation of JSOX simply provides a `JSOX` object just\nlike the native ES5 `JSON` object.\n\nTo use from Node:\n\n```sh\nnpm install jsox\n```\n\n```js\nvar JSOX = require('jsox');\n```\n\nTo use in the browser (adds the `JSOX` object to the global namespace):\n\n```html\n<script src=\"node_modules/jsonx/lib/jsox.js\"></script>\n```\n\nThen in both cases, you can simply replace native `JSON` calls with `JSOX`:\n\n```js\nvar obj = JSOX.parse('{unquoted:\"key\",trailing:\"comma\",}');\nvar str = JSOX.stringify(obj); /* uses JSON stringify, so don't have to replace */\n```\n\n|JSOX Methods | return | parameters | Description |\n|-----|-----|-----|----|\n|parse| the first value| (string [,reviver]) | supports all of the JSOX features listed above, as well as the native [`reviver` argument][json-parse]. |\n|stringify| string | ( value[,replacer[,space]] ) | converts object to JSOX.  [stringify][json-stringify] |\n|stringifier |  Stringifier(methods below)| () | Gets a utility object that can stringify.  The object can have classes defined on it for stringification |\n|escape | string | ( string ) | substitutes \", \\, ', and \\` with backslashed sequences. (prevent 'JSON injection') |\n|begin| Parser(methods below) |(cb [,reviver] ) | create a JSOX stream processor.  cb is called with (value) for each value decoded from input given with write().  Optional reviver is called with each object before being passed to callback. |\n|toJSOX  | none | (name,Function/Class,toCb) | For each object that matches the prototype, the name is used to prefix the type; and the cb is called to get toJSOX.  | Instead of setting prototype extensions, provides a way to register formatters for prototypes.  These are shared for all stringifier instances, and will throw an exception if duplicate set happens. |\n|fromJSOX| none | (name,Function/Class,fromCb) | fromCb is called whenever the type 'name' is revived.  The type of object following the name is passd as 'this'. Will throw an exception if duplicate set happens. |\n|registerToFrom  | none | (name,Function/Class,toCb, fromCb) | register both to and from for the same name. |\n|reset| none | () | Reset to/from types on JSOX global parser and stringifier. (should be reserved for tests) |\n\n\n|Stringifier method | return | parameters | Description |\n|-------|------|-----|----|\n|stringify | string | (value[,replacer[,space]] ) | converts object to JSOX attempting to match objects to classes defined in stringifier.  [stringify][json-stringify] |\n|toJSOX  | none | (name,Function/Class,toCb) | For each object that matches the prototype, the name is used to prefix the type; and the cb is called to get toJSOX.  | Instead of setting prototype extensions, provides a way to register formatters for prototypes.  These only applied to this one stringifier instance, and will throw an exception if duplicate set happens. |\n|setQuote | none | ( quote ) | the argument passed is used as the default quote for strings and identifiers as required. |\n|defineClass | none | ( name, object ) | Defines a class using name 'name' and the fields in 'object'.  This allows defining for some pre-existing object; it also uses the prototype to test (if not Object), otherwise it matches based on they Object.keys() array. |\n\n\n|Parser Methods | parameters | Description |\n|-----|-----|-----|\n|write | (buffer) | add data to the parser stream |\n|reset| () | When an error is thrown from parsing a stream, the parser must be reset using `reset()`, otherwise it will continue throwing an error. |\n|parse | (buffer) | use a parser instance to parse a single message |\n|currentRef | () | Returns an object containing `{o:, f:}` where `o` is the object containing the field being revived, and `f` is the name of the field being revive; together this pair makes a reference to a value.  |\n|fromJSOX| (name,Function/Class,fromCb) | fromCb is called whenever the type 'name' is revived.  The type of object following the name is passd as 'this'. Will throw an exception if duplicate set happens. |\n\n\n#### Registering `toJSOX` : `JSOX.toJSOX()` or `stringifier.toJSOX()`\n\n`function toJSOX( name, Type, customEmitterCallback )`\n\n  - name is a string\n  - Type is the type which should be encoded as this name.\n  - customEmitterCallback is called when one of these types is encountered.  The callback should return a string\n    to emit.\n\n`toJSOX()` registers a handler to convert a type to JSOX.  This method is used to avoid modification of prototypes; would require instead \nthat ojects that have a toJSOX know of the JSOX module instead.  The result of the callback should be a string, and is up to the\ntoJSOX method to include quotes if it is a string value.  Any string may result that is valid JSOX.\n\nRegsitering the same name more than once throws an error.\n\n``` js\nfunction stringTest() {\n\tthis.a = 3;\n\tthis.b = 4;\n}\nstringifierTest.prototype.toString = function(stringifier) {\n\t// \n\treturn `a is ${this.a} b is ${this.b}`;\n}\n\nJSOX.toJSOX( \"stringTest\", stringTest, function(stringifier) { return '\"' + this.toString() + '\"' } );\n```\n\nThe callback specified is passed the current value to stringify as `this`, and the current stringifier is passed\nas the first argument.  If the structure contains cyclic references, the provided stringifier is required to be used\ninstead of `JSOX.stringify()` or a new instance of a stringifier when encoding the sub-members of this object; otherwise,\nthe references do not properly refer to the root of the object.\n\n\n#### Registering `fromJSOX` : `JSOX.fromJSOX()` or `parser.fromJSOX()`\n\n`fromJSOX( name, type, callback )`\n\n  - name is the tag text which triggers reviving this type.\n  - type is the class or function used to create a `new type()`.  The instance is always created with empty parameters.\n  - callback(field,val)  is called with `this` set to the object of the type specified, and `field` set as the current field name being revived, `val` is the value being set into the field.\n    If field is `undefined` then this is the end of all fields being added to the object, and the `this` object may be changed to a different object; usually `if( field === undefined ) return this;`.\n\nThe callback is called after objects are completely revived; it is called when an array value is initially created, or immediately after resolving any other value.\n\nRegisters a handler to convert recovered string, array or object from JSOX.  The converted data from the JSOX stream is passed as\n'this'.  The result of the callback may be any type of value; the resulting value is used instead of the data converted from JSOX.\n\nRegistering the same name more than once throws an error.\n\n``` js\n// this epects a string, as indicated by the above toJSOX output.\n\nfunction stringTest() {\n}\n\n// if a field callback is specified, the function must either result with\n// undefined, which prevents setting the value internally, or return the same\n// or a new value for the value.\n// if the field is 'undefined' then must instead return 'this' or a new object \n// to take the place of this one.\n\nstringTest.fromJSOX = function(field,val) {\n\tif( field ) {\n\t\tconsole.log( \"Resuurect from String:[%s]\", this /*string*/ );\n\t} else\n\t\treturn new stringTest( this );\n}\nJSOX.fromJSOX( \"stringTest\", stringTest, stringTest.fromJSOX );\n```\n\n#### Register toJSOX and fromJSOX for the same type\n\nRegisters both to and from methods or a spsecified name, using the specified prototype to match during stringify.\nInternally, calls the above functions with the parameters split as appropriate.\n\nRegsitering the same name more than once for From or To throws an error.\n\n``` js\n\nJSOX.registerToFrom( \"stringTest\", stringTest\n\t, function() { return '\"' + this.toString() + '\"' }\n\t, function() {\n\t\tconsole.log( \"Resuurect from String:[%s]\", this /*string*/ );\n\t\treturn new stringTest( this );  // some stringTest class with string initializer\n\t}\n);\n```\n\n### JSOX typed-objects, typed-arrays, and typed-strings\n\ntyped-data is represented in the JSOX stream as \\<identifier\\>\\[data\\].  For objects, this is a document compression technique,\nwhich reduces the size of data to process.  For arrays, internally, fixed types represent ES6 TypedArray types (u8,s8, u16,f32,etc);\nAnother internal type is 'ref' which uses the array to have a list of element identifiers that define the path to the original object\nreference.  Another, simple variation is to implement typed-strings, which allows `color\"0x1234568\"` to have a `fromJSOX` method that\nis passed the string, and can result with a color object.\n\nIn each case, in the following example JSOX, the same 'color' fromJSOX \nmethod will be called.  It will be invoked with a string, with an array, \nwith an object, with an object, and with an object respectively.\n\n```\nvar JSOX= require( \"JSOX\" );\n\nfunction Color() {\n\tthis.r = 100;\n        this.g = 150;\n        this.b = 20;\n}\n\n// notice that the literal quotes to result as output are returned here.\n// this allows the encoder to use an object {}, an array [] or a string \"\"\n// to pass to the reviver function. \nsack.JSOX.registerToFrom( \"color\", Color.prototype, function() { return '\"#'+this.r.toString(16)+this.g.toString(16)+this.b.toString(16)+ '\"'; }\n           , function() { return '\"#'+this.r.toString(16)+this.g.toString(16)+this.b.toString(16)+ '\"'; }\n           );\n\nvar c = new Color();\n\nJSOX.stringify( c ) ); // result is 'color\"#649614\"'\nJSOX.parse( JSOX.stringify( c ) ); // result is   'Color { r: 100, g: 150, b: 20 }'  (console.log)\n\n```\n\n```\n\n// this are all variations which may be used to revive a color object\ncolor\"0x12345678\"                   // typed-string\ncolor[0x12,0x34,0x56,0x78]          // typed-array\n\n// at a root level, the first 'color' definition encountered\n// is used to create a field-name map.  Then later usages\n// sould only specify the values.\ncolor{r,g,b,a}            // typed-object definition\ncolor{0x12,34,0x56,0x78}  // typed-object subsequent usage\n\n// if no typed-object definition is rquired, then \n// the typed-object must never be used at a root level.\n\n{ a : color{r:0x12,g:0x34,b:0x56,a:0x78} } // object containing typed-object fromJSOX only, no pre-field-definition\n[ color{r:0x12,g:0x34,b:0x56,a:0x78} ]     // array containing typed-object fromJSOX only, no pre-field-definition\n```\n\nTyped strings have a caveat; at a root level, strings which are typed, MUST have \nunquoted-identifier strings indicating their type.  Because the closing quote is \na definitive end-of-data marker, quoted strings at a root level always emit as a \ncompleted string; This also requires no space between the unquoted-identifier string\nand the quoted data string. \n\nTyped-object and typed-arrays also require the identifer or string used for their\ntype information not be followed by a space before the opening '{', '\\[' or quoted \nstring. \n\n### More on Classes/Macro Tags - typed-object and typed-array\n\nMacro Tags are similar to class names, but define a set of field names to use for each subsequent use of the same number.\nThe names used for class names and for Macro tags may overlap, and then the macro objects are also revived as specified\nuser types.  If only a Macro Tag is used, then all objects revived with that tag have the same prototype, which may be \nextended in-place for all such objects.\n\nThe definition of a Macro Tag is an identifer at the top level (before the JSOX data) followed immediately by an open brace ('{'),\nwhitespace is not allowed.  Within the open brace '{' until the close brace '}' is a list of names separated by commas.\nIf a colon(`:`) is encountered before the first comma(`,`) , then instead of behaving as a Macro definition, the\nobject is revived as a named user type class instead. \n\nAll subsequent references to the defined tag are `<identifier>` followed by '{' until the close '}', is a list of comma separated values.  \nEach value is assign the name in the order it was defined at the definition.  This is effectively a 'zip' operation between the names\nspecfied at the start, and the values specified later.\n\nAll objects created with a class/tag definition shares the same prototype.\n\n``` bnf\ntagdef : identifier '{' identifier [ ',' identifier ] ... '}'\n\n```\nA class revival is similar, but includes both the identifer and value for each entry.\n\n``` bnf\nuserType : identifier '{' identifier ':' value [ ',' identifier ':' value ] ... '}'\n```\n\nUsage of tags is done by specifing their identifer followed by an open brace '{' in the value \nfield of an object definition; or at a top level referencing the same tag name already defined.\nFor each field defined in the class, a value is expected.  If a value is not found, the field\nwill not be added, as if receiving `field:undefined`.\n\n``` bnf\ntag usage : ':' identifier '{' value [ ',' value ]... '}' \n```\n\n\n``` js\n//-- the following...\na{ firstField, secondField }\na{ 1, 2 }\n//-- results as\n{ firstField : 1, secondField : 2 }\n\n\n//-- the following...\na { firstField, secondField }\n[ a { 1, 2 }, a(5,6), a(\"val1\",\"val2\") ]\n//-- results as\n[ { firstField : 1, secondField : 2 }, { firstField : 5, secondField : 6 }, { firstField : \"val1\", secondField : \"val2\" } ]\n\n```\n\nImplementation of tags allows apply a class to arrays.  Arrays have a class of ArrayBuffer, or other TypedArray type.  The\nrepresentation path in an array and a reference type for the array. This allows circular encoding.\n\n``` js\n// this is a string with a reference.\n{company:{name:\"Example.com\",employees:[{name:\"bob\"},{name:\"tom\"}],manager:ref[\"company\",\"employees\",0]}}\n\n// The above 'ref[]' gets resolved into the same employee object...\nOUT: ./file6.jsox { company:\n   { name: 'Example.com',\n     employees: [ /*a*/{ name: 'bob' }, { name: 'tom' } ],\n     manager: /*a*/{ name: 'bob' } } }\n```\n\n\n\n\n### JSOX Streaming\n\nA Parser that returns objects as they are encountered in a stream can be created.  `JSON.begin( dataCallback, reviver );`  The callback is called for each complete object in a stream of data that is passed.  \n\n`JSOX.begin( cb, reviver )` returns an object with a few methods.\n\n| Method | Arguments | Description | \n|:---|:---|:---|\n| write | (string) | Parse string passed and as objects are found, invoke the callback passed to `begin()` Objects are passed through optional reviver function passed to `begin()`. |\n| \\_write | (string,completeAtEnd) | Low level routine used internally.  This does the work of parsing the passed string. Returns 0 if no object completed, 1 if there is no more data, and an object was completd, returns 2 if there is more data and a parsed object is found.  if completedAtEnd is true, dangling values are returned, for example \"1234\" isn't known to be completed, more of the number might follow in another buffer; if completeAtEnd is passed, this iwll return as number 1234.  Passing empty arguments steps to the next buffered input value. |\n| value | () | Returns the currently completed object.  Used to get the completed object after calling \\_write. |\n| reset | () | If `write()` or `_write()` throws an exception, no further objects will be parsed becuase internal status is false, this resets the internal status to allow continuing using the existing parser.  ( May require some work to actually work for complex cases) |\n| usePrototype | (className,protoType) | configure what prototypes to use for class recovery |\n\n\n``` js\n   // This is (basically) the internal loop that write() uses.\n   var result\n   for( result = this._write(msg,false); result > 0; result = this._write() ) {\n      var obj = this.value();\n      // call reviver with (obj)\n      // call callback with (obj)\n   }\n```\n\n``` js\n// Example code using write\nfunction dataCallback( value ) {\n\tconsole.log( \"Value from stream:\", value );\n}\nvar parser = JSON.begin( dataCallback );\n\nparser.write( '\"Hello ' );   // a broken simple value string, results as 'Hello World!' \nparser.write( 'World!\"' );\nparser.write( '{ first: 1,' );   // a broken structure\nparser.write( ' second : 2 }' );\nparser.write( '[1234,12');  // a broken array across a value\nparser.write( '34,1234]'); \nparser.write( '1234 456 789 123 523');  // multiple single simple values that are numbers\nparser.write( '{a:1} {b:2} {c:3}');  // multiple objects\n\nparser.write( '1234' );  // this won't return immediately, there might be more numeric data.\nparser.write( '' ); // flush any pending numbers; if an object or array or string was split, throws an error; missing close.\n\nparser.write( '1234' ); \nparser.write( '5678 ' );  // at this point, the space will flush the number value '12345678' \n\n```\n\n\n\n### Extras\n\nIf you’re running this on Node, you can also register a JSOX `require()` hook\nto let you `require()` `.jsox` files just like you can `.json` files:\n\n```js\nrequire('jsox/lib/require');\nrequire('./path/to/foo');   // tries foo.jsox after foo.js, foo.json, etc.\nrequire('./path/to/bar.jsox');\n```\n\nThis module also provides a `jsox` executable (requires Node) for converting\nJSOX files to JSON:\n\n```sh\njsox -c path/to/foo.jsox    # generates path/to/foo.json\n```\n\n## Other Implementations\n\nThis is also implemented as part of npm [sack.vfs](https://www.npmjs.com/package/sack.vfs)\nas a native code node.js addon.  This native javascript version allows usage in browsers.\n\nC/C++ Amalgam version [jsox-wasm](https://www.github.com/d3x0r/jsox-wasm)\n\nPossible release of amagamated source, native Node Addon (standalone).  (Amalagmanted source is for now in jsox-wasm repository).\n\nWorking on a WebAssembly version. [jsox-wasm](https://www.github.com/d3x0r/jsox-wasm)\nThe overhead of the string exchange between WASM and JS (strings, key names of objects), defeats any benefit from 0 garbage collected/managed parsing.\n\n## Benchmarks\n\n~~This is as fast as the javascript version of Douglas Crockford's reference implementation [JSON implementation][json_parse.js] for JSON parsing.~~\n\n~~This is nearly double the speed of [JSON5](http://json5.org) implementation that inspired this (which is half the speed of Crockford's reference implementation).~~\n\n~~This is half the speed of the sack.vfs native C++ node addon implementation (which itself is half the speed of V8's native code implementation, but they can cheat and build strings directly).~~\n\n\n## Development\n\n```sh\ngit clone https://github.com/d3x0r/jsox\ncd jsox\nnpm install\nnpm test\n```\n\nAs the `package.jsox` file states, be sure to run `npm run build` on changes\nto `package.jsox`, since npm requires `package.json`.\n\nFeel free to [file issues](https://github.com/d3x0r/jsox/issues) and submit\n[pull requests](https://github.com/d3x0r/JSOX/pulls) — contributions are\nwelcome. If you do submit a pull request, please be sure to add or update the\ntests, and ensure that `npm test` continues to pass.\n\n## Continuous Integration Testing\n\nTravis CI is used to automatically test the package when pushed to github. Recently .mjs tests have been\nadded, and rather than build a switch to test `mocha/test/*.js`  instead of just `*`, and depending on node version\nswitch the test command which is run, the older platforms were removed from testing.\n\nThe product of this should run on very old platforms also, especially `node_modules/jsox/lib/jsox.min.js`.\n\n\n## Changelog\n- 1.2.114 (inprogress)\n- 1.2.113\n    - Add higher resolution Date type called DateNS; which adds a 'ns' field which is a number of additional nanoseconds on top of the timestamp.  (JS Specific issue; ISO-8601 date format may be of any precision)\n- 1.2.112\n    - add check for `\\ufeff` in stringifier for identifiers; because of BOM legacy usage unquoted ZWNBSP has to be counted as just whitespace. (especially considering multiple files might have been concatenated?)\n- 1.2.111\n    - fixes travis tests; latest mocha/coverage slows benchmark tests by 10x.\n- 1.2.110\n    - Fix packaging error.\n- 1.2.109\n    - fixed vertical tab character parsing.\n    - fixed hex numbers with `[a-f][A-F]` characters.\n    - added reset() method for tests to reset global JSOX type registrations.\n    - added 1.2.108 named tests.\n    - Added `RegExp` support; ~~encodes as `Ρεχ` string type;  `JSOX.parses(\"Ρεχ'a+'\") === /a+/`~~\n       - encode as `regex` instead of `Ρεχ`; is actually 1 byte shorter, and more familiar. `JSOX.parses(\"regex'a+'\") === /a+/`, `JSOX.stringify(/a+/) === /\"regex'a+'\"/`\n- 1.2.108\n    - Refix base64, which failed to quote strings that looked like numbers.\n    - Clear array buffer typed variable when resolving the typed array; leaked to next parse.\n- 1.2.107\n    - Updated document about CI tests.\n    - Enable Travis CI integration.\n    - Reference arrays don't result with the same object; reduce frequency of warning message.\n    - Remove automatic guess promoting numbers to bigints, floats can also be pretty big.\n- 1.2.106\n    - fix regression in stringifying binary array objects; removing the quotes caused the '/' to be interpreted as a comment.\n    - update documentation about base64 encoding\n    - replace '+/' with '$_' as the high value strings emitted.  Older versions will already accept this encoding.\n- 1.2.105\n    - Fix losing array containing typed objects.\n    - Pass stringifier to toJSOX method.\n    - Added compatibility tests between sack.vfs node plugin and JS version.\n    - Fixed issues reviving references (new test), and replacing/providing values.\n- 1.2.104\n    - Throw error while parser is in error state and new writes() are called.\n    - allow '+' prefix to numbers\n    - Fix fromJSOX class revival handling; call per-field.\n    - Added beginning of stringify tests (coverage).\n- 1.2.103\n    - additional reference path revival fix.\n- 1.2.102\n    - added automated test notes\n    - Added formal reference revival test; a different recursive variation of reference which failed.\n    - refactored to remove 'element_array' special case tracking variable; standardize on just 'elements' instead.\n- 1.1.123 (published as 1.2.101)\n    - Added automated mocha tests; (ported from JSON6).\n    - Fixed some parsing issues exposed by tests around unicode whitespace handling and more.  \n    - Throw an error when a invalid date is created.\n    - Most fixes were in handling badly formatted data either with exceptions, or accepting more badly formatted input as valid.\n- 1.1.122\n    - Remove option SUPPORT_LEAD_ZERO_OCTAL; JS \"strict\" errors on lead zeros; and Number() converts lead zeros as decimal; removes custom decoding.\n- 1.1.121\n    - fix parsing {op:f,}.  Generalize unquoted string recovery.\n- 1.1.120\n    - revert UTC time change; keep accuracy.\n- 1.1.119\n    - missed the toFullYear -> toUTCFullYear of the date.\n- 1.1.118\n    - treat \\u00A0 the same as a ' ' (space).  Visually they are the same, so in the interst of being human readable, it would make sense the machine should read it the same way.\n    - fix failure to encode millisecond into timestamp.\n- 1.1.117\n    - Fixes reviving a class in a class in a map referencing the class in the map, and then finishsing map.class.class before finishing map.class \n    - Fixes reviving references after another prototype revival.  (map followed by a key with a reference).\n    - restore handling empty object arguments `{,,a:3,,,,,b:4,,,}` results in `{a;3,b:4}`.\n    - Added some tests which caused the above failures; updated ancient tests to account for \n    - top level `<string><object>` in a stream to seprate with `<string><ws><object>` which is valid for the test.\n- 1.1.116\n    - Provides 'browser', and 'module' entry points.  Improves module support.\n    - Fixes an issue with references in arrays after other objects.\n    - Fixes unclosed ref array state, for `ref[], []`.\n    - Resolves an internal state meaning that overlapped meaning of default and pushed.\n- 1.1.115\n    - publish minor doc updates\n- 1.1.114\n    - Cricial Fix - clear arrayType when opening a new object or array (circular object decode)\n    - Reference fix when referencing the root node.\n- 1.1.113\n    - fix leftover test code in require.js.\n- 1.1.111\n    - fix packaging.\n- 1.1.101\n    - Minor patch to get a long miner version\n    - fixed base64 decoding to handle terminations better.\n- 1.1.1\n    - added Map() builtin type for JS which is type 'map'.\n    - Fixed expression which quoted words with 'S' or 's' in them.\n    - Fixed Known array types.\n- 1.1.0 \n    - Added stringifier/parser instance specific registrations for ToJSOX and FromJSOX handlers.\n    - removed unicode non-identifier check, prefering instead just the set of structure characters (basically anything which is not caught before the end begins an identifier).  This simplifies testing field names for encoding/stringification.\n- 1.0.8 - Sort object fields case insensitively; standardize field ordering.\n- 1.0.7 - Fixed some stream parsing issues with identifiers.\n- 1.0.6 - just updated build products\n- 1.0.5 \n    - Fix streaming ability\n    - consequtive strings only have whitespace to separate them, so identifiers for defining typed-objects cannot have whitespace between them and '{'.\n    - (reverted)implement test for non-identifier characters to quote field strings (or not).  Implement reading non-identifier characters, and fault if identifier is unquoted and has such a character.\n    - implement typed-strings, which can be used to trigger constructors which accept single strings.\n    - update readme with typed-strings, typed-arrays, and typed-objects.\n    - performance fix; was keeping parser objects forever.\n- 1.0.4 - Be more forgiving about platforms not having BigInt native support.\n- 1.0.3 - Add ability to register prototypes to use for decoding.\n- 1.0.2 - Issue with mutiple leading and trailing spaces. Fix collecting streams of numbers.  Fix an issue with nested classes.  Add circular reference support.\n- 1.0.1 - Removed modification of object prototypes; instead track object prototype to formatting function in a WeakMap().  Fixed class expansion.  Make objects of a class share the same prototype.\n- 1.0.0 - Intial Release.\n\n## License\n\nMIT. See [LICENSE.md](./LICENSE.md) for details.\n\n## Credits\n\nhttp://github.com/json5/json5  Inspiring this JSON6 and subsequently this project.\n\n[Douglous Crockford json parse]: https://github.com/douglascrockford/JSON-js/blob/master/json_parse.js\n\n\n\n",
    "licenseText": "MIT License\n\nCopyright (c) 2017+ d3x0r (github id)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n------\nIf you make notable improvments/fixes I would appreciate a best effort to share\nsuch changes; or at least share that there might be a possibility of improvement.\nThere is no penalty if nothing is shared.  I attempted to get JSON5 maintainers\nto implement the changes before re-implementing, but they were unresponsive.\nBesides this implementation is twice the speed, so it benefits a lot from not \nbeing based on their code in the first place.  It's only based on the description\nof their extensions to original JSON format."
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/jsox/-/jsox-1.2.113.tgz#c5335ef27a18828da10ccde6b13c0a47081bd208",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/jsox/-/jsox-1.2.113.tgz",
    "hash": "c5335ef27a18828da10ccde6b13c0a47081bd208",
    "integrity": "sha512-Qvfxml1nIeG5mvuxgmAocz8fBtjnP9E92gvS76gS8akZs3cGPmq6gqNL+ashjsWj2ETt81qB1aWrWdEMRw3LEA==",
    "registry": "npm",
    "packageName": "jsox",
    "cacheIntegrity": "sha512-Qvfxml1nIeG5mvuxgmAocz8fBtjnP9E92gvS76gS8akZs3cGPmq6gqNL+ashjsWj2ETt81qB1aWrWdEMRw3LEA== sha1-xTNe8noYgo2hDM3msTwKRwgb0gg="
  },
  "registry": "npm",
  "hash": "c5335ef27a18828da10ccde6b13c0a47081bd208"
}