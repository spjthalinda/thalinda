import { arrayify, last, DEFAULT_EXTENSIONS, MARKDOWN_EXTENSIONS, getPhysicalFilename, performSyncWork } from 'eslint-mdx';
import { processors as processors$1 } from 'eslint-plugin-markdown';
import path from 'path';

const base = {
  parser: "eslint-mdx",
  parserOptions: {
    sourceType: "module",
    ecmaVersion: "latest"
  },
  plugins: ["mdx"],
  processor: "mdx/remark",
  rules: {
    "mdx/remark": 1,
    "no-unused-expressions": 2
  }
};

const codeBlocks = {
  parserOptions: {
    ecmaFeatures: {
      impliedStrict: true
    }
  },
  rules: {
    "eol-last": "off",
    "no-undef": "off",
    "no-unused-expressions": "off",
    "no-unused-vars": "off",
    "padded-blocks": "off",
    strict: "off",
    "unicode-bom": "off"
  }
};

var __defProp$4 = Object.defineProperty;
var __defProps$2 = Object.defineProperties;
var __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$4 = Object.getOwnPropertySymbols;
var __hasOwnProp$4 = Object.prototype.hasOwnProperty;
var __propIsEnum$4 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$4 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$4.call(b, prop))
      __defNormalProp$4(a, prop, b[prop]);
  if (__getOwnPropSymbols$4)
    for (var prop of __getOwnPropSymbols$4(b)) {
      if (__propIsEnum$4.call(b, prop))
        __defNormalProp$4(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));
let isReactPluginAvailable = false;
try {
  require.resolve("eslint-plugin-react");
  isReactPluginAvailable = true;
} catch (e) {
}
const overrides$1 = __spreadProps$2(__spreadValues$4({}, base), {
  globals: {
    React: false
  },
  plugins: arrayify(base.plugins, isReactPluginAvailable ? "react" : null),
  rules: {
    "react/jsx-no-undef": isReactPluginAvailable ? [
      2,
      {
        allowGlobals: true
      }
    ] : 0,
    "react/react-in-jsx-scope": 0
  }
});

var __defProp$3 = Object.defineProperty;
var __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;
var __hasOwnProp$3 = Object.prototype.hasOwnProperty;
var __propIsEnum$3 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$3 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$3.call(b, prop))
      __defNormalProp$3(a, prop, b[prop]);
  if (__getOwnPropSymbols$3)
    for (var prop of __getOwnPropSymbols$3(b)) {
      if (__propIsEnum$3.call(b, prop))
        __defNormalProp$3(a, prop, b[prop]);
    }
  return a;
};
const recommended = {};
const overrides = [
  __spreadValues$3({
    files: ["*.md", "*.mdx"],
    extends: "plugin:mdx/overrides"
  }, base),
  {
    files: "**/*.{md,mdx}/**",
    extends: "plugin:mdx/code-blocks"
  }
];
try {
  require.resolve("prettier");
  require.resolve("eslint-plugin-prettier");
  overrides.push({
    files: "*.md",
    rules: {
      "prettier/prettier": [
        2,
        {
          parser: "markdown"
        }
      ]
    }
  }, {
    files: "*.mdx",
    rules: {
      "prettier/prettier": [
        2,
        {
          parser: "mdx"
        }
      ]
    }
  });
} catch (e) {
}
Object.assign(recommended, {
  overrides
});

const configs = {
  base,
  "code-blocks": codeBlocks,
  codeBlocks,
  overrides: overrides$1,
  recommended
};

const getGlobals = (sources, initialGlobals = {}) => (Array.isArray(sources) ? sources : Object.keys(sources)).reduce((globals, source) => Object.assign(globals, {
  [source]: false
}), initialGlobals);

var __defProp$2 = Object.defineProperty;
var __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;
var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
var __propIsEnum$2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$2 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$2.call(b, prop))
      __defNormalProp$2(a, prop, b[prop]);
  if (__getOwnPropSymbols$2)
    for (var prop of __getOwnPropSymbols$2(b)) {
      if (__propIsEnum$2.call(b, prop))
        __defNormalProp$2(a, prop, b[prop]);
    }
  return a;
};
const DEFAULT_LANGUAGE_MAPPER = {
  javascript: "js",
  javascriptreact: "jsx",
  typescript: "ts",
  typescriptreact: "tsx",
  markdown: "md",
  mdown: "md",
  mkdn: "md"
};
function getShortLang(filename, languageMapper) {
  const language = last(filename.split("."));
  if (languageMapper === false) {
    return language;
  }
  languageMapper = __spreadValues$2(__spreadValues$2({}, DEFAULT_LANGUAGE_MAPPER), languageMapper);
  const lang = language.toLowerCase();
  return languageMapper[language] || languageMapper[lang] || lang;
}

const processorOptions = {};
const linterPath = Object.keys(require.cache).find((path) => /([/\\])eslint\1lib(?:\1linter){2}\.js$/.test(path));
if (!linterPath) {
  throw new Error("Could not find ESLint Linter in require cache");
}
const ESLinter = require(linterPath).Linter;
const { verify } = ESLinter.prototype;
ESLinter.prototype.verify = function(code, config, options) {
  const settings = config && (typeof config.extractConfig === "function" ? config.extractConfig(typeof options === "undefined" || typeof options === "string" ? options : options.filename) : config).settings || {};
  processorOptions.lintCodeBlocks = settings["mdx/code-blocks"] === true;
  processorOptions.languageMapper = settings["mdx/language-mapper"];
  return verify.call(this, code, config, options);
};

var __defProp$1 = Object.defineProperty;
var __defProps$1 = Object.defineProperties;
var __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1.call(b, prop))
      __defNormalProp$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b)) {
      if (__propIsEnum$1.call(b, prop))
        __defNormalProp$1(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));
const remark$1 = {
  supportsAutofix: true,
  preprocess(text, filename) {
    if (!processorOptions.lintCodeBlocks) {
      return [text];
    }
    return [
      text,
      ...processors$1.markdown.preprocess(text, filename).map(({ text: text2, filename: filename2 }) => ({
        text: text2,
        filename: filename2.slice(0, filename2.lastIndexOf(".")) + "." + getShortLang(filename2, processorOptions.languageMapper)
      }))
    ];
  },
  postprocess([mdxMessages, ...markdownMessages], filename) {
    return [
      ...mdxMessages,
      ...processors$1.markdown.postprocess(markdownMessages, filename)
    ].sort((a, b) => a.line - b.line || a.column - b.column).map((lintMessage) => {
      const {
        message,
        ruleId: eslintRuleId,
        severity: eslintSeverity
      } = lintMessage;
      if (eslintRuleId !== "mdx/remark") {
        return lintMessage;
      }
      const { source, ruleId, reason, severity } = JSON.parse(message);
      return __spreadProps$1(__spreadValues$1({}, lintMessage), {
        ruleId: `${source}-${ruleId}`,
        message: reason,
        severity: Math.max(eslintSeverity, severity)
      });
    });
  }
};

const processors = { remark: remark$1 };

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
const remark = {
  meta: {
    type: "layout",
    docs: {
      description: "Linter integration with remark plugins",
      category: "Stylistic Issues",
      recommended: true
    },
    fixable: "code"
  },
  create(context) {
    const filename = context.getFilename();
    const extname = path.extname(filename);
    const sourceCode = context.getSourceCode();
    const options = context.parserOptions;
    const isMdx = [
      ...DEFAULT_EXTENSIONS,
      ...options.extensions || []
    ].includes(extname);
    const isMarkdown = [
      ...MARKDOWN_EXTENSIONS,
      ...options.markdownExtensions || []
    ].includes(extname);
    return {
      Program(node) {
        if (!isMdx && !isMarkdown) {
          return;
        }
        const ignoreRemarkConfig = Boolean(options.ignoreRemarkConfig);
        const physicalFilename = getPhysicalFilename(filename);
        const sourceText = sourceCode.getText(node);
        const { messages, content: fixedText } = performSyncWork({
          fileOptions: {
            path: physicalFilename,
            value: sourceText,
            cwd: context.getCwd()
          },
          physicalFilename,
          isMdx,
          process: true,
          ignoreRemarkConfig
        });
        let fixed = 0;
        for (const {
          source,
          reason,
          ruleId,
          fatal,
          line,
          column,
          position: { start, end }
        } of messages) {
          const severity = fatal ? 2 : fatal == null ? 0 : 1;
          if (!severity) {
            continue;
          }
          const message = {
            reason,
            source,
            ruleId,
            severity
          };
          context.report({
            message: JSON.stringify(message),
            loc: {
              line,
              column: column - 1,
              start: __spreadProps(__spreadValues({}, start), {
                column: start.column - 1
              }),
              end: __spreadProps(__spreadValues({}, end), {
                column: end.column - 1
              })
            },
            node,
            fix: fixedText === sourceText ? null : () => fixed++ ? null : {
              range: [0, sourceText.length],
              text: fixedText
            }
          });
        }
      }
    };
  }
};

const rules = { remark };

export { DEFAULT_LANGUAGE_MAPPER, base, codeBlocks, configs, getGlobals, getShortLang, overrides$1 as overrides, processorOptions, processors, recommended, remark, rules };
