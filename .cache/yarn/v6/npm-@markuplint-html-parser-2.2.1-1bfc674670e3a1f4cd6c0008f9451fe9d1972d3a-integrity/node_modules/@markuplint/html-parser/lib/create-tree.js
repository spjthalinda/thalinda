"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createTree = void 0;
const tslib_1 = require("tslib");
const parser_utils_1 = require("@markuplint/parser-utils");
const parse5_1 = require("parse5");
const parse_raw_tag_1 = tslib_1.__importDefault(require("./parse-raw-tag"));
const P5_OPTIONS = { sourceCodeLocationInfo: true };
function createTree(rawCode, isFragment, offsetOffset, offsetLine, offsetColumn) {
    const doc = isFragment
        ? (0, parse5_1.parseFragment)(rawCode, P5_OPTIONS)
        : (0, parse5_1.parse)(rawCode, P5_OPTIONS);
    return createTreeRecursive(doc, null, rawCode, offsetOffset, offsetLine, offsetColumn);
}
exports.createTree = createTree;
function createTreeRecursive(rootNode, parentNode, rawHtml, offsetOffset, offsetLine, offsetColumn) {
    const nodeList = [];
    const childNodes = getChildNodes(rootNode);
    let prevNode = null;
    for (const p5node of childNodes) {
        const node = nodeize(p5node, prevNode, parentNode, rawHtml, offsetOffset, offsetLine, offsetColumn);
        if (!node) {
            continue;
        }
        if (prevNode) {
            if (node.type !== 'endtag') {
                prevNode.nextNode = node;
            }
            node.prevNode = prevNode;
        }
        prevNode = node;
        nodeList.push(node);
    }
    return nodeList;
}
function nodeize(originNode, prevNode, parentNode, rawHtml, offsetOffset, offsetLine, offsetColumn) {
    const nextNode = null;
    const location = getLocation(originNode);
    if (!location) {
        const prevToken = prevNode || parentNode;
        const startOffset = prevToken ? prevToken.endOffset : 0;
        const endOffset = prevToken ? prevToken.endOffset : 0;
        const startLine = prevToken ? prevToken.endLine : 0;
        const endLine = prevToken ? prevToken.endLine : 0;
        const startCol = prevToken ? prevToken.endCol : 0;
        const endCol = prevToken ? prevToken.endCol : 0;
        const node = {
            uuid: (0, parser_utils_1.uuid)(),
            raw: '',
            startOffset: startOffset + offsetOffset,
            endOffset: endOffset + offsetOffset,
            startLine: startLine + offsetLine,
            endLine: endLine + offsetLine,
            startCol: startCol + (startLine === 1 ? offsetColumn : 0),
            endCol: endCol + (endLine === 1 ? offsetColumn : 0),
            nodeName: originNode.nodeName,
            type: 'omittedtag',
            namespace: getNamespace(originNode),
            parentNode,
            prevNode,
            nextNode,
            isFragment: false,
            isGhost: true,
            isCustomElement: false,
        };
        node.childNodes = createTreeRecursive(originNode, node, rawHtml, offsetOffset, offsetLine, offsetColumn);
        return node;
    }
    const { startOffset, endOffset, startLine, endLine, startCol, endCol } = location;
    const raw = rawHtml.slice(startOffset, endOffset || startOffset);
    switch (originNode.nodeName) {
        case '#documentType': {
            return {
                uuid: (0, parser_utils_1.uuid)(),
                raw,
                // @ts-ignore
                name: originNode.name || '',
                // @ts-ignore
                publicId: originNode.publicId || '',
                // @ts-ignore
                systemId: originNode.systemId || '',
                startOffset: startOffset + offsetOffset,
                endOffset: endOffset + offsetOffset,
                startLine: startLine + offsetLine,
                endLine: endLine + offsetLine,
                startCol: startCol + (startLine === 1 ? offsetColumn : 0),
                endCol: endCol + (endLine === 1 ? offsetColumn : 0),
                nodeName: '#doctype',
                type: 'doctype',
                parentNode,
                prevNode,
                _addPrevNode: 102,
                nextNode,
                isFragment: false,
                isGhost: false,
            };
        }
        case '#text': {
            const node = {
                uuid: (0, parser_utils_1.uuid)(),
                raw,
                startOffset: startOffset + offsetOffset,
                endOffset: endOffset + offsetOffset,
                startLine: startLine + offsetLine,
                endLine: endLine + offsetLine,
                startCol: startCol + (startLine === 1 ? offsetColumn : 0),
                endCol: endCol + (endLine === 1 ? offsetColumn : 0),
                nodeName: '#text',
                type: 'text',
                parentNode,
                prevNode,
                nextNode,
                isFragment: false,
                isGhost: false,
            };
            return node;
        }
        case '#comment': {
            return {
                uuid: (0, parser_utils_1.uuid)(),
                raw,
                startOffset: startOffset + offsetOffset,
                endOffset: endOffset + offsetOffset,
                startLine: startLine + offsetLine,
                endLine: endLine + offsetLine,
                startCol: startCol + (startLine === 1 ? offsetColumn : 0),
                endCol: endCol + (endLine === 1 ? offsetColumn : 0),
                nodeName: '#comment',
                type: 'comment',
                parentNode,
                prevNode,
                nextNode,
                isFragment: false,
                isGhost: false,
            };
        }
        default: {
            const tagLoc = 'startTag' in location ? location.startTag : null;
            const startTagRaw = tagLoc
                ? rawHtml.slice(tagLoc.startOffset, tagLoc.endOffset)
                : rawHtml.slice(startOffset, endOffset || startOffset);
            const tagTokens = (0, parse_raw_tag_1.default)(startTagRaw, startLine, startCol, startOffset, offsetOffset, offsetLine, offsetColumn);
            const tagName = tagTokens.tagName;
            const isCustomElement = (0, parser_utils_1.isPotentialCustomElementName)(tagName);
            let endTag = null;
            let endTagLoc = 'endTag' in location ? location.endTag : null;
            /**
             * Patch: Create endTag for SVG Element
             * @see https://github.com/inikulin/parse5/issues/352
             */
            if (!endTagLoc &&
                'namespaceURI' in originNode &&
                originNode.namespaceURI === 'http://www.w3.org/2000/svg') {
                const belowRawHTMLFromStartTagEnd = rawHtml.slice(location.endOffset);
                const endTagMatched = belowRawHTMLFromStartTagEnd.match(new RegExp(`^</\\s*${tagName}[^>]*>`, 'm'));
                const endTag = endTagMatched && endTagMatched[0];
                if (endTag) {
                    endTagLoc = (0, parser_utils_1.sliceFragment)(rawHtml, location.endOffset, location.endOffset + endTag.length);
                }
            }
            if (endTagLoc) {
                const { startOffset, endOffset, startLine, endLine, startCol, endCol } = endTagLoc;
                const endTagRaw = rawHtml.slice(startOffset, endOffset);
                const endTagTokens = (0, parse_raw_tag_1.default)(endTagRaw, startLine, startCol, startOffset, offsetOffset, offsetLine, offsetColumn);
                const endTagName = endTagTokens.tagName;
                endTag = {
                    uuid: (0, parser_utils_1.uuid)(),
                    raw: endTagRaw,
                    startOffset: startOffset + offsetOffset,
                    endOffset: endOffset + offsetOffset,
                    startLine: startLine + offsetLine,
                    endLine: endLine + offsetLine,
                    startCol: startCol + (startLine === 1 ? offsetColumn : 0),
                    endCol: endCol + (endLine === 1 ? offsetColumn : 0),
                    nodeName: endTagName,
                    type: 'endtag',
                    namespace: getNamespace(originNode),
                    attributes: endTagTokens.attrs,
                    parentNode,
                    prevNode,
                    nextNode,
                    pearNode: null,
                    isFragment: false,
                    isGhost: false,
                    tagOpenChar: '</',
                    tagCloseChar: '>',
                    isCustomElement,
                };
            }
            const _endOffset = startOffset + startTagRaw.length;
            const _endLine = (0, parser_utils_1.getEndLine)(startTagRaw, startLine);
            const _endCol = (0, parser_utils_1.getEndCol)(startTagRaw, startCol);
            const startTag = {
                uuid: (0, parser_utils_1.uuid)(),
                raw: startTagRaw,
                startOffset: startOffset + offsetOffset,
                endOffset: _endOffset + offsetOffset,
                startLine: startLine + offsetLine,
                endLine: _endLine + offsetLine,
                startCol: startCol + (startLine === 1 ? offsetColumn : 0),
                endCol: _endCol + (startLine === _endLine ? offsetColumn : 0),
                nodeName: tagName,
                type: 'starttag',
                namespace: getNamespace(originNode),
                attributes: tagTokens.attrs,
                hasSpreadAttr: false,
                parentNode,
                prevNode,
                nextNode,
                pearNode: endTag,
                selfClosingSolidus: tagTokens.selfClosingSolidus,
                endSpace: tagTokens.endSpace,
                isFragment: false,
                isGhost: false,
                tagOpenChar: '<',
                tagCloseChar: '>',
                isCustomElement,
            };
            if (endTag) {
                endTag.pearNode = startTag;
            }
            startTag.childNodes = createTreeRecursive(originNode, startTag, rawHtml, offsetOffset, offsetLine, offsetColumn);
            return startTag;
        }
    }
}
/**
 * getChildNodes
 *
 * - If node has "content" property then parse as document fragment.
 * - If node is <noscript> then that childNodes is a TextNode. But parse as document fragment it for disabled script.
 */
function getChildNodes(rootNode) {
    if (rootNode.nodeName === 'noscript') {
        const textNode = rootNode.childNodes[0];
        if (!textNode || textNode.nodeName !== '#text') {
            return [];
        }
        // @ts-ignore
        const html = textNode.value;
        // @ts-ignore
        const { startOffset, startLine, startCol } = textNode.sourceCodeLocation;
        const breakCount = startLine - 1;
        const indentWidth = startCol - 1;
        const offsetSpaces = ' '.repeat(startOffset - Math.max(breakCount, 0) - Math.max(indentWidth, 0)) +
            '\n'.repeat(breakCount) +
            ' '.repeat(indentWidth);
        const fragment = (0, parse5_1.parseFragment)(`${offsetSpaces}${html}`, P5_OPTIONS);
        const childNodes = fragment.childNodes.slice(offsetSpaces ? 1 : 0);
        // const childNodes = ('childNodes' in _childNodes && _childNodes.childNodes) || [];
        return childNodes;
    }
    return rootNode.content ? rootNode.content.childNodes : rootNode.childNodes || [];
}
function hasLocation(node) {
    return 'sourceCodeLocation' in node;
}
function getLocation(node) {
    if (hasLocation(node) && node.sourceCodeLocation) {
        return node.sourceCodeLocation;
    }
    return null;
}
function getNamespace(node) {
    if ('namespaceURI' in node) {
        return node.namespaceURI;
    }
    return '';
}
