"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const parser_utils_1 = require("@markuplint/parser-utils");
const attr_tokenizer_1 = tslib_1.__importDefault(require("./attr-tokenizer"));
const const_1 = require("./const");
// eslint-disable-next-line no-control-regex
const reAttrsInStartTag = /\s*[^\x00-\x1f\x7f-\x9f "'>/=]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^\s]*))?/;
const reEndTokens = /(\s*\/)?(\s*)>$/;
function parseRawTag(raw, startLine, startCol, startOffset, offsetOffset = 0, offsetLine = 0, offsetColumn = 0) {
    let offset = startOffset + offsetOffset;
    let line = startLine + offsetLine;
    let col = startCol + (startLine === 1 ? offsetColumn : 0);
    const matches = raw.match(const_1.reTag);
    if (!matches) {
        throw new SyntaxError(`Invalid tag syntax: "${raw}"`);
    }
    const tagWithAttrs = matches[1];
    // eslint-disable-next-line no-control-regex
    const tagNameSplited = tagWithAttrs.split(/[\u0000\u0009\u000A\u000C\u0020/>]/);
    const tagName = tagNameSplited[0] || tagNameSplited[1];
    if (!tagName || (!const_1.reTagName.test(tagName) && !(0, parser_utils_1.isPotentialCustomElementName)(tagName))) {
        throw new SyntaxError(`Invalid tag name: "${tagName}" in <${tagWithAttrs}>`);
    }
    const tagStartPos = tagWithAttrs.indexOf(tagName);
    let rawAttrs = tagWithAttrs.substring(tagStartPos + tagName.length);
    // console.log({ raw, tagStartPos, tagName, rawAttrs });
    col += tagName.length + 1 + tagStartPos;
    offset += tagName.length + 1 + tagStartPos;
    const attrs = [];
    while (reAttrsInStartTag.test(rawAttrs)) {
        const attrMatchedMap = rawAttrs.match(reAttrsInStartTag);
        if (attrMatchedMap && attrMatchedMap[0]) {
            const rawAttr = attrMatchedMap[0];
            const attr = (0, attr_tokenizer_1.default)(rawAttr, line, col, offset);
            line = attr.endLine;
            col = attr.endCol;
            offset = attr.endOffset;
            rawAttrs = rawAttrs.substr(rawAttr.length);
            attrs.push(attr);
        }
    }
    const endTokens = reEndTokens.exec(raw);
    const selfClosingSolidus = (0, parser_utils_1.tokenizer)(endTokens && endTokens[1], line, col, offset);
    line = selfClosingSolidus.endLine;
    col = selfClosingSolidus.endCol;
    offset = selfClosingSolidus.endOffset;
    const endSpace = (0, parser_utils_1.tokenizer)(endTokens && endTokens[2], line, col, offset);
    return {
        tagName,
        attrs,
        selfClosingSolidus,
        endSpace,
    };
}
exports.default = parseRawTag;
