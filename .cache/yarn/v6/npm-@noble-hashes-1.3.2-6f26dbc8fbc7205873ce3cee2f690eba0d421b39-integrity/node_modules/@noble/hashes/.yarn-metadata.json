{
  "manifest": {
    "name": "@noble/hashes",
    "version": "1.3.2",
    "description": "Audited & minimal 0-dependency JS implementation of SHA2, SHA3, RIPEMD, BLAKE2/3, HMAC, HKDF, PBKDF2, Scrypt",
    "files": [
      "/*.js",
      "/*.d.ts",
      "/*.js.map",
      "esm",
      "src/*.ts"
    ],
    "scripts": {
      "bench": "node benchmark/index.js noble",
      "bench:all": "node benchmark/index.js",
      "bench:install": "cd benchmark && npm install && cd ../../",
      "build": "npm run build:clean; tsc && tsc -p tsconfig.esm.json",
      "build:release": "cd build; npm i; npm run build",
      "build:clean": "rm *.{js,d.ts,js.map} esm/*.{js,js.map} 2> /dev/null",
      "lint": "prettier --check 'src/**/*.{js,ts}' 'test/**/*.{js,ts}'",
      "format": "prettier --write 'src/**/*.{js,ts}' 'test/**/*.{js,ts}'",
      "test": "node test/index.js",
      "test:dos": "node test/slow-dos.test.js",
      "test:big": "node test/slow-big.test.js"
    },
    "author": {
      "name": "Paul Miller",
      "url": "https://paulmillr.com"
    },
    "homepage": "https://paulmillr.com/noble/",
    "repository": {
      "type": "git",
      "url": "https://github.com/paulmillr/noble-hashes.git"
    },
    "license": "MIT",
    "sideEffects": false,
    "browser": {
      "node:crypto": false,
      "./crypto": "./crypto.js"
    },
    "devDependencies": {
      "micro-bmark": "0.3.1",
      "micro-should": "0.4.0",
      "prettier": "2.8.4",
      "typescript": "5.0.2"
    },
    "engines": {
      "node": ">= 16"
    },
    "exports": {
      ".": {
        "types": "./index.d.ts",
        "import": "./esm/index.js",
        "default": "./index.js"
      },
      "./crypto": {
        "types": "./crypto.d.ts",
        "node": {
          "import": "./esm/cryptoNode.js",
          "default": "./cryptoNode.js"
        },
        "import": "./esm/crypto.js",
        "default": "./crypto.js"
      },
      "./_assert": {
        "types": "./_assert.d.ts",
        "import": "./esm/_assert.js",
        "default": "./_assert.js"
      },
      "./_sha2": {
        "types": "./_sha2.d.ts",
        "import": "./esm/_sha2.js",
        "default": "./_sha2.js"
      },
      "./argon2": {
        "types": "./argon2.d.ts",
        "import": "./esm/argon2.js",
        "default": "./argon2.js"
      },
      "./blake2b": {
        "types": "./blake2b.d.ts",
        "import": "./esm/blake2b.js",
        "default": "./blake2b.js"
      },
      "./blake2s": {
        "types": "./blake2s.d.ts",
        "import": "./esm/blake2s.js",
        "default": "./blake2s.js"
      },
      "./blake3": {
        "types": "./blake3.d.ts",
        "import": "./esm/blake3.js",
        "default": "./blake3.js"
      },
      "./eskdf": {
        "types": "./eskdf.d.ts",
        "import": "./esm/eskdf.js",
        "default": "./eskdf.js"
      },
      "./hkdf": {
        "types": "./hkdf.d.ts",
        "import": "./esm/hkdf.js",
        "default": "./hkdf.js"
      },
      "./hmac": {
        "types": "./hmac.d.ts",
        "import": "./esm/hmac.js",
        "default": "./hmac.js"
      },
      "./pbkdf2": {
        "types": "./pbkdf2.d.ts",
        "import": "./esm/pbkdf2.js",
        "default": "./pbkdf2.js"
      },
      "./ripemd160": {
        "types": "./ripemd160.d.ts",
        "import": "./esm/ripemd160.js",
        "default": "./ripemd160.js"
      },
      "./scrypt": {
        "types": "./scrypt.d.ts",
        "import": "./esm/scrypt.js",
        "default": "./scrypt.js"
      },
      "./sha1": {
        "types": "./sha1.d.ts",
        "import": "./esm/sha1.js",
        "default": "./sha1.js"
      },
      "./sha3-addons": {
        "types": "./sha3-addons.d.ts",
        "import": "./esm/sha3-addons.js",
        "default": "./sha3-addons.js"
      },
      "./sha3": {
        "types": "./sha3.d.ts",
        "import": "./esm/sha3.js",
        "default": "./sha3.js"
      },
      "./sha256": {
        "types": "./sha256.d.ts",
        "import": "./esm/sha256.js",
        "default": "./sha256.js"
      },
      "./sha512": {
        "types": "./sha512.d.ts",
        "import": "./esm/sha512.js",
        "default": "./sha512.js"
      },
      "./utils": {
        "types": "./utils.d.ts",
        "import": "./esm/utils.js",
        "default": "./utils.js"
      }
    },
    "keywords": [
      "sha",
      "sha2",
      "sha3",
      "sha256",
      "sha512",
      "keccak",
      "kangarootwelve",
      "ripemd160",
      "blake2",
      "blake3",
      "hmac",
      "hkdf",
      "pbkdf2",
      "scrypt",
      "kdf",
      "hash",
      "cryptography",
      "security",
      "noble"
    ],
    "funding": "https://paulmillr.com/funding/",
    "_registry": "npm",
    "_loc": "/data/data/com.termux/files/home/.cache/yarn/v6/npm-@noble-hashes-1.3.2-6f26dbc8fbc7205873ce3cee2f690eba0d421b39-integrity/node_modules/@noble/hashes/package.json",
    "readmeFilename": "README.md",
    "readme": "# noble-hashes\n\nAudited & minimal JS implementation of SHA2, SHA3, RIPEMD, BLAKE2/3, HMAC, HKDF, PBKDF2 & Scrypt.\n\n- 🔒 [**Audited**](#security) by an independent security firm\n- 🔻 Tree-shaking-friendly: use only what's necessary, other code won't be included\n- 🏎 Ultra-fast, hand-optimized for caveats of JS engines\n- 🔍 Unique tests ensure correctness: chained tests, sliding window tests, DoS tests, fuzzing\n- 🔁 No unrolled loops: makes it easier to verify and reduces source code size up to 5x\n- 🐢 Scrypt supports `N: 2**22`, while other implementations are limited to `2**20`\n- 🦘 SHA3 supports Keccak, TupleHash, KangarooTwelve and MarsupilamiFourteen\n- 🪶 Just 3.4k lines / 17KB gzipped. SHA256-only is 240 lines / 3KB gzipped\n\nThe library's initial development was funded by [Ethereum Foundation](https://ethereum.org/).\n\n### This library belongs to _noble_ crypto\n\n> **noble-crypto** — high-security, easily auditable set of contained cryptographic libraries and tools.\n\n- No dependencies, protection against supply chain attacks\n- Auditable TypeScript / JS code\n- Supported on all major platforms\n- Releases are signed with PGP keys and built transparently with NPM provenance\n- Check out [homepage](https://paulmillr.com/noble/) & all libraries:\n  [ciphers](https://github.com/paulmillr/noble-ciphers),\n  [curves](https://github.com/paulmillr/noble-curves),\n  [hashes](https://github.com/paulmillr/noble-hashes),\n  4kb [secp256k1](https://github.com/paulmillr/noble-secp256k1) /\n  [ed25519](https://github.com/paulmillr/noble-ed25519)\n\n## Usage\n\n> npm install @noble/hashes\n\nWe support all major platforms and runtimes.\nFor [Deno](https://deno.land), ensure to use [npm specifier](https://deno.land/manual@v1.28.0/node/npm_specifiers).\nFor React Native, you may need a [polyfill for getRandomValues](https://github.com/LinusU/react-native-get-random-values).\nIf you don't like NPM, a standalone [noble-hashes.js](https://github.com/paulmillr/noble-hashes/releases) is also available.\n\n```js\n// import * from '@noble/hashes'; // Error: use sub-imports, to ensure small app size\nimport { sha256 } from '@noble/hashes/sha256'; // ECMAScript modules (ESM) and Common.js\n// import { sha256 } from 'npm:@noble/hashes@1.3.0/sha256'; // Deno\nconsole.log(sha256(new Uint8Array([1, 2, 3]))); // Uint8Array(32) [3, 144, 88, 198, 242...]\n// you could also pass strings that will be UTF8-encoded to Uint8Array\nconsole.log(sha256('abc')); // == sha256(new TextEncoder().encode('abc'))\n\n// sha384 is here, because it uses same internals as sha512\nimport { sha512, sha512_256, sha384 } from '@noble/hashes/sha512';\n// prettier-ignore\nimport {\n  sha3_224, sha3_256, sha3_384, sha3_512,\n  keccak_224, keccak_256, keccak_384, keccak_512,\n  shake128, shake256\n} from '@noble/hashes/sha3';\n// prettier-ignore\nimport {\n  cshake128, cshake256, kmac128, kmac256,\n  k12, m14,\n  tuplehash256, parallelhash256, keccakprg\n} from '@noble/hashes/sha3-addons';\nimport { ripemd160 } from '@noble/hashes/ripemd160';\nimport { blake3 } from '@noble/hashes/blake3';\nimport { blake2b } from '@noble/hashes/blake2b';\nimport { blake2s } from '@noble/hashes/blake2s';\nimport { hmac } from '@noble/hashes/hmac';\nimport { hkdf } from '@noble/hashes/hkdf';\nimport { pbkdf2, pbkdf2Async } from '@noble/hashes/pbkdf2';\nimport { scrypt, scryptAsync } from '@noble/hashes/scrypt';\n\nimport { sha1 } from '@noble/hashes/sha1'; // legacy\n\n// small utility method that converts bytes to hex\nimport { bytesToHex as toHex } from '@noble/hashes/utils';\nconsole.log(toHex(sha256('abc'))); // ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad\n```\n\n## API\n\nAll hash functions:\n\n- can be called directly, with `Uint8Array`.\n- return `Uint8Array`\n- can receive `string`, which is automatically converted to `Uint8Array`\n  via utf8 encoding **(not hex)**\n- support hashing 4GB of data per update on 64-bit systems (unlimited with streaming)\n\n```ts\nfunction hash(message: Uint8Array | string): Uint8Array;\nhash(new Uint8Array([1, 3]));\nhash('string') == hash(new TextEncoder().encode('string'));\n```\n\nAll hash functions can be constructed via `hash.create()` method:\n\n- the result is `Hash` subclass instance, which has `update()` and `digest()` methods\n- `digest()` finalizes the hash and makes it no longer usable\n\n```ts\nhash\n  .create()\n  .update(new Uint8Array([1, 3]))\n  .digest();\n```\n\n_Some_ hash functions can also receive `options` object, which can be either passed as a:\n\n- second argument to hash function: `blake3('abc', { key: 'd', dkLen: 32 })`\n- first argument to class initializer: `blake3.create({ context: 'e', dkLen: 32 })`\n\n## Modules\n\n- [SHA2 (sha256, sha384, sha512, sha512_256)](#sha2-sha256-sha384-sha512-sha512_256)\n- [SHA3 (FIPS, SHAKE, Keccak)](#sha3-fips-shake-keccak)\n- [SHA3 Addons (cSHAKE, KMAC, KangarooTwelve, MarsupilamiFourteen)](#sha3-addons-cshake-kmac-tuplehash-parallelhash-kangarootwelve-marsupilamifourteen)\n- [RIPEMD-160](#ripemd-160)\n- [BLAKE2b, BLAKE2s](#blake2b-blake2s)\n- [BLAKE3](#blake3)\n- [SHA1 (legacy)](#sha1-legacy)\n- [HMAC](#hmac)\n- [HKDF](#hkdf)\n- [PBKDF2](#pbkdf2)\n- [Scrypt](#scrypt)\n- [ESKDF](#eskdf)\n- [utils](#utils)\n\n##### SHA2 (sha256, sha384, sha512, sha512_256)\n\n```typescript\nimport { sha256 } from '@noble/hashes/sha256';\nconst h1a = sha256('abc');\nconst h1b = sha256\n  .create()\n  .update(Uint8Array.from([1, 2, 3]))\n  .digest();\n```\n\n```typescript\nimport { sha512 } from '@noble/hashes/sha512';\nconst h2a = sha512('abc');\nconst h2b = sha512\n  .create()\n  .update(Uint8Array.from([1, 2, 3]))\n  .digest();\n\n// SHA512/256 variant\nimport { sha512_256 } from '@noble/hashes/sha512';\nconst h3a = sha512_256('abc');\nconst h3b = sha512_256\n  .create()\n  .update(Uint8Array.from([1, 2, 3]))\n  .digest();\n\n// SHA384\nimport { sha384 } from '@noble/hashes/sha512';\nconst h4a = sha384('abc');\nconst h4b = sha384\n  .create()\n  .update(Uint8Array.from([1, 2, 3]))\n  .digest();\n```\n\nSee [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and\n[the paper on SHA512/256](https://eprint.iacr.org/2010/548.pdf).\n\n##### SHA3 (FIPS, SHAKE, Keccak)\n\n```typescript\nimport {\n  sha3_224,\n  sha3_256,\n  sha3_384,\n  sha3_512,\n  keccak_224,\n  keccak_256,\n  keccak_384,\n  keccak_512,\n  shake128,\n  shake256,\n} from '@noble/hashes/sha3';\nconst h5a = sha3_256('abc');\nconst h5b = sha3_256\n  .create()\n  .update(Uint8Array.from([1, 2, 3]))\n  .digest();\nconst h6a = keccak_256('abc');\nconst h7a = shake128('abc', { dkLen: 512 });\nconst h7b = shake256('abc', { dkLen: 512 });\n```\n\nSee [FIPS PUB 202](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf),\n[Website](https://keccak.team/keccak.html).\n\nCheck out [the differences between SHA-3 and Keccak](https://crypto.stackexchange.com/questions/15727/what-are-the-key-differences-between-the-draft-sha-3-standard-and-the-keccak-sub)\n\n##### SHA3 Addons (cSHAKE, KMAC, TupleHash, ParallelHash, KangarooTwelve, MarsupilamiFourteen)\n\n```typescript\nimport {\n  cshake128,\n  cshake256,\n  kmac128,\n  kmac256,\n  k12,\n  m14,\n  tuplehash128,\n  tuplehash256,\n  parallelhash128,\n  parallelhash256,\n  keccakprg,\n} from '@noble/hashes/sha3-addons';\nconst h7c = cshake128('abc', { personalization: 'def' });\nconst h7d = cshake256('abc', { personalization: 'def' });\nconst h7e = kmac128('key', 'message');\nconst h7f = kmac256('key', 'message');\nconst h7h = k12('abc');\nconst h7g = m14('abc');\nconst h7i = tuplehash128(['ab', 'c']); // tuplehash(['ab', 'c']) !== tuplehash(['a', 'bc']) !== tuplehash(['abc'])\n// Same as k12/blake3, but without reduced number of rounds. Doesn't speedup anything due lack of SIMD and threading,\n// added for compatibility.\nconst h7j = parallelhash128('abc', { blockLen: 8 });\n// pseudo-random generator, first argument is capacity. XKCP recommends 254 bits capacity for 128-bit security strength.\n// * with a capacity of 254 bits.\nconst p = keccakprg(254);\np.feed('test');\nconst rand1b = p.fetch(1);\n```\n\n- Full [NIST SP 800-185](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-185.pdf):\n  cSHAKE, KMAC, TupleHash, ParallelHash + XOF variants\n- 🦘 K12 ([KangarooTwelve Paper](https://keccak.team/files/KangarooTwelve.pdf),\n  [RFC Draft](https://www.ietf.org/archive/id/draft-irtf-cfrg-kangarootwelve-06.txt))\n  and M14 aka MarsupilamiFourteen are basically parallel versions of Keccak with\n  reduced number of rounds (same as Blake3 and ParallelHash).\n- [KeccakPRG](https://keccak.team/files/CSF-0.1.pdf): Pseudo-random generator based on Keccak\n\n##### RIPEMD-160\n\n```typescript\nimport { ripemd160 } from '@noble/hashes/ripemd160';\n// function ripemd160(data: Uint8Array): Uint8Array;\nconst hash8 = ripemd160('abc');\nconst hash9 = ripemd160()\n  .create()\n  .update(Uint8Array.from([1, 2, 3]))\n  .digest();\n```\n\nSee [RFC 2286](https://datatracker.ietf.org/doc/html/rfc2286),\n[Website](https://homes.esat.kuleuven.be/~bosselae/ripemd160.html)\n\n##### BLAKE2b, BLAKE2s\n\n```typescript\nimport { blake2b } from '@noble/hashes/blake2b';\nimport { blake2s } from '@noble/hashes/blake2s';\nconst h10a = blake2s('abc');\nconst b2params = { key: new Uint8Array([1]), personalization: t, salt: t, dkLen: 32 };\nconst h10b = blake2s('abc', b2params);\nconst h10c = blake2s\n  .create(b2params)\n  .update(Uint8Array.from([1, 2, 3]))\n  .digest();\n```\n\nSee [RFC 7693](https://datatracker.ietf.org/doc/html/rfc7693), [Website](https://www.blake2.net).\n\n##### BLAKE3\n\n```typescript\nimport { blake3 } from '@noble/hashes/blake3';\n// All params are optional\nconst h11 = blake3('abc', { dkLen: 256, key: 'def', context: 'fji' });\n```\n\n##### SHA1 (legacy)\n\nSHA1 was cryptographically broken, however, it was not broken for cases like HMAC.\n\nSee [RFC4226 B.2](https://datatracker.ietf.org/doc/html/rfc4226#appendix-B.2).\n\nDon't use it for a new protocol.\n\n```typescript\nimport { sha1 } from '@noble/hashes/sha1';\nconst h12 = sha1('def');\n```\n\n##### HMAC\n\n```typescript\nimport { hmac } from '@noble/hashes/hmac';\nimport { sha256 } from '@noble/hashes/sha256';\nconst mac1 = hmac(sha256, 'key', 'message');\nconst mac2 = hmac.create(sha256, Uint8Array.from([1, 2, 3])).update(Uint8Array.from([4, 5, 6])).digest();\n```\n\nMatches [RFC 2104](https://datatracker.ietf.org/doc/html/rfc2104).\n\n##### HKDF\n\n```typescript\nimport { hkdf } from '@noble/hashes/hkdf';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { randomBytes } from '@noble/hashes/utils';\nconst inputKey = randomBytes(32);\nconst salt = randomBytes(32);\nconst info = 'abc';\nconst dkLen = 32;\nconst hk1 = hkdf(sha256, inputKey, salt, info, dkLen);\n\n// == same as\nimport * as hkdf from '@noble/hashes/hkdf';\nimport { sha256 } from '@noble/hashes/sha256';\nconst prk = hkdf.extract(sha256, inputKey, salt);\nconst hk2 = hkdf.expand(sha256, prk, info, dkLen);\n```\n\nMatches [RFC 5869](https://datatracker.ietf.org/doc/html/rfc5869).\n\n##### PBKDF2\n\n```typescript\nimport { pbkdf2, pbkdf2Async } from '@noble/hashes/pbkdf2';\nimport { sha256 } from '@noble/hashes/sha256';\nconst pbkey1 = pbkdf2(sha256, 'password', 'salt', { c: 32, dkLen: 32 });\nconst pbkey2 = await pbkdf2Async(sha256, 'password', 'salt', { c: 32, dkLen: 32 });\nconst pbkey3 = await pbkdf2Async(sha256, Uint8Array.from([1, 2, 3]), Uint8Array.from([4, 5, 6]), {\n  c: 32,\n  dkLen: 32,\n});\n```\n\nMatches [RFC 2898](https://datatracker.ietf.org/doc/html/rfc2898).\n\n##### Scrypt\n\n```typescript\nimport { scrypt, scryptAsync } from '@noble/hashes/scrypt';\nconst scr1 = scrypt('password', 'salt', { N: 2 ** 16, r: 8, p: 1, dkLen: 32 });\nconst scr2 = await scryptAsync('password', 'salt', { N: 2 ** 16, r: 8, p: 1, dkLen: 32 });\nconst scr3 = await scryptAsync(Uint8Array.from([1, 2, 3]), Uint8Array.from([4, 5, 6]), {\n  N: 2 ** 22,\n  r: 8,\n  p: 1,\n  dkLen: 32,\n  onProgress(percentage) {\n    console.log('progress', percentage);\n  },\n  maxmem: 2 ** 32 + 128 * 8 * 1, // N * r * p * 128 + (128*r*p)\n});\n```\n\nConforms to [RFC 7914](https://datatracker.ietf.org/doc/html/rfc7914),\n[Website](https://www.tarsnap.com/scrypt.html)\n\n- `N, r, p` are work factors. To understand them, see [the blog post](https://blog.filippo.io/the-scrypt-parameters/).\n- `dkLen` is the length of output bytes\n- It is common to use N from `2**10` to `2**22` and `{r: 8, p: 1, dkLen: 32}`\n- `onProgress` can be used with async version of the function to report progress to a user.\n\nMemory usage of scrypt is calculated with the formula `N * r * p * 128 + (128 * r * p)`,\nwhich means `{N: 2 ** 22, r: 8, p: 1}` will use 4GB + 1KB of memory. To prevent\nDoS, we limit scrypt to `1GB + 1KB` of RAM used, which corresponds to\n`{N: 2 ** 20, r: 8, p: 1}`. If you want to use higher values, increase\n`maxmem` using the formula above.\n\n_Note:_ noble supports `2**22` (4GB RAM) which is the highest amount amongst JS\nlibs. Many other implementations don't support it. We cannot support `2**23`,\nbecause there is a limitation in JS engines that makes allocating\narrays bigger than 4GB impossible, but we're looking into other possible solutions.\n\n##### Argon2\n\nExperimental Argon2 RFC 9106 implementation. It may be removed at any time.\n\n```ts\nimport { argon2d, argon2i, argon2id } from '@noble/hashes/argon2';\nconst result = argon2id('password', 'salt', { t: 2, m: 65536, p: 1 });\n```\n\n##### ESKDF\n\nA tiny stretched KDF for various applications like AES key-gen. Takes >= 2 seconds to execute.\n\nTakes following params:\n\n- `username` - username, email, or identifier, min: 8 characters, should have enough entropy\n- `password` - min: 8 characters, should have enough entropy\n\nProduces ESKDF instance that has `deriveChildKey(protocol, accountId[, options])` function.\n\n- `protocol` - 3-15 character protocol name\n- `accountId` - numeric identifier of account\n- `options` - `keyLength: 32` with specified key length (default is 32),\n  or `modulus: 2n ** 221n - 17n` with specified modulus. It will fetch modulus + 64 bits of\n  data, execute modular division. The result will have negligible bias as per FIPS 186 B.4.1.\n  Can be used to generate, for example, elliptic curve keys.\n\nTakes username and password, then takes protocol name and account id.\n\n```typescript\nimport { eskdf } from '@noble/hashes/eskdf';\nconst kdf = await eskdf('example@university', 'beginning-new-example');\nconsole.log(kdf.fingerprint);\nconst key1 = kdf.deriveChildKey('aes', 0);\nconst key2 = kdf.deriveChildKey('aes', 0, { keyLength: 16 });\nconst ecc1 = kdf.deriveChildKey('ecc', 0, { modulus: 2n ** 252n - 27742317777372353535851937790883648493n })\nkdf.expire();\n```\n\n##### utils\n\n```typescript\nimport { bytesToHex as toHex, randomBytes } from '@noble/hashes/utils';\nconsole.log(toHex(randomBytes(32)));\n```\n\n- `bytesToHex` will convert `Uint8Array` to a hex string\n- `randomBytes(bytes)` will produce cryptographically secure random `Uint8Array` of length `bytes`\n\n## Security\n\nNoble is production-ready.\n\n1. The library has been audited in Jan 2022 by an independent security firm\n   cure53: [PDF](https://cure53.de/pentest-report_hashing-libs.pdf).\n   No vulnerabilities have been found. The audit has been funded by\n   [Ethereum Foundation](https://ethereum.org/en/) with help of [Nomic Labs](https://nomiclabs.io).\n   Modules `blake3`, `sha3-addons`, `sha1` and `argon2` have not been audited.\n   See [changes since audit](https://github.com/paulmillr/noble-hashes/compare/1.0.0..main).\n2. The library has been fuzzed by [Guido Vranken's cryptofuzz](https://github.com/guidovranken/cryptofuzz).\n   You can run the fuzzer by yourself to check it.\n3. [Timing attack](https://en.wikipedia.org/wiki/Timing_attack) considerations:\n   _JIT-compiler_ and _Garbage Collector_ make \"constant time\" extremely hard to\n   achieve in a scripting language. Which means _any other JS library can't have constant-timeness_.\n   Even statically typed Rust, a language without GC,\n   [makes it harder to achieve constant-time](https://www.chosenplaintext.ca/open-source/rust-timing-shield/security)\n   for some cases. If your goal is absolute security, don't use any JS lib — including\n   bindings to native ones. Use low-level libraries & languages. Nonetheless we're\n   targetting algorithmic constant time.\n4. Memory dump considerations: the library shares state buffers between hash\n   function calls. The buffers are zeroed-out after each call. However, if an attacker\n   can read application memory, you are doomed in any case:\n    - At some point, input will be a string and strings are immutable in JS:\n      there is no way to overwrite them with zeros. For example: deriving\n      key from `scrypt(password, salt)` where password and salt are strings\n    - Input from a file will stay in file buffers\n    - Input / output will be re-used multiple times in application which means\n      it could stay in memory\n    - `await anything()` will always write all internal variables (including numbers)\n    to memory. With async functions / Promises there are no guarantees when the code\n    chunk would be executed. Which means attacker can have plenty of time to read data from memory\n    - There is no way to guarantee anything about zeroing sensitive data without\n      complex tests-suite which will dump process memory and verify that there is\n      no sensitive data left. For JS it means testing all browsers (incl. mobile),\n      which is complex. And of course it will be useless without using the same\n      test-suite in the actual application that consumes the library\n\nWe consider infrastructure attacks like rogue NPM modules very important; that's\nwhy it's crucial to minimize the amount of 3rd-party dependencies & native bindings.\nIf your app uses 500 dependencies, any dep could get hacked and you'll be downloading\nmalware with every `npm install`. Our goal is to minimize this attack vector.\n\n## Speed\n\nBenchmarks measured on Apple M1 with macOS 12.\nNote that PBKDF2 and Scrypt are tested with extremely high work factor.\nTo run benchmarks, execute `npm run bench:install` and then `npm run bench`\n\n```\nSHA256 32B x 1,219,512 ops/sec @ 820ns/op ± 2.58% (min: 625ns, max: 4ms)\nSHA384 32B x 512,032 ops/sec @ 1μs/op\nSHA512 32B x 509,943 ops/sec @ 1μs/op\nSHA3-256, keccak256, shake256 32B x 199,600 ops/sec @ 5μs/op\nKangaroo12 32B x 336,360 ops/sec @ 2μs/op\nMarsupilami14 32B x 298,418 ops/sec @ 3μs/op\nBLAKE2b 32B x 379,794 ops/sec @ 2μs/op\nBLAKE2s 32B x 515,995 ops/sec @ 1μs/op ± 1.07% (min: 1μs, max: 4ms)\nBLAKE3 32B x 588,235 ops/sec @ 1μs/op ± 1.36% (min: 1μs, max: 5ms)\nRIPEMD160 32B x 1,140,250 ops/sec @ 877ns/op ± 3.12% (min: 708ns, max: 6ms)\nHMAC-SHA256 32B x 377,358 ops/sec @ 2μs/op\n\nHKDF-SHA256 32B x 108,377 ops/sec @ 9μs/op\nPBKDF2-HMAC-SHA256 262144 x 3 ops/sec @ 326ms/op\nPBKDF2-HMAC-SHA512 262144 x 1 ops/sec @ 970ms/op\nScrypt r: 8, p: 1, n: 262144 x 1 ops/sec @ 616ms/op\n```\n\nCompare to native node.js implementation that uses C bindings instead of pure-js code:\n\n```\nSHA256 32B node x 1,302,083 ops/sec @ 768ns/op ± 10.54% (min: 416ns, max: 7ms)\nSHA384 32B node x 975,609 ops/sec @ 1μs/op ± 11.32% (min: 625ns, max: 8ms)\nSHA512 32B node x 983,284 ops/sec @ 1μs/op ± 11.24% (min: 625ns, max: 8ms)\nSHA3-256 32B node x 910,746 ops/sec @ 1μs/op ± 12.19% (min: 666ns, max: 10ms)\nkeccak, k12, m14 are not implemented\nBLAKE2b 32B node x 967,117 ops/sec @ 1μs/op ± 11.26% (min: 625ns, max: 9ms)\nBLAKE2s 32B node x 1,055,966 ops/sec @ 947ns/op ± 11.07% (min: 583ns, max: 7ms)\nBLAKE3 is not implemented\nRIPEMD160 32B node x 1,002,004 ops/sec @ 998ns/op ± 10.66% (min: 625ns, max: 7ms)\nHMAC-SHA256 32B node x 919,963 ops/sec @ 1μs/op ± 6.13% (min: 833ns, max: 5ms)\nHKDF-SHA256 32 node x 369,276 ops/sec @ 2μs/op ± 13.59% (min: 1μs, max: 9ms)\nPBKDF2-HMAC-SHA256 262144 node x 25 ops/sec @ 39ms/op\nPBKDF2-HMAC-SHA512 262144 node x 7 ops/sec @ 132ms/op\nScrypt r: 8, p: 1, n: 262144 node x 1 ops/sec @ 523ms/op\n```\n\nIt is possible to [make this library 4x+ faster](./benchmark/README.md) by\n_doing code generation of full loop unrolls_. We've decided against it. Reasons:\n\n- the library must be auditable, with minimum amount of code, and zero dependencies\n- most method invocations with the lib are going to be something like hashing 32b to 64kb of data\n- hashing big inputs is 10x faster with low-level languages, which means you should probably pick 'em instead\n\nThe current performance is good enough when compared to other projects; SHA256 takes only 900 nanoseconds to run.\n\n## Contributing & testing\n\n1. Clone the repository\n2. `npm install` to install build dependencies like TypeScript\n3. `npm run build` to compile TypeScript code\n4. `npm run test` will execute all main tests. See [our approach to testing](./test/README.md)\n5. `npm run test:dos` will test against DoS; by measuring function complexity. **Takes ~20 minutes**\n6. `npm run test:big` will execute hashing on 4GB inputs,\n   scrypt with 1024 different `N, r, p` combinations, etc. **Takes several hours**. Using 8-32+ core CPU helps.\n\n## License\n\nThe MIT License (MIT)\n\nCopyright (c) 2022 Paul Miller [(https://paulmillr.com)](https://paulmillr.com)\n\nSee LICENSE file.\n",
    "licenseText": "The MIT License (MIT)\n\nCopyright (c) 2022 Paul Miller (https://paulmillr.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the “Software”), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE."
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/@noble/hashes/-/hashes-1.3.2.tgz#6f26dbc8fbc7205873ce3cee2f690eba0d421b39",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/@noble/hashes/-/hashes-1.3.2.tgz",
    "hash": "6f26dbc8fbc7205873ce3cee2f690eba0d421b39",
    "integrity": "sha512-MVC8EAQp7MvEcm30KWENFjgR+Mkmf+D189XJTkFIlwohU5hcBbn1ZkKq7KVTi2Hme3PMGF390DaL52beVrIihQ==",
    "registry": "npm",
    "packageName": "@noble/hashes",
    "cacheIntegrity": "sha512-MVC8EAQp7MvEcm30KWENFjgR+Mkmf+D189XJTkFIlwohU5hcBbn1ZkKq7KVTi2Hme3PMGF390DaL52beVrIihQ== sha1-bybbyPvHIFhzzjzuL2kOug1CGzk="
  },
  "registry": "npm",
  "hash": "6f26dbc8fbc7205873ce3cee2f690eba0d421b39"
}