"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parse = void 0;
const tslib_1 = require("tslib");
const html_parser_1 = require("@markuplint/html-parser");
const parser_utils_1 = require("@markuplint/parser-utils");
const attr_1 = require("./attr");
const vue_parser_1 = tslib_1.__importDefault(require("./vue-parser"));
const parse = rawCode => {
    let ast;
    try {
        ast = (0, vue_parser_1.default)(rawCode);
    }
    catch (err) {
        if (err instanceof SyntaxError && 'lineNumber' in err && 'column' in err) {
            throw new parser_utils_1.ParserError(
            // @ts-ignore
            err.message, {
                // @ts-ignore
                line: err.lineNumber,
                // @ts-ignore
                col: err.column,
                raw: '',
            });
        }
        return {
            nodeList: [],
            isFragment: true,
            parseError: err instanceof Error ? err.message : new Error(`${err}`).message,
        };
    }
    const nodeList = ast.templateBody
        ? (0, html_parser_1.flattenNodes)(traverse(ast.templateBody, null, rawCode), rawCode)
        : [];
    // Remove `</template>`
    const templateEndTagIndex = nodeList.findIndex(node => /\s*<\/\s*template\s*>\s*/i.test(node.raw));
    if (templateEndTagIndex !== -1) {
        const templateEndTag = nodeList[templateEndTagIndex];
        for (const node of nodeList) {
            if (node.nextNode && node.nextNode.uuid === templateEndTag.uuid) {
                node.nextNode = null;
            }
        }
        nodeList.splice(templateEndTagIndex, 1);
    }
    return {
        nodeList,
        isFragment: true,
    };
};
exports.parse = parse;
function traverse(rootNode, parentNode = null, rawHtml) {
    const nodeList = [];
    if (rootNode.type !== 'VElement') {
        return [];
    }
    let prevNode = null;
    for (const vNode of rootNode.children) {
        const node = nodeize(vNode, prevNode, parentNode, rawHtml);
        if (!node) {
            continue;
        }
        if (prevNode) {
            if (node.type !== 'endtag') {
                prevNode.nextNode = node;
            }
            node.prevNode = prevNode;
        }
        prevNode = node;
        nodeList.push(node);
    }
    return nodeList;
}
function nodeize(originNode, prevNode, parentNode, rawHtml) {
    const nextNode = null;
    const startOffset = originNode.range[0];
    const endOffset = originNode.range[1];
    const startLine = originNode.loc.start.line;
    const endLine = originNode.loc.end.line;
    const startCol = originNode.loc.start.column + 1;
    const endCol = originNode.loc.end.column + 1;
    const raw = rawHtml.slice(startOffset, endOffset || startOffset);
    switch (originNode.type) {
        case 'VText': {
            const node = {
                uuid: (0, parser_utils_1.uuid)(),
                raw,
                startOffset,
                endOffset,
                startLine,
                endLine,
                startCol,
                endCol,
                nodeName: '#text',
                type: 'text',
                parentNode,
                prevNode,
                nextNode,
                isFragment: false,
                isGhost: false,
            };
            return node;
        }
        case 'VExpressionContainer': {
            return {
                uuid: (0, parser_utils_1.uuid)(),
                raw,
                startOffset,
                endOffset,
                startLine,
                endLine,
                startCol,
                endCol,
                nodeName: '#vue-expression-conatiner',
                type: 'psblock',
                parentNode,
                prevNode,
                nextNode,
                isFragment: false,
                isGhost: false,
            };
        }
        default: {
            const tagLoc = originNode.startTag;
            const startTagRaw = rawHtml.slice(tagLoc.range[0], tagLoc.range[1]);
            const tagTokens = (0, html_parser_1.parseRawTag)(startTagRaw, startLine, startCol, startOffset);
            const tagName = tagTokens.tagName;
            let endTag = null;
            const endTagLoc = originNode.endTag;
            if (endTagLoc) {
                const endTagRaw = rawHtml.slice(endTagLoc.range[0], endTagLoc.range[1]);
                const endTagTokens = (0, html_parser_1.parseRawTag)(endTagRaw, endTagLoc.loc.start.line, endTagLoc.loc.start.column, endTagLoc.range[0]);
                const endTagName = endTagTokens.tagName;
                endTag = {
                    uuid: (0, parser_utils_1.uuid)(),
                    raw: endTagRaw,
                    startOffset: endTagLoc.range[0],
                    endOffset: endTagLoc.range[1],
                    startLine: endTagLoc.loc.start.line,
                    endLine: endTagLoc.loc.end.line,
                    startCol: endTagLoc.loc.start.column + 1,
                    endCol: endTagLoc.loc.end.column + 1,
                    nodeName: endTagName,
                    type: 'endtag',
                    namespace: originNode.namespace,
                    attributes: endTagTokens.attrs,
                    parentNode,
                    prevNode,
                    nextNode,
                    pearNode: null,
                    isFragment: false,
                    isGhost: false,
                    tagOpenChar: '</',
                    tagCloseChar: '>',
                    isCustomElement: isVueComponentName(endTagName),
                };
            }
            const startTag = {
                uuid: (0, parser_utils_1.uuid)(),
                raw: startTagRaw,
                startOffset,
                endOffset: startOffset + startTagRaw.length,
                startLine,
                endLine: (0, parser_utils_1.getEndLine)(startTagRaw, startLine),
                startCol,
                endCol: (0, parser_utils_1.getEndCol)(startTagRaw, startCol),
                nodeName: tagName,
                type: 'starttag',
                namespace: originNode.namespace,
                attributes: tagTokens.attrs.map(attr_1.attr),
                hasSpreadAttr: false,
                parentNode,
                prevNode,
                nextNode,
                pearNode: endTag,
                selfClosingSolidus: tagTokens.selfClosingSolidus,
                endSpace: tagTokens.endSpace,
                isFragment: false,
                isGhost: false,
                tagOpenChar: '<',
                tagCloseChar: '>',
                isCustomElement: isVueComponentName(tagName),
            };
            if (endTag) {
                endTag.pearNode = startTag;
            }
            startTag.childNodes = traverse(originNode, startTag, rawHtml);
            return startTag;
        }
    }
}
function isVueComponentName(name) {
    return (0, parser_utils_1.isPotentialCustomElementName)(name) || /^[A-Z]|\./.test(name);
}
