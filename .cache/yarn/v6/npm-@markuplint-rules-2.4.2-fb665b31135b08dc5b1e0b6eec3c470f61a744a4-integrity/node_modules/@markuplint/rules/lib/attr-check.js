"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.valueCheck = exports.attrCheck = void 0;
const types_1 = require("@markuplint/types");
const create_message_1 = require("./create-message");
const debug_1 = require("./debug");
/**
 * Use in rules `invalid-attr` and `wai-aria`
 *
 * @param name
 * @param value
 * @param isCustomRule
 * @param spec
 */
function attrCheck(t, name, value, isCustomRule, spec) {
    if (!isCustomRule) {
        if (/^data-.+$/.test(name)) {
            // Ignore checking because "data-*" attribute is any type
            return false;
        }
        if (/^aria-.+$|^role$/.test(name)) {
            // Ignore checking because ARIA attributes are check on another rule
            return false;
        }
    }
    // Existance
    if (!spec) {
        (0, debug_1.log)('The "%s" attribute DOES\'NT EXIST in the spec', name);
        return {
            invalidType: 'non-existent',
            message: t('{0} is {1:c}', t('the "{0*}" {1}', name, 'attribute'), 'disallowed'),
        };
    }
    const nameCaseSensitive = /[A-Z]/.test(spec.name);
    if (nameCaseSensitive && name !== spec.name) {
        (0, debug_1.log)('The "%s" attribute name is unmatched in case-sensitive', name);
        return {
            invalidType: 'non-existent',
            message: t('{0} is {1:c}', t('the "{0*}" {1}', name, 'attribute'), 'disallowed') +
                t('. ') +
                t('Did you mean "{0*}"?', spec.name),
        };
    }
    const types = Array.isArray(spec.type) ? spec.type : [spec.type];
    const invalidList = types.map(type => {
        if (!type) {
            (0, debug_1.log)('attrCheck: %o', arguments);
            throw new Error('type is empty in spec');
        }
        const invalid = valueCheck(t, name, value, type);
        if (invalid) {
            if (typeof invalid === 'string') {
                return {
                    invalidType: 'invalid-value',
                    message: invalid,
                };
            }
            else {
                return {
                    invalidType: 'invalid-value',
                    message: invalid[0],
                    loc: invalid[1],
                };
            }
        }
        return false;
    });
    if (invalidList.some(i => !i)) {
        return false;
    }
    const invalid = invalidList.find(i => i);
    return invalid || false;
}
exports.attrCheck = attrCheck;
function valueCheck(t, name, value, type) {
    if (type === 'Boolean') {
        // Valid because an attribute is exist
        return false;
    }
    const matches = (0, types_1.check)(value, type);
    if (debug_1.log.enabled) {
        (0, debug_1.log)(`Result ([${name}="${value}"]): %O`, { ...matches, type });
    }
    if (!matches.matched) {
        const location = {
            raw: matches.raw,
            line: matches.line - 1,
            col: matches.column - 1,
        };
        const base = t('the "{0*}" {1}', name, 'attribute');
        const message = (0, create_message_1.createMessageValueExpected)(t, base, type, matches);
        return [message, location];
    }
    return false;
}
exports.valueCheck = valueCheck;
