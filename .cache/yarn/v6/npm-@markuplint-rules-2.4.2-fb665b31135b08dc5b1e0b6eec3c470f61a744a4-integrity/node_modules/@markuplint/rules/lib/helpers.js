"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeCharRef = exports.getOwnedLabel = exports.accnameMayBeMutable = exports.checkAria = exports.checkAriaValue = exports.getComputedRole = exports.getImplicitRole = exports.getPermittedRoles = exports.getRoleSpec = exports.ariaSpec = exports.toNormalizedValue = exports.isValidAttr = exports.htmlSpec = exports.rePCENChar = exports.match = exports.attrMatches = void 0;
const html_entities_1 = require("html-entities");
const attr_check_1 = require("./attr-check");
function attrMatches(node, condition) {
    if (!condition) {
        return true;
    }
    let matched = false;
    if ('self' in condition && condition.self) {
        const condSelector = Array.isArray(condition.self) ? condition.self.join(',') : condition.self;
        matched = node.matches(condSelector);
    }
    if ('ancestor' in condition && condition.ancestor) {
        let _node = node.parentNode;
        while (_node) {
            if (_node.type === 'Element') {
                const condSelector = Array.isArray(condition.ancestor)
                    ? condition.ancestor.join(',')
                    : condition.ancestor;
                if (_node.matches(condSelector)) {
                    matched = true;
                    break;
                }
            }
            _node = _node.parentNode;
        }
    }
    return matched;
}
exports.attrMatches = attrMatches;
function match(needle, pattern) {
    const matches = pattern.match(/^\/(.*)\/(i|g|m)*$/);
    if (matches && matches[1]) {
        const re = matches[1];
        const flag = matches[2];
        return new RegExp(re, flag).test(needle);
    }
    return needle === pattern;
}
exports.match = match;
/**
 * PotentialCustomElementName
 *
 * @see https://spec.whatwg.org/multipage/custom-elements.html#prod-potentialcustomelementname
 *
 * > PotentialCustomElementName ::=
 * >   [a-z] (PCENChar)* '-' (PCENChar)*
 * > PCENChar ::=
 * >   "-" | "." | [0-9] | "_" | [a-z] | #xB7 | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x37D] |
 * >   [#x37F-#x1FFF] | [#x200C-#x200D] | [#x203F-#x2040] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]
 * > This uses the EBNF notation from the XML specification. [XML]
 *
 * ASCII-case-insensitively.
 * Originally, it is not possible to define a name including ASCII upper alphas in the custom element, but it is not treated as illegal by the HTML parser.
 */
exports.rePCENChar = [
    '\\-',
    '\\.',
    '[0-9]',
    '_',
    '[a-z]',
    '\u00B7',
    '[\u00C0-\u00D6]',
    '[\u00D8-\u00F6]',
    '[\u00F8-\u037D]',
    '[\u037F-\u1FFF]',
    '[\u200C-\u200D]',
    '[\u203F-\u2040]',
    '[\u2070-\u218F]',
    '[\u2C00-\u2FEF]',
    '[\u3001-\uD7FF]',
    '[\uF900-\uFDCF]',
    '[\uFDF0-\uFFFD]',
    '[\uD800-\uDBFF][\uDC00-\uDFFF]',
].join('|');
function htmlSpec(specs, nameWithNS) {
    const spec = specs.specs.find(spec => spec.name === nameWithNS);
    return spec || null;
}
exports.htmlSpec = htmlSpec;
function isValidAttr(t, name, value, isDynamicValue, node, attrSpecs, log) {
    let invalid = false;
    const spec = attrSpecs.find(s => s.name.toLowerCase() === name.toLowerCase());
    log && log('Spec of the %s attr: %o', name, spec);
    invalid = (0, attr_check_1.attrCheck)(t, name, value, false, spec);
    if (!invalid && spec && spec.condition && !node.hasSpreadAttr && !attrMatches(node, spec.condition)) {
        invalid = {
            invalidType: 'non-existent',
            message: t('{0} is {1}', t('the "{0*}" {1}', name, 'attribute'), 'disallowed'),
        };
    }
    if (invalid && invalid.invalidType === 'invalid-value' && isDynamicValue) {
        invalid = false;
    }
    return invalid;
}
exports.isValidAttr = isValidAttr;
function toNormalizedValue(value, spec) {
    let normalized = value;
    if (!spec.caseSensitive) {
        normalized = normalized.toLowerCase();
    }
    if (typeof spec.type === 'string') {
        if (spec.type[0] === '<') {
            normalized = normalized.toLowerCase().trim().replace(/\s+/g, ' ');
        }
    }
    else {
        if ('token' in spec.type) {
            if (spec.type.caseInsensitive) {
                normalized = normalized.toLowerCase();
            }
            if (!spec.type.disallowToSurroundBySpaces) {
                normalized = normalized.trim();
            }
            if (spec.type.separator === 'space') {
                normalized = normalized.replace(/\s+/g, ' ');
            }
            if (spec.type.separator === 'comma') {
                normalized = normalized.replace(/\s*,\s*/g, ',');
            }
        }
    }
    return normalized;
}
exports.toNormalizedValue = toNormalizedValue;
function ariaSpec(specs) {
    const roles = specs.def['#roles'];
    const ariaAttrs = specs.def['#ariaAttrs'];
    return {
        roles,
        ariaAttrs,
    };
}
exports.ariaSpec = ariaSpec;
function getRoleSpec(specs, roleName) {
    const role = getRoleByName(specs, roleName);
    if (!role) {
        return null;
    }
    const superClassRoles = recursiveTraverseSuperClassRoles(specs, roleName);
    return {
        name: role.name,
        isAbstract: !!role.isAbstract,
        accessibleNameRequired: role.accessibleNameRequired,
        statesAndProps: role.ownedAttribute,
        superClassRoles,
    };
}
exports.getRoleSpec = getRoleSpec;
function getRoleByName(specs, roleName) {
    const roles = specs.def['#roles'];
    const role = roles.find(r => r.name === roleName);
    return role;
}
function getSuperClassRoles(specs, roleName) {
    const role = getRoleByName(specs, roleName);
    return ((role === null || role === void 0 ? void 0 : role.generalization.map(roleName => getRoleByName(specs, roleName)).filter((role) => !!role)) || null);
}
function recursiveTraverseSuperClassRoles(specs, roleName) {
    const roles = [];
    const superClassRoles = getSuperClassRoles(specs, roleName);
    if (superClassRoles) {
        roles.push(...superClassRoles);
        for (const superClassRole of superClassRoles) {
            const ancestorRoles = recursiveTraverseSuperClassRoles(specs, superClassRole.name);
            roles.push(...ancestorRoles);
        }
    }
    return roles;
}
/**
 * Getting permitted ARIA roles.
 *
 * - If an array, it is role list.
 * - If `true`, this mean is "Any".
 * - If `false`, this mean is "No".
 */
function getPermittedRoles(specs, el) {
    var _a;
    const implicitRole = getImplicitRole(specs, el);
    const spec = (_a = htmlSpec(specs, el.nodeName)) === null || _a === void 0 ? void 0 : _a.permittedRoles;
    if (!spec) {
        return true;
    }
    if (spec.conditions) {
        for (const { condition, roles } of spec.conditions) {
            if (el.matches(condition)) {
                return mergeRoleList(implicitRole, roles);
            }
        }
    }
    if (implicitRole && Array.isArray(spec.roles)) {
        return [implicitRole, ...spec.roles];
    }
    if (implicitRole && spec.roles === false) {
        return [implicitRole];
    }
    return mergeRoleList(implicitRole, spec.roles);
}
exports.getPermittedRoles = getPermittedRoles;
function mergeRoleList(implicitRole, permittedRoles) {
    if (implicitRole && Array.isArray(permittedRoles)) {
        return [implicitRole, ...permittedRoles];
    }
    if (implicitRole && permittedRoles === false) {
        return [implicitRole];
    }
    return permittedRoles;
}
function getImplicitRole(specs, el) {
    var _a;
    const implicitRole = (_a = htmlSpec(specs, el.nodeName)) === null || _a === void 0 ? void 0 : _a.implicitRole;
    if (!implicitRole) {
        return false;
    }
    if (implicitRole.conditions) {
        for (const { condition, role } of implicitRole.conditions) {
            if (el.matches(condition)) {
                return role;
            }
        }
    }
    return implicitRole.role;
}
exports.getImplicitRole = getImplicitRole;
function getComputedRole(specs, el) {
    const roleAttrTokens = el.getAttributeToken('role');
    const roleAttr = roleAttrTokens[0];
    if (roleAttr) {
        const roleName = roleAttr.getValue().potential.trim().toLowerCase();
        return {
            name: roleName,
            isImplicit: false,
        };
    }
    const implicitRole = getImplicitRole(specs, el);
    if (implicitRole) {
        return {
            name: implicitRole,
            isImplicit: true,
        };
    }
    return null;
}
exports.getComputedRole = getComputedRole;
/**
 *
 * @see https://www.w3.org/TR/wai-aria-1.2/#propcharacteristic_value
 *
 * @param type
 * @param value
 * @param tokenEnum
 */
function checkAriaValue(type, value, tokenEnum) {
    switch (type) {
        case 'token': {
            return tokenEnum.includes(value);
        }
        case 'token list': {
            const list = value.split(/\s+/g).map(s => s.trim());
            return list.every(token => tokenEnum.includes(token));
        }
        case 'string':
        case 'ID reference':
        case 'ID reference list': {
            return true;
        }
        case 'true/false': {
            return ['true', 'false'].includes(value);
        }
        case 'tristate': {
            return ['mixed', 'true', 'false', 'undefined'].includes(value);
        }
        case 'true/false/undefined': {
            return ['true', 'false', 'undefined'].includes(value);
        }
        case 'integer': {
            return parseInt(value).toString() === value;
        }
        case 'number': {
            return parseFloat(value).toString() === value;
        }
    }
    // For skipping checking
    return true;
}
exports.checkAriaValue = checkAriaValue;
function checkAria(specs, attrName, currentValue, role) {
    const ariaAttrs = specs.def['#ariaAttrs'];
    const aria = ariaAttrs.find(a => a.name === attrName);
    if (!aria) {
        return {
            currentValue,
            // For skipping checking
            isValid: true,
        };
    }
    let valueType = aria.value;
    if (role && aria.conditionalValue) {
        for (const cond of aria.conditionalValue) {
            if (cond.role.includes(role)) {
                valueType = cond.value;
                break;
            }
        }
    }
    const isValid = checkAriaValue(valueType, currentValue, aria.enum);
    return {
        ...aria,
        currentValue,
        isValid,
    };
}
exports.checkAria = checkAria;
function accnameMayBeMutable(el, document) {
    if (el.hasMutableAttributes() || el.hasMutableChildren(true)) {
        return true;
    }
    const ownedLable = getOwnedLabel(el, document);
    if (ownedLable && (ownedLable.hasMutableAttributes() || ownedLable.hasMutableChildren(true))) {
        return true;
    }
    return false;
}
exports.accnameMayBeMutable = accnameMayBeMutable;
const labelable = ['button', 'input:not([type=hidden])', 'meter', 'output', 'progress', 'select', 'textarea'];
function getOwnedLabel(el, docuemnt) {
    if (!labelable.some(cond => el.matches(cond))) {
        return null;
    }
    let ownedLable = el.closest('label');
    if (!ownedLable) {
        const id = el.getAttribute('id');
        if (id) {
            ownedLable = docuemnt.querySelector(`label[for="${id}"]`);
        }
    }
    return ownedLable;
}
exports.getOwnedLabel = getOwnedLabel;
function decodeCharRef(characterReference) {
    return (0, html_entities_1.decode)(characterReference);
}
exports.decodeCharRef = decodeCharRef;
