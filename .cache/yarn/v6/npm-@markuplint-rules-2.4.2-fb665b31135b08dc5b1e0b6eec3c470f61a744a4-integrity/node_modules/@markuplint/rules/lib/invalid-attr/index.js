"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ml_core_1 = require("@markuplint/ml-core");
const attr_check_1 = require("../attr-check");
const debug_1 = require("../debug");
const helpers_1 = require("../helpers");
const log = debug_1.log.extend('invalid-attr');
exports.default = (0, ml_core_1.createRule)({
    defaultOptions: {},
    async verify({ document, report, t }) {
        await document.walkOn('Element', node => {
            var _a, _b, _c, _d, _e, _f, _g, _h;
            const attrSpecs = (0, ml_core_1.getAttrSpecs)(node.nameWithNS, document.specs);
            for (const attr of node.attributes) {
                if (attr.attrType === 'html-attr' && attr.isDirective) {
                    continue;
                }
                const attrName = attr.getName();
                const name = attrName.potential;
                if (!node.isCustomElement && attr.attrType === 'html-attr' && attr.candidate) {
                    const message = t('{0} is {1:c}', t('the "{0*}" {1}', attrName.raw, 'attribute'), 'disallowed') +
                        t('. ') +
                        t('Did you mean "{0}"?', attr.candidate);
                    report({
                        scope: node,
                        message: message,
                        line: attrName.line,
                        col: attrName.col,
                        raw: attrName.raw,
                    });
                    continue;
                }
                const attrValue = attr.getValue();
                const value = attrValue.potential;
                if (node.rule.option.ignoreAttrNamePrefix) {
                    const ignoreAttrNamePrefixes = Array.isArray(node.rule.option.ignoreAttrNamePrefix)
                        ? node.rule.option.ignoreAttrNamePrefix
                        : [node.rule.option.ignoreAttrNamePrefix];
                    if (ignoreAttrNamePrefixes.some(prefix => name.indexOf(prefix) === 0)) {
                        continue;
                    }
                }
                let invalid = false;
                const customRule = node.rule.option.attrs ? node.rule.option.attrs[name] : null;
                if (customRule) {
                    if (attr.attrType === 'html-attr' && attr.isDynamicValue) {
                        continue;
                    }
                    if ('enum' in customRule) {
                        invalid = (0, attr_check_1.attrCheck)(t, name.toLowerCase(), value, true, {
                            name,
                            type: {
                                enum: customRule.enum,
                            },
                            description: '',
                        });
                    }
                    else if ('pattern' in customRule) {
                        if (!(0, helpers_1.match)(value, customRule.pattern)) {
                            invalid = {
                                invalidType: 'invalid-value',
                                message: t('{0} is unmatched with the below patterns: {1}', t('the "{0*}" {1}', name, 'attribute'), customRule.pattern),
                            };
                        }
                    }
                    else if ('type' in customRule) {
                        invalid = (0, attr_check_1.attrCheck)(t, name, value, true, { name, type: customRule.type, description: '' });
                    }
                    else if ('disallowed' in customRule && customRule.disallowed) {
                        invalid = {
                            invalidType: 'non-existent',
                            message: t('{0} is disallowed', t('the "{0*}" {1}', name, 'attribute')),
                        };
                    }
                }
                else if (!node.isCustomElement && attrSpecs) {
                    log('Checking %s[%s="%s"]', node.nodeName, name, value);
                    invalid = (0, helpers_1.isValidAttr)(t, name, value, (attr.attrType === 'html-attr' && attr.isDynamicValue) || false, node, attrSpecs, log);
                }
                if (invalid) {
                    switch (invalid.invalidType) {
                        case 'invalid-value': {
                            report({
                                scope: node,
                                message: invalid.message,
                                line: attrValue.line + ((_b = (_a = invalid.loc) === null || _a === void 0 ? void 0 : _a.line) !== null && _b !== void 0 ? _b : 0),
                                col: ((_c = invalid.loc) === null || _c === void 0 ? void 0 : _c.line) ? ((_d = invalid.loc) === null || _d === void 0 ? void 0 : _d.col) + 1 : attrValue.col + ((_f = (_e = invalid.loc) === null || _e === void 0 ? void 0 : _e.col) !== null && _f !== void 0 ? _f : 0),
                                raw: (_h = (_g = invalid.loc) === null || _g === void 0 ? void 0 : _g.raw) !== null && _h !== void 0 ? _h : value,
                            });
                            break;
                        }
                        case 'non-existent': {
                            const spec = (0, helpers_1.htmlSpec)(document.specs, node.nameWithNS);
                            if (spec === null || spec === void 0 ? void 0 : spec.possibleToAddProperties) {
                                continue;
                            }
                            report({
                                scope: node,
                                message: invalid.message,
                                line: attrName.line,
                                col: attrName.col,
                                raw: attrName.raw,
                            });
                        }
                    }
                }
            }
        });
    },
});
