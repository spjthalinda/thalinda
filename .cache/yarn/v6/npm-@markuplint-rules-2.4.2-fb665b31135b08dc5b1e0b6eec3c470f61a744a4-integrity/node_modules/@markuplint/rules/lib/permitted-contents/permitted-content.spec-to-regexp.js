"use strict";
var _TagList_list;
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const helpers_1 = require("../helpers");
const array_combination_1 = tslib_1.__importDefault(require("./array.combination"));
const unfold_content_models_to_tags_1 = tslib_1.__importDefault(require("./unfold-content-models-to-tags"));
const ALL = '(?:<[^>]+>)?';
const ___TRANSPARENT___ = '___TRANSPARENT___';
const ___InTRANSPARENT = '___InTRANSPARENT';
const CUSTOM_ELEMENT = `(?:<[a-z](?:${helpers_1.rePCENChar})*\\-(?:${helpers_1.rePCENChar})*>)`;
class ExpGenerator {
    constructor(_id) {
        this._id = _id;
        this._idCounter = 0;
    }
    specToRegExp(contentRule, parentExp = null, ownNS = null) {
        if (contentRule === true) {
            return new RegExp(`^(?:${ALL})+$`);
        }
        if (contentRule === false) {
            return new RegExp('^$');
        }
        const parentPattern = parentExp ? parentExp.source.replace(/^\^|\$$/g, '') : ALL;
        const pattern = this._toPattern(contentRule, null, ownNS, 1, 1).replace(___TRANSPARENT___, () => `(?<TRANSPARENT_${this._id}${this._idCounter++}>${parentPattern})`);
        return new RegExp(`^${pattern}$`, 'i');
    }
    _toPattern(contentRule, ignore, ownNS, min, max) {
        if (isTarget(contentRule)) {
            return this._targetTags(contentRule, ignore, ownNS, min, max);
        }
        let notAllowedDescendantsNamedCapture = '';
        const exp = [];
        for (const nodeRule of contentRule) {
            let pattern = '';
            if (isRequiredContents(nodeRule)) {
                if (nodeRule.notAllowedDescendants) {
                    notAllowedDescendantsNamedCapture = nodeRule.notAllowedDescendants
                        .map(r => r.replace('#', '_'))
                        .join('_');
                    if (nodeRule.require === '#transparent') {
                        notAllowedDescendantsNamedCapture += `${___InTRANSPARENT}`;
                    }
                }
                pattern = this._targetTags(nodeRule.require, nodeRule.ignore || null, ownNS, nodeRule.min || 1, nodeRule.max || nodeRule.min || 1);
            }
            else if (isOptionalContents(nodeRule)) {
                if (nodeRule.notAllowedDescendants) {
                    notAllowedDescendantsNamedCapture = nodeRule.notAllowedDescendants
                        .map(r => r.replace('#', '_'))
                        .join('_');
                    if (nodeRule.optional === '#transparent') {
                        notAllowedDescendantsNamedCapture += `${___InTRANSPARENT}`;
                    }
                }
                pattern = this._targetTags(nodeRule.optional, nodeRule.ignore || null, ownNS, 0, nodeRule.max || 1);
            }
            else if (isOneOrMoreContents(nodeRule)) {
                if (nodeRule.notAllowedDescendants) {
                    notAllowedDescendantsNamedCapture = nodeRule.notAllowedDescendants
                        .map(r => r.replace('#', '_'))
                        .join('_');
                    if (nodeRule.oneOrMore === '#transparent') {
                        notAllowedDescendantsNamedCapture += `${___InTRANSPARENT}`;
                    }
                }
                pattern = this._toPattern(nodeRule.oneOrMore, nodeRule.ignore || null, ownNS, 1, nodeRule.max || Infinity);
            }
            else if (isZeroOrMoreContents(nodeRule)) {
                if (nodeRule.notAllowedDescendants) {
                    notAllowedDescendantsNamedCapture = nodeRule.notAllowedDescendants
                        .map(r => r.replace('#', '_'))
                        .join('_');
                    if (nodeRule.zeroOrMore === '#transparent') {
                        notAllowedDescendantsNamedCapture += `${___InTRANSPARENT}`;
                    }
                }
                pattern = this._toPattern(nodeRule.zeroOrMore, nodeRule.ignore || null, ownNS, 0, nodeRule.max || Infinity);
            }
            else if (isChoiceContents(nodeRule)) {
                pattern = `(?:${nodeRule.choice.map(choice => this._toPattern(choice, null, ownNS, 1, 1)).join('|')})`;
            }
            else if (isInterleaveContents(nodeRule)) {
                pattern = this._interleavePattern(nodeRule.interleave, ownNS);
            }
            exp.push(pattern);
        }
        const range = createRange(min, max);
        const c = notAllowedDescendantsNamedCapture
            ? `?<NAD_${this._id}${this._idCounter++}_${notAllowedDescendantsNamedCapture}>`
            : '?:';
        if (1 === exp.length && range === '') {
            if (notAllowedDescendantsNamedCapture) {
                return `(${c}${exp[0]})`;
            }
            return exp[0];
        }
        if (range === '') {
            if (notAllowedDescendantsNamedCapture) {
                return `(${c}${exp.join('')})`;
            }
            return exp.join('');
        }
        return `(${c}${exp.join('')})${range}`;
    }
    _interleavePattern(contents, ownNS) {
        const interleave = contents.map(content => this._toPattern(content, null, ownNS, 1, 1));
        const patterns = (0, array_combination_1.default)(interleave).map((pattern, i) => pattern.join('').replace(/(\(\?<[A-Z]+_)([0-9]+)_/g, ($0, $1, $2) => `${$1}${$2}${i}_`));
        return join(patterns);
    }
    _targetTags(target, ignore, ownNS, min, max) {
        const tagList = this._resolveTags(target, ownNS);
        const ignoreList = ignore ? this._resolveTags(ignore, ownNS) : null;
        if (ignoreList) {
            ignoreList.forEach(ignore => tagList.delete(ignore));
        }
        return join(Array.from(tagList), createRange(min, max));
    }
    _resolveTags(target, ownNS) {
        const list = Array.isArray(target) ? target : [target];
        const tagList = new TagList();
        for (const name of list) {
            if (name !== '#text' && name[0] === '#') {
                switch (name) {
                    case '#transparent': {
                        tagList.addPattern(___TRANSPARENT___);
                        break;
                    }
                    case '#custom': {
                        tagList.addPattern(CUSTOM_ELEMENT);
                        break;
                    }
                    default: {
                        const selectors = (0, unfold_content_models_to_tags_1.default)(name);
                        const counter = this._idCounter++;
                        selectors.forEach(selector => {
                            if (selector === '#custom') {
                                tagList.addPattern(CUSTOM_ELEMENT);
                                return;
                            }
                            if (/]$/i.test(selector)) {
                                const [, tagName] = /^([^[\]]+)\[[^\]]+\]$/.exec(selector) || [];
                                // ACM = Attributes by content model
                                const exp = `(?<ACM_${this._id}${counter}_${name.slice(1)}_${tagName}><${tagName}>)`;
                                tagList.addPattern(exp);
                                return;
                            }
                            tagList.addTag(selector, ownNS);
                        });
                    }
                }
                continue;
            }
            tagList.addTag(name, ownNS);
        }
        return tagList.result();
    }
}
exports.default = ExpGenerator;
class TagList {
    constructor() {
        _TagList_list.set(this, new Set());
    }
    addPattern(pattern) {
        tslib_1.__classPrivateFieldGet(this, _TagList_list, "f").add(pattern);
    }
    addTag(tagNameOrSelector, ownNS) {
        if (ownNS) {
            tagNameOrSelector = tagNameOrSelector.replace(new RegExp(`^${ownNS}:`, 'i'), '');
        }
        tslib_1.__classPrivateFieldGet(this, _TagList_list, "f").add(`<${tagNameOrSelector}>`);
    }
    result() {
        return tslib_1.__classPrivateFieldGet(this, _TagList_list, "f");
    }
}
_TagList_list = new WeakMap();
function isRequiredContents(contents) {
    return 'require' in contents;
}
function isOptionalContents(contents) {
    return 'optional' in contents;
}
function isOneOrMoreContents(contents) {
    return 'oneOrMore' in contents;
}
function isZeroOrMoreContents(contents) {
    return 'zeroOrMore' in contents;
}
function isChoiceContents(contents) {
    return 'choice' in contents;
}
function isInterleaveContents(contents) {
    return 'interleave' in contents;
}
function createRange(min, max) {
    let result = `{${min},${max}}`;
    switch (result) {
        case '{0,1}':
            result = '?';
            break;
        case '{1,1}':
            result = '';
            break;
        case '{0,Infinity}':
            result = '*';
            break;
        case '{1,Infinity}':
            result = '+';
            break;
    }
    return result;
}
function isTarget(contentRule) {
    if (typeof contentRule === 'string') {
        return true;
    }
    return contentRule.some((i) => typeof i === 'string');
}
function join(pattern, range = '') {
    if (1 === pattern.length && range === '') {
        return pattern[0];
    }
    return `(?:${pattern.join('|')})${range}`;
}
