'use strict';

var pluginutils = require('@rollup/pluginutils');
var acorn = require('acorn');
var escodegen = require('escodegen');
var unassertjs = require('unassert');
var convert = require('convert-source-map');
var multiStageSourcemap = require('multi-stage-sourcemap');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var acorn__default = /*#__PURE__*/_interopDefaultLegacy(acorn);
var escodegen__default = /*#__PURE__*/_interopDefaultLegacy(escodegen);
var unassertjs__default = /*#__PURE__*/_interopDefaultLegacy(unassertjs);
var convert__default = /*#__PURE__*/_interopDefaultLegacy(convert);

// Adapted from https://github.com/unassert-js/unassertify/blob/master/index.js
// by Takuto Wada (MIT-licensed)

function handleIncomingSourceMap(originalCode) {
    const commented = convert__default["default"].fromSource(originalCode);
    if (commented) {
        return commented.toObject();
    }
    return null;
}

function overwritePropertyIfExists(name, from, to) {
    // eslint-disable-next-line no-prototype-builtins
    if (from.hasOwnProperty(name)) {
        to.setProperty(name, from[name]);
    }
}
function reconnectSourceMap(inMap, outMap) {
    const mergedRawMap = mergeSourceMap(inMap, outMap.toObject());
    const reMap = convert__default["default"].fromObject(mergedRawMap);
    overwritePropertyIfExists('sources', inMap, reMap);
    overwritePropertyIfExists('sourceRoot', inMap, reMap);
    overwritePropertyIfExists('sourcesContent', inMap, reMap);
    return reMap;
}

function mergeSourceMap(incomingSourceMap, outgoingSourceMap) {
    if (typeof outgoingSourceMap === 'string' || outgoingSourceMap instanceof String) {
        outgoingSourceMap = JSON.parse(outgoingSourceMap);
    }
    if (!incomingSourceMap) {
        return outgoingSourceMap;
    }
    return JSON.parse(multiStageSourcemap.transfer({fromSourceMap: outgoingSourceMap, toSourceMap: incomingSourceMap}));
}

function unassert(options = {}) {
    if (options.sourcemap === undefined) {
        options.sourcemap = true;
    }

    const filter = pluginutils.createFilter(
        options.include || ['*.js', '**/*.js'],
        options.exclude
    );

    return {
        name: 'unassert',
        transform(code, id) {
            if (!filter(id)) { return null; }

            return new Promise((resolve) => {
                const comments = [];
                const tokens = [];

                const ast = acorn__default["default"].parse(code, {
                    sourceType: 'module',
                    ecmaVersion: 'latest',
                    locations: true,
                    ranges: true,
                    onComment: comments,
                    onToken: tokens,
                });

                escodegen__default["default"].attachComments(ast, comments, tokens);
                const unassertedAst = escodegen__default["default"].generate(unassertjs__default["default"](ast), {
                    sourceMap: id,
                    sourceContent: code,
                    sourceMapWithCode: true,
                    comment: true,
                });

                const inMap = options.sourcemap && handleIncomingSourceMap(code);
                let outMap = convert__default["default"].fromJSON(unassertedAst.map.toString());
                if (inMap) {
                    outMap = reconnectSourceMap(inMap, outMap);
                }

                resolve({
                    code: unassertedAst.code,
                    map: outMap.toObject()
                });
            });
        }
    };
}

module.exports = unassert;
